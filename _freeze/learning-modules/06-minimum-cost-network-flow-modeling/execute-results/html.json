{
  "hash": "dd5348f3b049281ec2e5c95eb9f44edf",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"06 | Minimum Cost Network Flow Models\"\nsubtitle: \"Optimizing Transportation in Supply Chain Networks\"\nformat: \n  html:\n    other-links:\n      - text: \"min_cost_ex_arcs.csv\"\n        href: \"data/min_cost_ex_arcs.csv\"\n        icon: file-earmark-spreadsheet\n      - text: \"min_cost_ex_nodes.csv\"\n        href: \"data/min_cost_ex_nodes.csv\"\n        icon: file-earmark-spreadsheet\n      - text: \"min_cost_ex_solution.csv\"\n        href: \"data/min_cost_ex_solution.csv\"\n        icon: file-earmark-spreadsheet\n      - text: \"optimal_flows.csv (Oil Transport Problem)\"\n        href: \"optimal_flows.csv\"\n        icon: file-earmark-spreadsheet\norder: 6\n---\n\n\n\n\n## Overview\n\nNetwork flow models are powerful tools for optimizing the movement of goods through a supply chain network. The minimum cost network flow model helps determine the most cost-effective way to transport products from origins (like factories) to destinations (like warehouses).\n\nIn this module, you will learn how to:\n\n1. Understand the key components of network flow problems\n2. Formulate these as linear programming models\n3. Implement and solve them using both Excel Solver and Python/Gurobi\n4. Analyze different scenarios to make better supply chain decisions\n\n## Key Components of Network Flow Problems\n\nA minimum cost network flow problem has three main components:\n\n1. **Nodes**: Points in the network representing locations\n   - **Supply nodes**: Where products originate (factories, plants)\n   - **Transshipment nodes**: Intermediate points (distribution centers)\n   - **Demand nodes**: Where products are required (warehouses, customers)\n\n2. **Arcs**: Connections between nodes representing possible flow paths\n   - Each arc has a **cost per unit** of flow\n   - Each arc may have a **capacity limit**\n\n3. **Flows**: The amount of resource moving along each arc\n   - Flow must be conserved at each node (total inflow = total outflow, except at supply/demand nodes)\n   - Total supply must equal total demand for the problem to have feasible solutions\n\n## Mathematical Formulation\n\nLet's define:\n\n- $x_{ij}$ = flow from node $i$ to node $j$\n- $c_{ij}$ = cost per unit flow from node $i$ to node $j$\n- $u_{ij}$ = capacity of arc from node $i$ to node $j$\n- $b_i$ = net flow at node $i$ (positive for supply, negative for demand, zero for transshipment)\n\nThe general formulation is:\n\n**Objective**: Minimize $\\sum_{(i,j)} c_{ij} \\cdot x_{ij}$\n\n**Subject to**:\n\n1. Flow Conservation: $\\sum_{j:(i,j)} x_{ij} - \\sum_{j:(j,i)} x_{ji} = b_i$ for all nodes $i$\n2. Capacity Constraints: $0 \\leq x_{ij} \\leq u_{ij}$ for all arcs $(i,j)$\n\n## Example 01: Distribution Unlimited Co.\n\nLet's apply this to a concrete example. Distribution Unlimited Co. has two factories (F1, F2) that need to ship products to two warehouses (W1, W2). There's also a distribution center (DC) that can be used as an intermediate point.\n\n\n\n\n```{mermaid}\nflowchart LR\n    F1(Factory 1<br/>80 units)\n    F2(Factory 2<br/>40 units)\n    DC(Distribution Center)\n    W1(Warehouse 1<br/>-60 units)\n    W2(Warehouse 2<br/>-90 units)\n    \n    F1 -->|$7/unit| W1\n    F1 -->|$3/unit<br/>Max 50 units| DC\n    F2 -->|$4/unit<br/>Max 50 units| DC\n    DC -->|$0/unit| W1\n    DC -->|$2/unit<br/>Max 60 units| W2\n```\n\n\n\n\nThe network includes:\n\n- Factory 1 (F1) produces 80 units\n- Factory 2 (F2) produces 40 units\n- Warehouse 1 (W1) requires 60 units\n- Warehouse 2 (W2) requires 90 units\n\nNotice that total demand (150 units) exceeds total supply (120 units). This means we'll need to handle unfulfilled demand in our model.\n\n### Handling Supply-Demand Imbalance\n\nWhen total supply doesn't equal total demand, we can:\n\n1. **Add a dummy supply node** (if supply < demand)\n2. **Add a dummy demand node** (if supply > demand)\n\nFor Distribution Unlimited Co., we'll add a dummy supply of 30 units with zero transportation cost to make the problem feasible:\n\n\n\n\n```{mermaid}\nflowchart LR\n    F1(Factory 1<br/>80 units)\n    F2(Factory 2<br/>40 units)\n    DC(Distribution Center)\n    W1(Warehouse 1<br/>-60 units)\n    W2(Warehouse 2<br/>-90 units)\n    DS(Dummy Supply<br/>30 units)\n    \n    F1 -->|$7/unit| W1\n    F1 -->|$3/unit<br/>Max 50 units| DC\n    F2 -->|$4/unit<br/>Max 50 units| DC\n    DC -->|$0/unit| W1\n    DC -->|$2/unit<br/>Max 60 units| W2\n    DS -->|$0/unit| W2\n```\n\n\n\n\n### Solving with Python\n\nThe Python implementation uses Gurobi Optimizer through its Python interface, `gurobipy`. Unlike Excel, which uses a tabular format, Python builds the model programmatically. Let's break down how this works step by step.\n\nHere's the basic structure:\n\n1. Define nodes and their supply/demand values\n2. Define arcs with costs and capacities\n3. Create decision variables for flows\n4. Add flow conservation constraints\n5. Add capacity constraints\n6. Set the objective and solve the model\n\nFirst, we need to import the necessary libraries:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n```\n\nGurobipy is Gurobi's Python API, and GRB provides constants like GRB.MINIMIZE for setting the optimization direction.\n\n#### Defining the Problem Structure\n\nNext, we define our network structure using Python data structures:\n\n::: {#d9e9d2cc .cell execution_count=1}\n``` {.python .cell-code}\n# Define nodes\nnodes = ['F1', 'F2', 'DC', 'W1', 'W2', 'Dummy']\n\n# Define supply/demand at each node\nsupply_demand = {\n    'F1': 80,    # Supply of 80 units\n    'F2': 40,    # Supply of 40 units\n    'DC': 0,     # Transshipment node (no net supply/demand)\n    'W1': -60,   # Demand of 60 units\n    'W2': -90,   # Demand of 90 units\n    'Dummy': 30  # Dummy supply of 30 units\n}\n\n# Define arcs with costs and capacities\narcs = {\n    ('F1', 'W1'): (7, float('inf')),  # Direct route from F1 to W1\n    ('F1', 'DC'): (3, 50),            # Route from F1 to DC with capacity 50\n    ('F2', 'DC'): (4, 50),            # Route from F2 to DC with capacity 50\n    ('DC', 'W1'): (0, float('inf')),  # Route from DC to W1\n    ('DC', 'W2'): (2, 60),            # Route from DC to W2 with capacity 60\n    ('Dummy', 'W2'): (0, float('inf'))  # Dummy route to W2\n}\n```\n:::\n\n\nThis approach is very flexible. We can easily add or remove nodes and arcs by modifying these data structures.\n\n#### Creating the Optimization Model\n\nNow we create a Gurobi model and define the flow variables:\n\n```python\n# Create a new model\nmodel = gp.Model(\"MinCostNetworkFlow\")\n\n# Create flow variables for each arc\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n```\n\nEach variable `flow[(i, j)]` represents the amount flowing from node `i` to node `j`. The `obj=cost` parameter sets the coefficient in the objective function.\n\n##### `flow = {}`\n\nThis initializes an empty Python dictionary called `flow`. This dictionary will store our decision variables, which represent the amount of product flowing along each arc in the network. The dictionary's keys will be tuples representing arcs (from node $i$ to node $j$), and the values will be Gurobi variable objects.\n\n##### `arcs.items()`\n\nThe `arcs` variable is a dictionary where:\n\n- Each key is a tuple `(i, j)` representing an arc from node $i$ to node $j$.\n- Each value is another tuple `(cost, capacity)` containing the cost per unit of flow and the maximum capacity for that arc.\n\nThe `items()` method returns an iterator over the key-value pairs in the dictionary, so `arcs.items()` produces pairs like: `((i, j), (cost, capacity))`.\n\n::: {#79980b9b .cell execution_count=2}\n``` {.python .cell-code}\nfor value in arcs.items():\n    print(value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(('F1', 'W1'), (7, inf))\n(('F1', 'DC'), (3, 50))\n(('F2', 'DC'), (4, 50))\n(('DC', 'W1'), (0, inf))\n(('DC', 'W2'), (2, 60))\n(('Dummy', 'W2'), (0, inf))\n```\n:::\n:::\n\n\n##### `for (i, j), (cost, _) in arcs.items():`\n\nThis line uses Python's tuple unpacking to extract values. For each iteration:\n\n- `(i, j)` captures the origin and destination nodes from the arc tuple.\n- `(cost, _)` captures the cost while ignoring the capacity (the underscore `_` is a Python convention for a variable you don't intend to use).\n\nFor example, if one entry in `arcs` is `('F1', 'DC'): (3, 50)`, then in that iteration:\n\n- `i` would be `'F1'` (the origin node)\n- `j` would be `'DC'` (the destination node)\n- `cost` would be `3` (the cost per unit of flow)\n- `_` would be `50` (the capacity, which we're ignoring for now)\n\n##### `flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)`\n\nFor each arc, this line creates a Gurobi decision variable and adds it to our flow dictionary:\n\n- `model.addVar()` creates a new decision variable in the Gurobi model.\n- `name=f'flow_{i}_{j}'` gives the variable a descriptive name like `\"flow_F1_DC\"`.\n- `obj=cost` sets the variable's coefficient in the objective function to the cost of this arc.\n- `flow[(i, j)] = ...` stores the created variable in our dictionary with the arc tuple as the key.\n\nBy default, Gurobi variables are non-negative (`lb = 0`) and continuous, which is what we want for flow variables in this network problem.\n\n##### What's Happening Overall\n\nThis loop iterates through each possible shipping route (arc) in our network. For each arc, it:\n\n1. Extracts the origin node, destination node, and shipping cost\n2. Creates a variable representing \"how much to ship from origin to destination\"\n3. Associates that variable with the arc's cost in the objective function\n4. Stores the variable in a dictionary for later use when creating constraints\n\nAfter this loop completes, the `flow` dictionary contains all the decision variables our model needs, with each variable properly connected to its cost in the objective function. This is the foundation of our optimization model, we're creating variables for each possible shipment route and telling Gurobi that we want to minimize the total shipping cost.\n\nThe next parts of the code will add constraints to ensure flow conservation (what comes in equals what goes out at each node) and to enforce capacity limits on certain routes.\n\n#### Adding Flow Conservation Constraints\n\nThe most important constraints ensure flow conservation at each node:\n\n```python\n# Add flow conservation constraints for each node\nfor i in nodes:\n    # Sum of all flows leaving node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of all flows entering node i\n    inflow  = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n```\n\nThis loop creates one constraint for each node. The constraint ensures that:\n\n- For supply nodes: $outflow - inflow = supply amount$\n- For demand nodes: $outflow - inflow = -demand amount$\n- For transshipment nodes: $outflow - inflow = 0$\n\n##### `for i in nodes:`\n\nThis loop iterates through each node in our network. For every node (whether it's a factory, warehouse, or distribution center), we need to create a flow conservation constraint.\n\nFlow conservation is a fundamental principle in network flow models. It states that for any node in the network:\n\n- The amount of flow entering the node, minus\n- The amount of flow leaving the node,\n- Must equal the node's supply or demand value\n\nThis mirrors real-world physical constraints: products don't disappear or materialize within the network (except at supply or demand nodes).\n\n##### `outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)`\n\nThis line calculates the total flow leaving node `i`:\n\n1. `arcs.keys()` gives us all the arc tuples `(i2, j)` in our network.\n2. `if i2 == i` filters for only those arcs where the origin node matches our current node `i`.\n3. `flow[(i, j)]` retrieves the decision variable representing flow on the arc from node `i` to some other node `j`.\n4. `gp.quicksum(...)` sums up all these flow variables.\n\nEssentially, we're adding up all the flow variables for arcs that originate from node `i`.\n\nThe reason for using `i2` here is that we're unpacking tuples from `arcs.keys()`. Each tuple is an arc represented as `(origin, destination)`. We use `i2` as a temporary variable name to compare with our current node `i`.\n\n##### `inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)`\n\nSimilarly, this line calculates the total flow entering node `i`:\n\n1. `arcs.keys()` gives us all the arc tuples `(j, i2)` in our network.\n2. `if i2 == i` filters for only those arcs where the destination node matches our current node `i`.\n3. `flow[(j, i)]` retrieves the decision variable representing flow on the arc from some other node `j` to node `i`.\n4. `gp.quicksum(...)` sums up all these flow variables.\n\nThis time, we're adding up all the flow variables for arcs that terminate at node `i`.\n\n##### `model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')`\n\nFinally, we add the constraint to our model:\n\n1. `outflow - inflow` calculates the net flow (outgoing minus incoming) at node `i`.\n2. `supply_demand[i]` retrieves the supply/demand value for node `i`:\n    - Positive supply for supply nodes (more going out than coming in)\n    - Negative for demand nodes (more coming in than going out)\n    - Zero for transshipment nodes (what comes in must equal what goes out)\n3. `model.addConstr(...)` adds this constraint to the Gurobi model.\n4. `name=f'node_{i}'` gives the constraint a unique name for identification.\n\nThe constraint enforces different behaviors depending on the node type:\n\n- **Supply Nodes**: If `supply_demand[i] = 50`, then `outflow - inflow = 50`, meaning the node sends out 50 more units than it receives.\n- **Demand Nodes**: If `supply_demand[i] = -30`, then `outflow - inflow = -30`, meaning the node receives 30 more units than it sends out.\n- **Transshipment Nodes**: If `supply_demand[i] = 0`, then `outflow - inflow = 0`, meaning everything that enters the node must also leave it.\n\n#### Adding Capacity Constraints\n\nSome arcs have capacity limits:\n\n```python\n# Add capacity constraints for each arc\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity < float('inf'):\n        model.addConstr(flow[(i, j)] <= capacity, name=f'capacity_{i}_{j}')\n```\n\nThis only adds constraints for arcs with finite capacity. We use `float('inf')` to represent unlimited capacity.\n\n##### `for (i, j), (_, capacity) in arcs.items():`\n\nThis loop iterates through each arc in our network and its corresponding capacity. Let's break down the unpacking:\n\n1. `arcs.items()` returns pairs of `((i, j), (cost, capacity))` where:\n    - `(i, j)` is the arc from node `i` to node `j`\n    - `(cost, capacity)` contains the shipping cost and maximum capacity\n2. `(i, j), (_, capacity)` unpacks these values:\n    - `i` is the origin node\n    - `j` is the destination node\n    - `_` is the cost (we use underscore because we don't need the cost for capacity constraints)\n    - `capacity` is the maximum amount that can flow on this arc\n\nFor example, if arcs contains ('F1', 'DC'): (3, 50), then in that iteration:\n\n- `i` would be `'F1'` (origin)\n- `j` would be `'DC'` (destination)\n- `_` would be `3` (cost, ignored here)\n- `capacity` would be `50` (maximum flow allowed)\n\n##### `if capacity < float('inf'):`\n\nNot all arcs need capacity constraints. Many routes have no practical limit, or their limit is so large that it won't affect the optimal solution. In our code:\n\n- `float('inf')` represents infinity in Python\n- `capacity < float('inf')` checks if the capacity is a finite number\n    - If true, we need to add a capacity constraint\n    - If false (capacity is infinite), no constraint is needed\n\nThis condition ensures we only add constraints where necessary, keeping our model streamlined.\n\n##### `model.addConstr(flow[(i, j)] <= capacity, name=f'capacity_{i}_{j}')`\n\nThis line creates and adds the actual capacity constraint to our model:\n\n1. `flow[(i, j)]` accesses the decision variable representing flow on this arc\n2. `flow[(i, j)] <= capacity` creates a constraint saying the flow cannot exceed the capacity\n3. `model.addConstr(...)` adds this constraint to the Gurobi model\n4. `name=f'capacity_{i}_{j}'` gives the constraint a descriptive name like \"capacity_F1_DC\"\n\n#### Setting the Objective and Solving\n\nFinally, we set the objective function and solve the model:\n\n```python\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Optimize the model\nmodel.optimize()\n```\n\n#### Extracting and Analyzing the Solution\n\nAfter solving, we can extract and analyze the results:\n\n```python\n# Check if an optimal solution was found\nif model.Status == GRB.OPTIMAL:\n    # Extract the solution\n    flow_values = {}\n    total_cost = 0\n    \n    for (i, j), var in flow.items():\n        # Get the flow amount for this arc\n        flow_amount = var.X\n        \n        # Only include arcs with positive flow\n        if flow_amount > 0.001:  # Small threshold for floating-point errors\n            flow_values[(i, j)] = flow_amount\n            \n            # Add to the total cost\n            cost = arcs[(i, j)][0]\n            total_cost += flow_amount * cost\n    \n    print(\"Optimal flows:\")\n    for (i, j), flow in sorted(flow_values.items()):\n        cost = arcs[(i, j)][0]\n        print(f\"{i} → {j}: {flow:.1f} units (cost: ${cost}/unit)\")\n    \n    print(f\"<br/>Total transportation cost: ${total_cost:.1f}\")\nelse:\n    print(f\"No optimal solution found. Status code: {model.Status}\")\n```\n\nThis code extracts the flow values from the solution, calculates the total cost, and prints a summary of the optimal flows.\n\n#### All Together\n\n::: {#093db2c9 .cell execution_count=3}\n``` {.python .cell-code}\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Define nodes\nnodes = ['F1', 'F2', 'DC', 'W1', 'W2', 'Dummy']\n\n# Define supply/demand at each node\nsupply_demand = {\n    'F1': 80,    # Supply of 80 units\n    'F2': 40,    # Supply of 40 units\n    'DC': 0,     # Transshipment node (no net supply/demand)\n    'W1': -60,   # Demand of 60 units\n    'W2': -90,   # Demand of 90 units\n    'Dummy': 30  # Dummy supply of 30 units\n}\n\n# Define arcs with costs and capacities\narcs = {\n    ('F1', 'W1'): (7, float('inf')),  # Direct route from F1 to W1\n    ('F1', 'DC'): (3, 50),            # Route from F1 to DC with capacity 50\n    ('F2', 'DC'): (4, 50),            # Route from F2 to DC with capacity 50\n    ('DC', 'W1'): (0, float('inf')),  # Route from DC to W1\n    ('DC', 'W2'): (2, 60),            # Route from DC to W2 with capacity 60\n    ('Dummy', 'W2'): (0, float('inf'))  # Dummy route to W2\n}\n\n# Create a new model\nmodel = gp.Model(\"MinCostNetworkFlow\")\nmodel.Params.LogToConsole = 0 # should turn off unwanted gurobipy output\n\n# Create flow variables for each arc\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints for each node\nfor i in nodes:\n    # Sum of all flows leaving node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of all flows entering node i\n    inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Add capacity constraints for each arc\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity < float('inf'):\n        model.addConstr(flow[(i, j)] <= capacity, name=f'capacity_{i}_{j}')\n\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Optimize the model\nmodel.optimize()\n\n# Check if an optimal solution was found\nif model.Status == GRB.OPTIMAL:\n    # Extract the solution\n    flow_values = {}\n    total_cost = 0\n    \n    for (i, j), var in flow.items():\n        # Get the flow amount for this arc\n        flow_amount = var.X\n        \n        # Only include arcs with positive flow\n        if flow_amount > 0.001:  # Small threshold for floating-point errors\n            flow_values[(i, j)] = flow_amount\n            \n            # Add to the total cost\n            cost = arcs[(i, j)][0]\n            total_cost += flow_amount * cost\n    \n    print(\"Optimal flows:\")\n    for (i, j), flow in sorted(flow_values.items()):\n        cost = arcs[(i, j)][0]\n        print(f\"{i} → {j}: {flow:.1f} units (cost: ${cost}/unit)\")\n    \n    print(f\"<br/>Total transportation cost: ${total_cost:.1f}\")\nelse:\n    print(f\"No optimal solution found. Status code: {model.Status}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSet parameter Username\nSet parameter LicenseID to value 2609229\nSet parameter LogToConsole to value 0\nOptimal flows:\nDC → W1: 30.0 units (cost: $0/unit)\nDC → W2: 60.0 units (cost: $2/unit)\nDummy → W2: 30.0 units (cost: $0/unit)\nF1 → DC: 50.0 units (cost: $3/unit)\nF1 → W1: 30.0 units (cost: $7/unit)\nF2 → DC: 40.0 units (cost: $4/unit)\n<br/>Total transportation cost: $640.0\n```\n:::\n:::\n\n\n```{mermaid}\nflowchart LR\n    F1(Factory 1<br/>80 units)\n    F2(Factory 2<br/>40 units)\n    DC(Distribution Center)\n    W1(Warehouse 1<br/>-60 units)\n    W2(Warehouse 2<br/>-90 units)\n    DS(Dummy Supply<br/>30 units)\n    \n    F1 -->|30 units<br/>$7/unit| W1\n    F1 -->|50 units<br/>$3/unit| DC\n    F2 -->|40 units<br/>$4/unit| DC\n    DC -->|30 units<br/>$0/unit| W1\n    DC -->|60 units<br/>$2/unit| W2\n    DS -->|30 units<br/>$0/unit| W2\n    \n    style F1 fill:#d4f1c5\n    style F2 fill:#d4f1c5\n    style DS fill:#d4f1c5\n    style W1 fill:#c5daf1\n    style W2 fill:#c5daf1\n    style DC fill:#f1e9c5\n```\n\n\n\n\n#### Advantages of the Python Approach\n\nThe Python/Gurobi approach offers several advantages:\n\n- Scales to very large networks (hundreds of nodes and arcs)\n- Easier to modify and analyze multiple scenarios\n- Can be integrated with other Python tools for data analysis and visualization\n- Faster for complex problems\n- More sophisticated error handling and reporting\n\nHere is a version of this problem with five factories, 3 distribution centers, and eight warehouse locations:\n\n\n\n\n```{mermaid}\nflowchart LR\n    %% Supply Nodes (Factories)\n    F1[Factory 1<br/>120 units]\n    F2[Factory 2<br/>150 units]\n    F3[Factory 3<br/>200 units]\n    F4[Factory 4<br/>180 units]\n    F5[Factory 5<br/>250 units]\n    \n    %% Transshipment Nodes (Distribution Centers)\n    DC1[Distribution Center 1]\n    DC2[Distribution Center 2]\n    DC3[Distribution Center 3]\n    \n    %% Demand Nodes (Warehouses)\n    W1[Warehouse 1<br/>-80 units]\n    W2[Warehouse 2<br/>-110 units]\n    W3[Warehouse 3<br/>-90 units]\n    W4[Warehouse 4<br/>-130 units]\n    W5[Warehouse 5<br/>-150 units]\n    W6[Warehouse 6<br/>-100 units]\n    W7[Warehouse 7<br/>-120 units]\n    W8[Warehouse 8<br/>-120 units]\n    \n    %% Factory to DC connections\n    F1 -->|$3/unit<br/>Max 100| DC1\n    F1 -->|$4/unit<br/>Max 80| DC2\n    F2 -->|$4/unit<br/>Max 90| DC1\n    F2 -->|$3/unit<br/>Max 100| DC2\n    F3 -->|$3/unit<br/>Max 120| DC2\n    F3 -->|$2/unit<br/>Max 150| DC3\n    F4 -->|$4/unit<br/>Max 100| DC2\n    F4 -->|$3/unit<br/>Max 110| DC3\n    F5 -->|$5/unit<br/>Max 80| DC1\n    F5 -->|$2/unit<br/>Max 200| DC3\n    \n    %% Sample direct Factory to Warehouse connections\n    F1 -.->|$8/unit| W1\n    F2 -.->|$8/unit| W2\n    F3 -.->|$9/unit| W4\n    F4 -.->|$10/unit| W5\n    F5 -.->|$8/unit| W8\n    \n    %% DC to Warehouse connections (showing representative examples)\n    DC1 -->|$3/unit<br/>Max 100| W1\n    DC1 -->|$4/unit<br/>Max 90| W2\n    DC1 -->|$2/unit<br/>Max 120| W3\n    DC2 -->|$3/unit<br/>Max 100| W3\n    DC2 -->|$2/unit<br/>Max 150| W4\n    DC2 -->|$4/unit<br/>Max 120| W5\n    DC3 -->|$4/unit<br/>Max 90| W6\n    DC3 -->|$3/unit<br/>Max 140| W7\n    DC3 -->|$2/unit<br/>Max 120| W8\n    \n    %% Inter-DC connections\n    DC1 -->|$1/unit<br/>Max 70| DC2\n    DC2 -->|$1/unit<br/>Max 90| DC3\n    DC3 -->|$2/unit<br/>Max 60| DC1\n    \n    %% Node styling\n    classDef supply fill:#d4f1c5,stroke:#333,stroke-width:1px\n    classDef transship fill:#f1e9c5,stroke:#333,stroke-width:1px\n    classDef demand fill:#c5daf1,stroke:#333,stroke-width:1px\n    \n    %% Apply styles\n    class F1,F2,F3,F4,F5 supply\n    class DC1,DC2,DC3 transship\n    class W1,W2,W3,W4,W5,W6,W7,W8 demand\n```\n\n::: {#177db580 .cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\n\"\"\"\nMinimum Cost Network Flow Solver\n\nThis script reads supply chain network data from CSV files and \nsolves the minimum cost network flow problem using Gurobi optimizer.\n\"\"\"\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport pandas as pd\n\n# Read the node data\nprint(\"Reading node data from nodes.csv...\")\nnodes_df = pd.read_csv(r'data\\min_cost_ex_nodes.csv')\n\n# Read the arc data\nprint(\"Reading arc data from arcs.csv...\")\narcs_df = pd.read_csv(r'data\\min_cost_ex_arcs.csv')\n\n# Extract node information\nnodes = nodes_df['node_id'].tolist()\nsupply_demand = dict(zip(nodes_df['node_id'], nodes_df['supply_demand']))\nnode_types = dict(zip(nodes_df['node_id'], nodes_df['type']))\n\n# Group nodes by type for reporting\nfactories = [node for node, type_val in node_types.items() if type_val == 'Factory']\ndistribution_centers = [node for node, type_val in node_types.items() if type_val == 'DC']\nwarehouses = [node for node, type_val in node_types.items() if type_val == 'Warehouse']\n\n# Check supply/demand balance\ntotal_supply = sum(v for v in supply_demand.values() if v > 0)\ntotal_demand = -sum(v for v in supply_demand.values() if v < 0)\nprint(f\"Total supply: {total_supply}\")\nprint(f\"Total demand: {total_demand}\")\nif total_supply != total_demand:\n    print(\"Warning: Supply and demand are not balanced!\")\n\n# Create arcs dictionary from DataFrame\n# Convert 'inf' strings to actual infinity\narcs_df['capacity'] = arcs_df['capacity'].replace('inf', float('inf'))\narcs_df['capacity'] = pd.to_numeric(arcs_df['capacity'])\n\n# Create arcs dictionary\narcs = {}\nfor _, row in arcs_df.iterrows():\n    arcs[(row['from_node'], row['to_node'])] = (row['cost'], row['capacity'])\n\nprint(f\"Network has {len(nodes)} nodes and {len(arcs)} arcs\")\n\n# Create a new Gurobi model\nmodel = gp.Model(\"SupplyChainNetwork\")\nmodel.Params.LogToConsole = 0\n\n# Create flow variables for each arc\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints for each node\nfor i in nodes:\n    # Sum of flows leaving node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of flows entering node i\n    inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Add capacity constraints for each arc\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity < float('inf'):\n        model.addConstr(flow[(i, j)] <= capacity, name=f'capacity_{i}_{j}')\n\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Solve the model\nprint(\"\\nSolving the network flow problem...\")\nmodel.optimize()\n\n# Check if an optimal solution was found\nif model.Status == GRB.OPTIMAL:\n    # Calculate flow statistics\n    active_arcs = 0\n    capacity_limited_arcs = 0\n    total_cost = 0\n    \n    # Dictionaries to track flows by node type\n    factory_flows = {f: 0 for f in factories}\n    dc_throughput = {dc: 0 for dc in distribution_centers}\n    warehouse_inflows = {w: 0 for w in warehouses}\n    \n    # Extract solution\n    flow_values = {}\n    for (i, j), var in flow.items():\n        flow_amount = var.X\n        if flow_amount > 0.001:  # Only count non-zero flows\n            flow_values[(i, j)] = flow_amount\n            active_arcs += 1\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            total_cost += flow_amount * cost\n            \n            # Check if arc is at capacity\n            if capacity < float('inf') and abs(flow_amount - capacity) < 0.001:\n                capacity_limited_arcs += 1\n            \n            # Update node statistics\n            if i in factories:\n                factory_flows[i] += flow_amount\n            if i in distribution_centers:\n                dc_throughput[i] += flow_amount\n            if j in warehouses:\n                warehouse_inflows[j] += flow_amount\n    \n    # Print results\n    print(\"\\n========== OPTIMAL SOLUTION FOUND ==========\")\n    print(f\"Total transportation cost: ${total_cost:.2f}\")\n    print(f\"Active arcs: {active_arcs} out of {len(arcs)} possible\")\n    print(f\"Arcs at capacity: {capacity_limited_arcs}\")\n    \n    # Factory utilization\n    print(\"\\nFACTORY UTILIZATION:\")\n    for f in factories:\n        utilization_pct = (factory_flows[f] / supply_demand[f]) * 100\n        print(f\"  {f}: {factory_flows[f]} units shipped ({utilization_pct:.1f}% of capacity)\")\n    \n    # Distribution center throughput\n    print(\"\\nDISTRIBUTION CENTER THROUGHPUT:\")\n    for dc in distribution_centers:\n        print(f\"  {dc}: {dc_throughput[dc]} units processed\")\n    \n    # Warehouse demand fulfillment\n    print(\"\\nWAREHOUSE DEMAND FULFILLMENT:\")\n    for w in warehouses:\n        received_pct = (warehouse_inflows[w] / (-supply_demand[w])) * 100\n        print(f\"  {w}: {warehouse_inflows[w]} units received ({received_pct:.1f}% of demand)\")\n    \n    # Detailed flow report\n    print(\"\\nDETAILED FLOW REPORT (non-zero flows only):\")\n    \n    # Factory to warehouse direct\n    f_to_w = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n             if i in factories and j in warehouses]\n    if f_to_w:\n        print(\"\\n  Factory → Warehouse (Direct):\")\n        for i, j, amt in sorted(f_to_w):\n            cost = arcs[(i, j)][0]\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f})\")\n    \n    # Factory to DC\n    f_to_dc = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n              if i in factories and j in distribution_centers]\n    if f_to_dc:\n        print(\"\\n  Factory → Distribution Center:\")\n        for i, j, amt in sorted(f_to_dc):\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            at_capacity = \" (at capacity)\" if abs(amt - capacity) < 0.001 else \"\"\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f}){at_capacity}\")\n    \n    # DC to warehouse\n    dc_to_w = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n              if i in distribution_centers and j in warehouses]\n    if dc_to_w:\n        print(\"\\n  Distribution Center → Warehouse:\")\n        for i, j, amt in sorted(dc_to_w):\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            at_capacity = \" (at capacity)\" if abs(amt - capacity) < 0.001 else \"\"\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f}){at_capacity}\")\n    \n    # Inter-DC flows\n    dc_to_dc = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n               if i in distribution_centers and j in distribution_centers]\n    if dc_to_dc:\n        print(\"\\n  Distribution Center → Distribution Center:\")\n        for i, j, amt in sorted(dc_to_dc):\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            at_capacity = \" (at capacity)\" if abs(amt - capacity) < 0.001 else \"\"\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f}){at_capacity}\")\n    \n    # Export solution to CSV\n    solution_data = []\n    for (i, j), flow_amount in flow_values.items():\n        cost = arcs[(i, j)][0]\n        capacity = arcs[(i, j)][1]\n        solution_data.append({\n            'from_node': i,\n            'to_node': j,\n            'flow': flow_amount,\n            'cost_per_unit': cost,\n            'total_cost': flow_amount * cost,\n            'capacity': capacity if capacity < float('inf') else 'unlimited',\n            'at_capacity': 'Yes' if capacity < float('inf') and abs(flow_amount - capacity) < 0.001 else 'No'\n        })\n    \n    solution_df = pd.DataFrame(solution_data)\n    solution_df.to_csv('solution.csv', index=False)\n    print()\n    print(solution_df)\n    \nelse:\n    print(f\"No optimal solution found. Status code: {model.Status}\")\n    print(\"Check your data for inconsistencies in supply/demand balance or network connectivity.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading node data from nodes.csv...\nReading arc data from arcs.csv...\nTotal supply: 900\nTotal demand: 900\nNetwork has 16 nodes and 35 arcs\nSet parameter LogToConsole to value 0\n\nSolving the network flow problem...\n\n========== OPTIMAL SOLUTION FOUND ==========\nTotal transportation cost: $5120.00\nActive arcs: 23 out of 35 possible\nArcs at capacity: 9\n\nFACTORY UTILIZATION:\n  F1: 120.0 units shipped (100.0% of capacity)\n  F2: 150.0 units shipped (100.0% of capacity)\n  F3: 200.0 units shipped (100.0% of capacity)\n  F4: 180.0 units shipped (100.0% of capacity)\n  F5: 250.0 units shipped (100.0% of capacity)\n\nDISTRIBUTION CENTER THROUGHPUT:\n  DC1: 240.0 units processed\n  DC2: 240.0 units processed\n  DC3: 460.0 units processed\n\nWAREHOUSE DEMAND FULFILLMENT:\n  W1: 80.0 units received (100.0% of demand)\n  W2: 110.0 units received (100.0% of demand)\n  W3: 90.0 units received (100.0% of demand)\n  W4: 130.0 units received (100.0% of demand)\n  W5: 150.0 units received (100.0% of demand)\n  W6: 100.0 units received (100.0% of demand)\n  W7: 120.0 units received (100.0% of demand)\n  W8: 120.0 units received (100.0% of demand)\n\nDETAILED FLOW REPORT (non-zero flows only):\n\n  Factory → Warehouse (Direct):\n    F2 → W2: 20.0 units (cost: $8/unit, total: $160.0)\n\n  Factory → Distribution Center:\n    F1 → DC1: 100.0 units (cost: $3/unit, total: $300.0) (at capacity)\n    F1 → DC2: 20.0 units (cost: $4/unit, total: $80.0)\n    F2 → DC1: 30.0 units (cost: $4/unit, total: $120.0)\n    F2 → DC2: 100.0 units (cost: $3/unit, total: $300.0) (at capacity)\n    F3 → DC2: 50.0 units (cost: $3/unit, total: $150.0)\n    F3 → DC3: 150.0 units (cost: $2/unit, total: $300.0) (at capacity)\n    F4 → DC2: 70.0 units (cost: $4/unit, total: $280.0)\n    F4 → DC3: 110.0 units (cost: $3/unit, total: $330.0) (at capacity)\n    F5 → DC1: 50.0 units (cost: $5/unit, total: $250.0)\n    F5 → DC3: 200.0 units (cost: $2/unit, total: $400.0) (at capacity)\n\n  Distribution Center → Warehouse:\n    DC1 → W1: 80.0 units (cost: $3/unit, total: $240.0)\n    DC1 → W2: 90.0 units (cost: $4/unit, total: $360.0) (at capacity)\n    DC1 → W3: 70.0 units (cost: $2/unit, total: $140.0)\n    DC2 → W3: 20.0 units (cost: $3/unit, total: $60.0)\n    DC2 → W4: 130.0 units (cost: $2/unit, total: $260.0)\n    DC2 → W5: 20.0 units (cost: $4/unit, total: $80.0)\n    DC2 → W6: 70.0 units (cost: $3/unit, total: $210.0)\n    DC3 → W5: 130.0 units (cost: $2/unit, total: $260.0) (at capacity)\n    DC3 → W6: 30.0 units (cost: $4/unit, total: $120.0)\n    DC3 → W7: 120.0 units (cost: $3/unit, total: $360.0)\n    DC3 → W8: 120.0 units (cost: $2/unit, total: $240.0) (at capacity)\n\n  Distribution Center → Distribution Center:\n    DC3 → DC1: 60.0 units (cost: $2/unit, total: $120.0) (at capacity)\n\n   from_node to_node   flow  cost_per_unit  total_cost   capacity at_capacity\n0         F1     DC1  100.0              3       300.0      100.0         Yes\n1         F1     DC2   20.0              4        80.0       80.0          No\n2         F2     DC1   30.0              4       120.0       90.0          No\n3         F2     DC2  100.0              3       300.0      100.0         Yes\n4         F3     DC2   50.0              3       150.0      120.0          No\n5         F3     DC3  150.0              2       300.0      150.0         Yes\n6         F4     DC2   70.0              4       280.0      100.0          No\n7         F4     DC3  110.0              3       330.0      110.0         Yes\n8         F5     DC1   50.0              5       250.0       80.0          No\n9         F5     DC3  200.0              2       400.0      200.0         Yes\n10        F2      W2   20.0              8       160.0  unlimited          No\n11       DC1      W1   80.0              3       240.0      100.0          No\n12       DC1      W2   90.0              4       360.0       90.0         Yes\n13       DC1      W3   70.0              2       140.0      120.0          No\n14       DC2      W3   20.0              3        60.0      100.0          No\n15       DC2      W4  130.0              2       260.0      150.0          No\n16       DC2      W5   20.0              4        80.0      120.0          No\n17       DC2      W6   70.0              3       210.0      110.0          No\n18       DC3      W5  130.0              2       260.0      130.0         Yes\n19       DC3      W6   30.0              4       120.0       90.0          No\n20       DC3      W7  120.0              3       360.0      140.0          No\n21       DC3      W8  120.0              2       240.0      120.0         Yes\n22       DC3     DC1   60.0              2       120.0       60.0         Yes\n```\n:::\n:::\n\n\nThis is just for example, we will not being doing any problems like this in this course.\n\n## Example 02: Oil Transport Problem\n\nLet's look at another example. The Conch Oil Company needs to transport 30 million barrels of crude oil from Doha, Qatar to three European refineries:\n\n- Rotterdam, Netherlands (6 million barrels)\n- Toulon, France (15 million barrels)\n- Palermo, Italy (9 million barrels)\n\nThere are three possible routes:\n\n1. Direct shipping around Africa (most expensive)\n2. Through the Suez Canal to Port Said, then to destinations\n3. From Suez to Damietta via pipeline (limited to 15 million barrels), then to destinations\n\n\n\n\n```{mermaid}\nflowchart LR\n    Doha(Doha<br/>30M barrels)\n    Suez(Suez)\n    PortSaid(Port Said)\n    Damietta(Damietta)\n    Rotterdam(Rotterdam<br/>-6M barrels)\n    Toulon(Toulon<br/>-15M barrels)\n    Palermo(Palermo<br/>-9M barrels)\n    \n    Doha -->|$1.20/barrel| Rotterdam\n    Doha -->|$1.40/barrel| Toulon\n    Doha -->|$1.35/barrel| Palermo\n    Doha -->|$0.35/barrel| Suez\n    Suez -->|$0.20/barrel| PortSaid\n    Suez -->|$0.16/barrel<br/>Max 15M barrels| Damietta\n    PortSaid -->|$0.27/barrel| Rotterdam\n    PortSaid -->|$0.28/barrel| Toulon\n    PortSaid -->|$0.19/barrel| Palermo\n    Damietta -->|$0.25/barrel| Rotterdam\n    Damietta -->|$0.20/barrel| Toulon\n    Damietta -->|$0.15/barrel| Palermo\n    \n    style Doha fill:#d4f1c5\n    style Rotterdam fill:#c5daf1\n    style Toulon fill:#c5daf1\n    style Palermo fill:#c5daf1\n    style Suez fill:#f1e9c5\n    style PortSaid fill:#f1e9c5\n    style Damietta fill:#f1e9c5\n```\n\n\n\n\n### Optimal Solution to Oil Transport Problem\n\nLet's implement a complete Python solution for the Conch Oil Company problem. We'll structure this similar to our previous example but add more detailed code comments to explain the logic.\n\n::: {#1976d7ba .cell execution_count=5}\n``` {.python .cell-code}\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Define the nodes in our network\nnodes = ['Doha', 'Suez', 'PortSaid', 'Damietta', 'Rotterdam', 'Toulon', 'Palermo']\n\n# Define supply/demand at each node (in millions of barrels)\nsupply_demand = {\n    'Doha': 30,        # Supply: 30M barrels at origin\n    'Suez': 0,         # Transshipment node: no net supply/demand\n    'PortSaid': 0,     # Transshipment node: no net supply/demand\n    'Damietta': 0,     # Transshipment node: no net supply/demand\n    'Rotterdam': -6,   # Demand: 6M barrels\n    'Toulon': -15,     # Demand: 15M barrels\n    'Palermo': -9      # Demand: 9M barrels\n}\n\n# Define arcs with (cost, capacity) tuples\n# Format: (origin, destination): (cost per barrel, capacity in millions of barrels)\narcs = {\n    # Direct routes from Doha to refineries\n    ('Doha', 'Rotterdam'): (1.20, float('inf')),\n    ('Doha', 'Toulon'): (1.40, float('inf')),\n    ('Doha', 'Palermo'): (1.35, float('inf')),\n    \n    # Route via Suez\n    ('Doha', 'Suez'): (0.35, float('inf')),\n    ('Suez', 'PortSaid'): (0.20, float('inf')),\n    ('Suez', 'Damietta'): (0.16, 15),  # Pipeline has 15M barrel capacity\n    \n    # Routes from Port Said to refineries\n    ('PortSaid', 'Rotterdam'): (0.27, float('inf')),\n    ('PortSaid', 'Toulon'): (0.28, float('inf')),\n    ('PortSaid', 'Palermo'): (0.19, float('inf')),\n    \n    # Routes from Damietta to refineries\n    ('Damietta', 'Rotterdam'): (0.25, float('inf')),\n    ('Damietta', 'Toulon'): (0.20, float('inf')),\n    ('Damietta', 'Palermo'): (0.15, float('inf'))\n}\n\n# Create a new Gurobi model\nmodel = gp.Model(\"OilTransportProblem\")\nmodel.Params.LogToConsole = 0\n\n# Create decision variables for flow on each arc\n# Each variable represents millions of barrels flowing on that route\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    # obj=cost sets this variable's coefficient in the objective function\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints\n# For each node: outflow - inflow = supply/demand\nfor i in nodes:\n    # Calculate total outflow from node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Calculate total inflow to node i\n    inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Set constraint: outflow - inflow = supply/demand for this node\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Add capacity constraints for arcs with limited capacity\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity < float('inf'):\n        model.addConstr(flow[(i, j)] <= capacity, name=f'capacity_{i}_{j}')\n\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Solve the model\nmodel.optimize()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSet parameter LogToConsole to value 0\n```\n:::\n:::\n\n\nWhen executing this model, the solution shows that:\n\n1. All 30 million barrels are shipped from Doha to Suez\n2. From Suez, 15 million barrels go through the pipeline to Damietta (utilizing full capacity)\n3. The remaining 15 million barrels go to Port Said\n4. From Damietta and Port Said, the oil is distributed to the refineries through the most cost-effective routes\n\nWe can extract values from our model with the following code. You should be able to use the same code for similar models, like in the lab (hint hint):\n\n::: {#28ae92a2 .cell execution_count=6}\n``` {.python .cell-code}\nimport pandas as pd\n\n# Create a list to store flow data for the CSV\nflow_data = []\ntotal_cost = 0\n\n# Extract non-zero flows\nfor (i, j), var in flow.items():\n    flow_amount = var.X\n    \n    # Filter out very small flows (numerical precision issues)\n    if flow_amount > 0.001:\n        # Get the cost for this arc\n        cost = arcs[(i, j)][0]\n        \n        # Calculate the cost contribution\n        flow_cost = flow_amount * cost\n        total_cost += flow_cost\n        \n        # Add a row with all relevant information\n        flow_data.append({\n            'origin': i,\n            'destination': j,\n            'flow': round(flow_amount, 2),\n            'cost_per_unit': cost,\n            'total_cost': round(flow_cost, 2),\n            'capacity': arcs[(i, j)][1] if arcs[(i, j)][1] < float('inf') else 'Unlimited'\n        })\n\n# Check if we have any flow data before proceeding\nif flow_data:\n    # Create a DataFrame from the flow data\n    flow_df = pd.DataFrame(flow_data)\n    \n    # Sort the DataFrame without assuming column names\n    if 'origin' in flow_df.columns and 'destination' in flow_df.columns:\n        flow_df = flow_df.sort_values(by=['origin', 'destination'])\n    \n    # Save to CSV\n    flow_df.to_csv('optimal_flows.csv', index=False)\n    \n    # Create a summary DataFrame with additional statistics\n    summary_data = [{\n        'metric': 'Total Cost',\n        'value': round(total_cost, 2)\n    }, {\n        'metric': 'Total Flow Units',\n        'value': round(sum(item['flow'] for item in flow_data), 2)\n    }, {\n        'metric': 'Number of Active Routes',\n        'value': len(flow_data)\n    }]\n    \n    summary_df = pd.DataFrame(summary_data)\n    summary_df.to_csv('solution_summary.csv', index=False)\n    \n    print(f\"Solution exported to 'optimal_flows.csv' and 'solution_summary.csv'\")\n    print(f\"Total transportation cost: ${total_cost:.2f}\")\n    print()\n    print(summary_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSolution exported to 'optimal_flows.csv' and 'solution_summary.csv'\nTotal transportation cost: $22.23\n\n                    metric  value\n0               Total Cost  22.23\n1         Total Flow Units  90.00\n2  Number of Active Routes   6.00\n```\n:::\n:::\n\n\nThis code:\n\n1. Creates a structured dataset with all key information for each flow\n2. Exports the detailed flows to 'optimal_flows.csv'\n3. Creates a separate summary file with key metrics\n4. Works with any network structure (not specific to the oil transport problem)\n5. Preserves the total cost calculation from the original code\n\nYou can easily adapt this by:\n\n1. Changing the column names if needed\n2. Adding more metrics to the summary file\n3. Modifying the rounding precision\n4. Adding more details to each flow record\n\nThe CSV output will have a clean, tabular structure that can be opened in Excel or other tools for further analysis or visualization.\n\n## References and Resources\n\n1. Hillier & Lieberman, \"Introduction to Operations Research,\" Chapter 9\n2. The [Gurobi Modeling Examples](https://gurobi.github.io/modeling-examples/) repository\n\n## Exercises\n\n### Simple Network Flow Problem\n\nA shipping company needs to transport goods from two origins (O1, O2) to three destinations (D1, D2, D3). The shipping costs (in $ per unit) and supply/demand quantities are shown below:\n\n**Supply and Demand**:\n\n- Origin O1 has 150 units available\n- Origin O2 has 250 units available\n- Destination D1 requires 100 units\n- Destination D2 requires 200 units\n- Destination D3 requires 100 units\n\n**Shipping Costs**:\n\n| From | To | Cost per unit |\n|:----:|:--:|:-------------:|\n| O1   | D1 | $5            |\n| O1   | D2 | $3            |\n| O1   | D3 | $6            |\n| O2   | D1 | $4            |\n| O2   | D2 | $6            |\n| O2   | D3 | $2            |\n\nFormulate and solve this minimum cost network flow problem.\n\n#### Solution\n\nThe solution demonstrates how to model and solve a basic transportation problem using Gurobi. The key components include:\n\n1. Setting up the network structure with origins (O1, O2) and destinations (D1, D2, D3)\n2. Defining supply and demand quantities at each node\n3. Creating shipping costs between each origin-destination pair\n4. Formulating flow conservation constraints for all nodes\n5. Solving the model to find the minimum cost solution\n\n::: {#06a7bb78 .cell execution_count=7}\n``` {.python .cell-code code-fold=\"true\"}\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport pandas as pd\n\n# Define the nodes in our network\norigins = ['O1', 'O2']\ndestinations = ['D1', 'D2', 'D3']\nnodes = origins + destinations\n\n# Define supply/demand at each node\nsupply_demand = {\n    'O1':  150,  # Origin 1 supplies 150 units\n    'O2':  250,  # Origin 2 supplies 250 units\n    'D1': -100,  # Destination 1 demands 100 units\n    'D2': -200,  # Destination 2 demands 200 units\n    'D3': -100   # Destination 3 demands 100 units\n}\n\n# Define shipping costs\nshipping_costs = {\n    ('O1', 'D1'): 5,\n    ('O1', 'D2'): 3,\n    ('O1', 'D3'): 6,\n    ('O2', 'D1'): 4,\n    ('O2', 'D2'): 6,\n    ('O2', 'D3'): 2\n}\n\n# Define arcs with (cost, capacity)\narcs = {}\nfor (origin, dest), cost in shipping_costs.items():\n    arcs[(origin, dest)] = (cost, float('inf'))  # All routes have unlimited capacity initially\n\n# Create a new Gurobi model\nmodel = gp.Model(\"SimpleTransportationProblem\")\nmodel.Params.LogToConsole = 0\n\n# Create flow variables for each arc\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints\nfor i in nodes:\n    # Sum of flows leaving node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of flows entering node i\n    inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Solve the model\nmodel.optimize()\n\n# Extract the solution\nflow_values = {}\ntotal_cost = 0\n\nfor (i, j), var in flow.items():\n    flow_amount = var.X\n    \n    # Only include arcs with positive flow\n    if flow_amount > 0.001:\n        flow_values[(i, j)] = flow_amount\n        \n        # Add to the total cost\n        cost = arcs[(i, j)][0]\n        total_cost += flow_amount * cost\n\nprint(\"\\nOptimal shipping plan:\")\nfor (origin, dest), amount in sorted(flow_values.items()):\n    cost = arcs[(origin, dest)][0]\n    print(f\"{origin} → {dest}: {amount:.1f} units (cost: ${cost}/unit, total: ${amount*cost:.1f})\")\n\nprint(f\"\\nTotal transportation cost: ${total_cost:.1f}\")\n\n# Export results to CSV (as requested)\nflow_data = []\nfor (i, j), amount in flow_values.items():\n    cost = arcs[(i, j)][0]\n    flow_data.append({\n        'origin': i,\n        'destination': j,\n        'flow': round(amount, 1),\n        'cost_per_unit': cost,\n        'total_cost': round(amount * cost, 1)\n    })\n\nflow_df = pd.DataFrame(flow_data)\nflow_df.to_csv('exercise1_solution.csv', index=False)\nprint()\nprint(flow_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSet parameter LogToConsole to value 0\n\nOptimal shipping plan:\nO1 → D2: 150.0 units (cost: $3/unit, total: $450.0)\nO2 → D1: 100.0 units (cost: $4/unit, total: $400.0)\nO2 → D2: 50.0 units (cost: $6/unit, total: $300.0)\nO2 → D3: 100.0 units (cost: $2/unit, total: $200.0)\n\nTotal transportation cost: $1350.0\n\n  origin destination   flow  cost_per_unit  total_cost\n0     O1          D2  150.0              3       450.0\n1     O2          D1  100.0              4       400.0\n2     O2          D2   50.0              6       300.0\n3     O2          D3  100.0              2       200.0\n```\n:::\n:::\n\n\nThe optimal solution shows how to allocate shipments to minimize the total transportation cost. In the optimal solution, we typically see that cheaper routes are preferred (like O1→D2 with cost $3/unit) over more expensive alternatives. The CSV export functionality demonstrates how to save results for further analysis.\n\nIf you've noticed by now, a lot of the Python code is cookie-cutter once you create the initial setup.\n\n### Network with Capacity Constraints\n\nExtend Exercise 1 by adding the following capacity constraints:\n\n- The route from O1 to D2 can handle at most 80 units\n- The route from O2 to D3 can handle at most 60 units\n\nAnswer the following:\n\n1. How do these constraints change the optimal solution?\n2. Which routes are now at capacity?\n3. How much does the total cost increase due to these constraints?\n\n#### Solution\n\nThis solution extends Exercise 1 by adding capacity constraints on specific routes:\n\n- O1 to D2: maximum 80 units\n- O2 to D3: maximum 60 units\n\nThe solution approach:\n\n1. Solves both the unconstrained and constrained versions of the problem\n2. Compares the solutions to understand the impact of capacity constraints\n3. Identifies which routes are at capacity in the optimal solution\n4. Calculates the cost increase due to the constraints\n\n::: {#4140f23e .cell execution_count=8}\n``` {.python .cell-code}\n# Define capacity constraints\ncapacity_constraints = {\n    ('O1', 'D2'): 80,   # Route from O1 to D2 has max capacity of 80 units\n    ('O2', 'D3'): 60    # Route from O2 to D3 has max capacity of 60 units\n}\n\n# Update arcs with capacity constraints\nfor (origin, dest) in capacity_constraints:\n    cost = arcs[(origin, dest)][0]\n    arcs[(origin, dest)] = (cost, capacity_constraints[(origin, dest)])\n\n    # Create a new Gurobi model\nmodel_constrained = gp.Model(\"CapacitatedTransportationProblem\")\nmodel_constrained.Params.LogToConsole = 0\n\n# Create flow variables for each arc\nflow_constrained = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow_constrained[(i, j)] = model_constrained.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints\nfor i in nodes:\n    # Sum of flows leaving node i\n    outflow = gp.quicksum(flow_constrained[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of flows entering node i\n    inflow = gp.quicksum(flow_constrained[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model_constrained.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Add capacity constraints\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity < float('inf'):\n        model_constrained.addConstr(flow_constrained[(i, j)] <= capacity, name=f'capacity_{i}_{j}')\n\n# Set objective to minimize total cost\nmodel_constrained.ModelSense = GRB.MINIMIZE\n\n# Solve the model\nmodel_constrained.optimize()\n\n# Extract the solution\nflow_values_constrained = {}\ntotal_cost_constrained = 0\n\nfor (i, j), var in flow_constrained.items():\n    flow_amount = var.X\n    \n    # Only include arcs with positive flow\n    if flow_amount > 0.001:\n        flow_values_constrained[(i, j)] = flow_amount\n        \n        # Add to the total cost\n        cost = arcs[(i, j)][0]\n        total_cost_constrained += flow_amount * cost\n\nprint(\"\\nConstrained Solution:\")\nprint(\"-\" * 30)\n\nfor (origin, dest), amount in sorted(flow_values_constrained.items()):\n    cost = arcs[(origin, dest)][0]\n    capacity = arcs[(origin, dest)][1]\n    \n    capacity_info = \"\"\n    if capacity < float('inf') and abs(amount - capacity) < 0.1:\n        capacity_info = \" (AT CAPACITY)\"\n    \n    print(f\"{origin} → {dest}: {amount:.1f} units (cost: ${cost}/unit, total: ${amount*cost:.1f}){capacity_info}\")\n\nprint(f\"\\nTotal transportation cost: ${total_cost_constrained:.1f}\")\n\n# Calculate cost difference\ncost_difference = total_cost_constrained - total_cost # from ex 1 solution\npercentage_increase = (cost_difference / total_cost) * 100\n\nprint(\"\\nCost Comparison:\")\nprint(f\"Cost increase due to capacity constraints: ${cost_difference:.1f} ({percentage_increase:.1f}%)\")\n\n# Export results to CSV\nflow_data = []\n\n# Add unconstrained solution data\nfor (i, j), amount in flow_values.items():\n    cost = arcs[(i, j)][0]\n    capacity = arcs[(i, j)][1]\n    at_capacity = \"Yes\" if capacity < float('inf') and abs(amount - capacity) < 0.1 else \"No\"\n    \n    flow_data.append({\n        'scenario': \"Unconstrained\",\n        'origin': i,\n        'destination': j,\n        'flow': round(amount, 1),\n        'cost_per_unit': cost,\n        'total_cost': round(amount * cost, 1),\n        'capacity': capacity if capacity < float('inf') else \"Unlimited\",\n        'at_capacity': at_capacity\n    })\n\n# Add constrained solution data\nfor (i, j), amount in flow_values_constrained.items():\n    cost = arcs[(i, j)][0]\n    capacity = arcs[(i, j)][1]\n    at_capacity = \"Yes\" if capacity < float('inf') and abs(amount - capacity) < 0.1 else \"No\"\n    \n    flow_data.append({\n        'scenario': \"Constrained\",\n        'origin': i,\n        'destination': j,\n        'flow': round(amount, 1),\n        'cost_per_unit': cost,\n        'total_cost': round(amount * cost, 1),\n        'capacity': capacity if capacity < float('inf') else \"Unlimited\",\n        'at_capacity': at_capacity\n    })\n\nflow_df = pd.DataFrame(flow_data)\nprint(flow_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSet parameter LogToConsole to value 0\n\nConstrained Solution:\n------------------------------\nO1 → D1: 30.0 units (cost: $5/unit, total: $150.0)\nO1 → D2: 80.0 units (cost: $3/unit, total: $240.0) (AT CAPACITY)\nO1 → D3: 40.0 units (cost: $6/unit, total: $240.0)\nO2 → D1: 70.0 units (cost: $4/unit, total: $280.0)\nO2 → D2: 120.0 units (cost: $6/unit, total: $720.0)\nO2 → D3: 60.0 units (cost: $2/unit, total: $120.0) (AT CAPACITY)\n\nTotal transportation cost: $1750.0\n\nCost Comparison:\nCost increase due to capacity constraints: $400.0 (29.6%)\n        scenario origin destination   flow  cost_per_unit  total_cost  \\\n0  Unconstrained     O1          D2  150.0              3       450.0   \n1  Unconstrained     O2          D1  100.0              4       400.0   \n2  Unconstrained     O2          D2   50.0              6       300.0   \n3  Unconstrained     O2          D3  100.0              2       200.0   \n4    Constrained     O1          D1   30.0              5       150.0   \n5    Constrained     O1          D2   80.0              3       240.0   \n6    Constrained     O1          D3   40.0              6       240.0   \n7    Constrained     O2          D1   70.0              4       280.0   \n8    Constrained     O2          D2  120.0              6       720.0   \n9    Constrained     O2          D3   60.0              2       120.0   \n\n    capacity at_capacity  \n0         80          No  \n1  Unlimited          No  \n2  Unlimited          No  \n3         60          No  \n4  Unlimited          No  \n5         80         Yes  \n6  Unlimited          No  \n7  Unlimited          No  \n8  Unlimited          No  \n9         60         Yes  \n```\n:::\n:::\n\n\nThe comparison provides an important real-world insight: limited shipping capacity often leads to higher transportation costs as companies are forced to use less efficient routes. The solution exports detailed results to a CSV file for further analysis, showing both the unconstrained and constrained flows side by side.\n\nThis exercise demonstrates how to implement and analyze capacity constraints in transportation networks, which is a common challenge in real-world supply chain management.\n\n",
    "supporting": [
      "06-minimum-cost-network-flow-modeling_files"
    ],
    "filters": [],
    "includes": {}
  }
}