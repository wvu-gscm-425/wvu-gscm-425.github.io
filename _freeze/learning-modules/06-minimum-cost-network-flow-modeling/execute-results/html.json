{
  "hash": "df0ab48cef7a12e5a448a24a074db001",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"06 | Minimum Cost Network Flow Models\"\nsubtitle: \"Optimizing Transportation in Supply Chain Networks\"\nformat: \n  html:\n    other-links:\n      - text: \"min_cost_ex_arcs.csv\"\n        href: \"data/min_cost_ex_arcs.csv\"\n        icon: file-earmark-spreadsheet\n      - text: \"min_cost_ex_nodes.csv\"\n        href: \"data/min_cost_ex_nodes.csv\"\n        icon: file-earmark-spreadsheet\n      - text: \"min_cost_ex_solution.csv\"\n        href: \"data/min_cost_ex_solution.csv\"\n        icon: file-earmark-spreadsheet\norder: 6\n---\n\n\n\n\n## Overview\n\nNetwork flow models are powerful tools for optimizing the movement of goods through a supply chain network. The minimum cost network flow model helps determine the most cost-effective way to transport products from origins (like factories) to destinations (like warehouses).\n\nIn this module, you will learn how to:\n\n1. Understand the key components of network flow problems\n2. Formulate these as linear programming models\n3. Implement and solve them using both Excel Solver and Python/Gurobi\n4. Analyze different scenarios to make better supply chain decisions\n\n## Key Components of Network Flow Problems\n\nA minimum cost network flow problem has three main components:\n\n1. **Nodes**: Points in the network representing locations\n   - **Supply nodes**: Where products originate (factories, plants)\n   - **Transshipment nodes**: Intermediate points (distribution centers)\n   - **Demand nodes**: Where products are required (warehouses, customers)\n\n2. **Arcs**: Connections between nodes representing possible flow paths\n   - Each arc has a **cost per unit** of flow\n   - Each arc may have a **capacity limit**\n\n3. **Flows**: The amount of resource moving along each arc\n   - Flow must be conserved at each node (total inflow = total outflow, except at supply/demand nodes)\n   - Total supply must equal total demand for the problem to have feasible solutions\n\n### Mathematical Formulation\n\nLet's define:\n\n- $x_{ij}$ = flow from node $i$ to node $j$\n- $c_{ij}$ = cost per unit flow from node $i$ to node $j$\n- $u_{ij}$ = capacity of arc from node $i$ to node $j$\n- $b_i$ = net flow at node $i$ (positive for supply, negative for demand, zero for transshipment)\n\nThe general formulation is:\n\n**Objective**: Minimize $\\sum_{(i,j)} c_{ij} \\cdot x_{ij}$\n\n**Subject to**:\n\n1. Flow Conservation: $\\sum_{j:(i,j)} x_{ij} - \\sum_{j:(j,i)} x_{ji} = b_i$ for all nodes $i$\n2. Capacity Constraints: $0 \\leq x_{ij} \\leq u_{ij}$ for all arcs $(i,j)$\n\n## Example 01: Distribution Unlimited Co.\n\nLet's apply this to a concrete example. Distribution Unlimited Co. has two factories (F1, F2) that need to ship products to two warehouses (W1, W2). There's also a distribution center (DC) that can be used as an intermediate point.\n\n\n\n\n```{mermaid}\nflowchart LR\n    F1(Factory 1<br/>80 units)\n    F2(Factory 2<br/>40 units)\n    DC(Distribution Center)\n    W1(Warehouse 1<br/>-60 units)\n    W2(Warehouse 2<br/>-90 units)\n    \n    F1 -->|$7/unit| W1\n    F1 -->|$3/unit<br/>Max 50 units| DC\n    F2 -->|$4/unit<br/>Max 50 units| DC\n    DC -->|$0/unit| W1\n    DC -->|$2/unit<br/>Max 60 units| W2\n```\n\n\n\n\nThe network includes:\n\n- Factory 1 (F1) produces 80 units\n- Factory 2 (F2) produces 40 units\n- Warehouse 1 (W1) requires 60 units\n- Warehouse 2 (W2) requires 90 units\n\nNotice that total demand (150 units) exceeds total supply (120 units). This means we'll need to handle unfulfilled demand in our model.\n\n### Handling Supply-Demand Imbalance\n\nWhen total supply doesn't equal total demand, we can:\n\n1. **Add a dummy supply node** (if supply < demand)\n2. **Add a dummy demand node** (if supply > demand)\n\nFor Distribution Unlimited Co., we'll add a dummy supply of 30 units with zero transportation cost to make the problem feasible:\n\n\n\n\n```{mermaid}\nflowchart LR\n    F1(Factory 1<br/>80 units)\n    F2(Factory 2<br/>40 units)\n    DC(Distribution Center)\n    W1(Warehouse 1<br/>-60 units)\n    W2(Warehouse 2<br/>-90 units)\n    DS(Dummy Supply<br/>30 units)\n    \n    F1 -->|$7/unit| W1\n    F1 -->|$3/unit<br/>Max 50 units| DC\n    F2 -->|$4/unit<br/>Max 50 units| DC\n    DC -->|$0/unit| W1\n    DC -->|$2/unit<br/>Max 60 units| W2\n    DS -->|$0/unit| W2\n```\n\n\n\n\n### Excel Implementation\n\nFor Excel implementation, we'll set up a table structure:\n\n1. Create a transportation table showing all possible routes\n2. Add columns for costs, capacities, and flow variables\n3. Set up flow conservation constraints for each node\n4. Use Solver to find the optimal solution\n\n### Step-by-Step Excel Implementation\n\n1. **Decision Variables Table**:\n   \n   | From | To | Flow | Cost/Unit | Total Cost | Capacity | At Capacity? |\n   |------|------|------|-----------|------------|----------|--------------|\n   | F1 | W1 | ? | 7 | ? | 999 | ? |\n   | F1 | DC | ? | 3 | ? | 50 | ? |\n   | F2 | DC | ? | 4 | ? | 50 | ? |\n   | DC | W1 | ? | 0 | ? | 999 | ? |\n   | DC | W2 | ? | 2 | ? | 60 | ? |\n   | Dummy | W2 | ? | 0 | ? | 999 | ? |\n\n2. **Node Flow Summary**:\n   \n   | Node | Supply/Demand | Inflow | Outflow | Net Flow | Constraint Met? |\n   |------|---------------|--------|---------|----------|-----------------|\n   | F1 | 80 | ? | ? | ? | ? |\n   | F2 | 40 | ? | ? | ? | ? |\n   | DC | 0 | ? | ? | ? | ? |\n   | W1 | -60 | ? | ? | ? | ? |\n   | W2 | -90 | ? | ? | ? | ? |\n   | Dummy | 30 | ? | ? | ? | ? |\n\n3. **Set Up Excel Solver**:\n   - Objective: Minimize total cost\n   - By changing: Flow variables\n   - Subject to: Flow conservation, capacity constraints, non-negativity\n\n### Excel Solution\n\nWhen we solve this using Excel Solver, we get the following optimal flows:\n\n- F1 → DC: 50 units (at capacity)\n- F1 → W1: 30 units\n- F2 → DC: 40 units\n- DC → W1: 30 units\n- DC → W2: 60 units (at capacity)\n- Dummy → W2: 30 units (unfulfilled demand)\n\nTotal cost = $640\n\n\n\n\n```{mermaid}\nflowchart LR\n    F1(Factory 1<br/>80 units)\n    F2(Factory 2<br/>40 units)\n    DC(Distribution Center)\n    W1(Warehouse 1<br/>-60 units)\n    W2(Warehouse 2<br/>-90 units)\n    DS(Dummy Supply<br/>30 units)\n    \n    F1 -->|30 units<br/>$7/unit| W1\n    F1 -->|50 units<br/>$3/unit| DC\n    F2 -->|40 units<br/>$4/unit| DC\n    DC -->|30 units<br/>$0/unit| W1\n    DC -->|60 units<br/>$2/unit| W2\n    DS -->|30 units<br/>$0/unit| W2\n    \n    style F1 fill:#d4f1c5\n    style F2 fill:#d4f1c5\n    style DS fill:#d4f1c5\n    style W1 fill:#c5daf1\n    style W2 fill:#c5daf1\n    style DC fill:#f1e9c5\n```\n\n\n\n\n### Python Implementation\n\nThe Python implementation uses Gurobi Optimizer through its Python interface, `gurobipy`. Unlike Excel, which uses a tabular format, Python builds the model programmatically. Let's break down how this works step by step.\n\nHere's the basic structure:\n\n1. Define nodes and their supply/demand values\n2. Define arcs with costs and capacities\n3. Create decision variables for flows\n4. Add flow conservation constraints\n5. Add capacity constraints\n6. Set the objective and solve the model\n\n#### Setting up the Environment\n\nFirst, we need to import the necessary libraries:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n```\n\nGurobipy is Gurobi's Python API, and GRB provides constants like GRB.MINIMIZE for setting the optimization direction.\n\n#### Defining the Problem Structure\n\nNext, we define our network structure using Python data structures:\n\n::: {#d495dce0 .cell execution_count=1}\n``` {.python .cell-code}\n# Define nodes\nnodes = ['F1', 'F2', 'DC', 'W1', 'W2', 'Dummy']\n\n# Define supply/demand at each node\nsupply_demand = {\n    'F1': 80,    # Supply of 80 units\n    'F2': 40,    # Supply of 40 units\n    'DC': 0,     # Transshipment node (no net supply/demand)\n    'W1': -60,   # Demand of 60 units\n    'W2': -90,   # Demand of 90 units\n    'Dummy': 30  # Dummy supply of 30 units\n}\n\n# Define arcs with costs and capacities\narcs = {\n    ('F1', 'W1'): (7, float('inf')),  # Direct route from F1 to W1\n    ('F1', 'DC'): (3, 50),            # Route from F1 to DC with capacity 50\n    ('F2', 'DC'): (4, 50),            # Route from F2 to DC with capacity 50\n    ('DC', 'W1'): (0, float('inf')),  # Route from DC to W1\n    ('DC', 'W2'): (2, 60),            # Route from DC to W2 with capacity 60\n    ('Dummy', 'W2'): (0, float('inf'))  # Dummy route to W2\n}\n```\n:::\n\n\nThis approach is very flexible. We can easily add or remove nodes and arcs by modifying these data structures.\n\n#### Creating the Optimization Model\n\nNow we create a Gurobi model and define the flow variables:\n\n```python\n# Create a new model\nmodel = gp.Model(\"MinCostNetworkFlow\")\n\n# Create flow variables for each arc\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n```\n\nEach variable `flow[(i, j)]` represents the amount flowing from node `i` to node `j`. The `obj=cost` parameter sets the coefficient in the objective function.\n\n##### `flow = {}`\n\nThis initializes an empty Python dictionary called `flow`. This dictionary will store our decision variables, which represent the amount of product flowing along each arc in the network. The dictionary's keys will be tuples representing arcs (from node $i$ to node $j$), and the values will be Gurobi variable objects.\n\n##### `arcs.items()`\n\nThe `arcs` variable is a dictionary where:\n\n- Each key is a tuple `(i, j)` representing an arc from node $i$ to node $j$.\n- Each value is another tuple `(cost, capacity)` containing the cost per unit of flow and the maximum capacity for that arc.\n\nThe `items()` method returns an iterator over the key-value pairs in the dictionary, so `arcs.items()` produces pairs like: `((i, j), (cost, capacity))`.\n\n::: {#0a9edb70 .cell execution_count=2}\n``` {.python .cell-code}\nfor value in arcs.items():\n    print(value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(('F1', 'W1'), (7, inf))\n(('F1', 'DC'), (3, 50))\n(('F2', 'DC'), (4, 50))\n(('DC', 'W1'), (0, inf))\n(('DC', 'W2'), (2, 60))\n(('Dummy', 'W2'), (0, inf))\n```\n:::\n:::\n\n\n##### `for (i, j), (cost, _) in arcs.items():`\n\nThis line uses Python's tuple unpacking to extract values. For each iteration:\n\n- `(i, j)` captures the origin and destination nodes from the arc tuple.\n- `(cost, _)` captures the cost while ignoring the capacity (the underscore `_` is a Python convention for a variable you don't intend to use).\n\nFor example, if one entry in `arcs` is `('F1', 'DC'): (3, 50)`, then in that iteration:\n\n- `i` would be `'F1'` (the origin node)\n- `j` would be `'DC'` (the destination node)\n- `cost` would be `3` (the cost per unit of flow)\n- `_` would be `50` (the capacity, which we're ignoring for now)\n\n##### `flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)`\n\nFor each arc, this line creates a Gurobi decision variable and adds it to our flow dictionary:\n\n- `model.addVar()` creates a new decision variable in the Gurobi model.\n- `name=f'flow_{i}_{j}'` gives the variable a descriptive name like `\"flow_F1_DC\"`.\n- `obj=cost` sets the variable's coefficient in the objective function to the cost of this arc.\n- `flow[(i, j)] = ...` stores the created variable in our dictionary with the arc tuple as the key.\n\nBy default, Gurobi variables are non-negative (`lb = 0`) and continuous, which is what we want for flow variables in this network problem.\n\n##### What's Happening Overall\n\nThis loop iterates through each possible shipping route (arc) in our network. For each arc, it:\n\n1. Extracts the origin node, destination node, and shipping cost\n2. Creates a variable representing \"how much to ship from origin to destination\"\n3. Associates that variable with the arc's cost in the objective function\n4. Stores the variable in a dictionary for later use when creating constraints\n\nAfter this loop completes, the `flow` dictionary contains all the decision variables our model needs, with each variable properly connected to its cost in the objective function. This is the foundation of our optimization model, we're creating variables for each possible shipment route and telling Gurobi that we want to minimize the total shipping cost.\n\nThe next parts of the code will add constraints to ensure flow conservation (what comes in equals what goes out at each node) and to enforce capacity limits on certain routes.\n\n#### Adding Flow Conservation Constraints\n\nThe most important constraints ensure flow conservation at each node:\n\n```python\n# Add flow conservation constraints for each node\nfor i in nodes:\n    # Sum of all flows leaving node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of all flows entering node i\n    inflow  = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n```\n\nThis loop creates one constraint for each node. The constraint ensures that:\n\n- For supply nodes: $outflow - inflow = supply amount$\n- For demand nodes: $outflow - inflow = -demand amount$\n- For transshipment nodes: $outflow - inflow = 0$\n\n##### `for i in nodes:`\n\nThis loop iterates through each node in our network. For every node (whether it's a factory, warehouse, or distribution center), we need to create a flow conservation constraint.\n\nFlow conservation is a fundamental principle in network flow models. It states that for any node in the network:\n\n- The amount of flow entering the node, minus\n- The amount of flow leaving the node,\n- Must equal the node's supply or demand value\n\nThis mirrors real-world physical constraints: products don't disappear or materialize within the network (except at supply or demand nodes).\n\n##### `outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)`\n\nThis line calculates the total flow leaving node `i`:\n\n1. `arcs.keys()` gives us all the arc tuples `(i2, j)` in our network.\n2. `if i2 == i` filters for only those arcs where the origin node matches our current node `i`.\n3. `flow[(i, j)]` retrieves the decision variable representing flow on the arc from node `i` to some other node `j`.\n4. `gp.quicksum(...)` sums up all these flow variables.\n\nEssentially, we're adding up all the flow variables for arcs that originate from node `i`.\n\nThe reason for using `i2` here is that we're unpacking tuples from `arcs.keys()`. Each tuple is an arc represented as `(origin, destination)`. We use `i2` as a temporary variable name to compare with our current node `i`.\n\n##### `inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)`\n\nSimilarly, this line calculates the total flow entering node `i`:\n\n1. `arcs.keys()` gives us all the arc tuples `(j, i2)` in our network.\n2. `if i2 == i` filters for only those arcs where the destination node matches our current node `i`.\n3. `flow[(j, i)]` retrieves the decision variable representing flow on the arc from some other node `j` to node `i`.\n4. `gp.quicksum(...)` sums up all these flow variables.\n\nThis time, we're adding up all the flow variables for arcs that terminate at node `i`.\n\n##### `model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')`\n\nFinally, we add the constraint to our model:\n\n1. `outflow - inflow` calculates the net flow (outgoing minus incoming) at node `i`.\n2. `supply_demand[i]` retrieves the supply/demand value for node `i`:\n    - Positive supply for supply nodes (more going out than coming in)\n    - Negative for demand nodes (more coming in than going out)\n    - Zero for transshipment nodes (what comes in must equal what goes out)\n3. `model.addConstr(...)` adds this constraint to the Gurobi model.\n4. `name=f'node_{i}'` gives the constraint a unique name for identification.\n\nThe constraint enforces different behaviors depending on the node type:\n\n- **Supply Nodes**: If `supply_demand[i] = 50`, then `outflow - inflow = 50`, meaning the node sends out 50 more units than it receives.\n- **Demand Nodes**: If `supply_demand[i] = -30`, then `outflow - inflow = -30`, meaning the node receives 30 more units than it sends out.\n- **Transshipment Nodes**: If `supply_demand[i] = 0`, then `outflow - inflow = 0`, meaning everything that enters the node must also leave it.\n\n#### Adding Capacity Constraints\n\nSome arcs have capacity limits:\n\n```python\n# Add capacity constraints for each arc\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity < float('inf'):\n        model.addConstr(flow[(i, j)] <= capacity, name=f'capacity_{i}_{j}')\n```\n\nThis only adds constraints for arcs with finite capacity. We use `float('inf')` to represent unlimited capacity.\n\n##### `for (i, j), (_, capacity) in arcs.items():`\n\nThis loop iterates through each arc in our network and its corresponding capacity. Let's break down the unpacking:\n\n1. `arcs.items()` returns pairs of `((i, j), (cost, capacity))` where:\n    - `(i, j)` is the arc from node `i` to node `j`\n    - `(cost, capacity)` contains the shipping cost and maximum capacity\n2. `(i, j), (_, capacity)` unpacks these values:\n    - `i` is the origin node\n    - `j` is the destination node\n    - `_` is the cost (we use underscore because we don't need the cost for capacity constraints)\n    - `capacity` is the maximum amount that can flow on this arc\n\nFor example, if arcs contains ('F1', 'DC'): (3, 50), then in that iteration:\n\n- `i` would be `'F1'` (origin)\n- `j` would be `'DC'` (destination)\n- `_` would be `3` (cost, ignored here)\n- `capacity` would be `50` (maximum flow allowed)\n\n##### `if capacity < float('inf'):`\n\nNot all arcs need capacity constraints. Many routes have no practical limit, or their limit is so large that it won't affect the optimal solution. In our code:\n\n- `float('inf')` represents infinity in Python\n- `capacity < float('inf')` checks if the capacity is a finite number\n    - If true, we need to add a capacity constraint\n    - If false (capacity is infinite), no constraint is needed\n\nThis condition ensures we only add constraints where necessary, keeping our model streamlined.\n\n##### `model.addConstr(flow[(i, j)] <= capacity, name=f'capacity_{i}_{j}')`\n\nThis line creates and adds the actual capacity constraint to our model:\n\n1. `flow[(i, j)]` accesses the decision variable representing flow on this arc\n2. `flow[(i, j)] <= capacity` creates a constraint saying the flow cannot exceed the capacity\n3. `model.addConstr(...)` adds this constraint to the Gurobi model\n4. `name=f'capacity_{i}_{j}'` gives the constraint a descriptive name like \"capacity_F1_DC\"\n\n#### Setting the Objective and Solving\n\nFinally, we set the objective function and solve the model:\n\n```python\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Optimize the model\nmodel.optimize()\n```\n\n#### Extracting and Analyzing the Solution\n\nAfter solving, we can extract and analyze the results:\n\n```python\n# Check if an optimal solution was found\nif model.Status == GRB.OPTIMAL:\n    # Extract the solution\n    flow_values = {}\n    total_cost = 0\n    \n    for (i, j), var in flow.items():\n        # Get the flow amount for this arc\n        flow_amount = var.X\n        \n        # Only include arcs with positive flow\n        if flow_amount > 0.001:  # Small threshold for floating-point errors\n            flow_values[(i, j)] = flow_amount\n            \n            # Add to the total cost\n            cost = arcs[(i, j)][0]\n            total_cost += flow_amount * cost\n    \n    print(\"Optimal flows:\")\n    for (i, j), flow in sorted(flow_values.items()):\n        cost = arcs[(i, j)][0]\n        print(f\"{i} → {j}: {flow:.1f} units (cost: ${cost}/unit)\")\n    \n    print(f\"<br/>Total transportation cost: ${total_cost:.1f}\")\nelse:\n    print(f\"No optimal solution found. Status code: {model.Status}\")\n```\n\nThis code extracts the flow values from the solution, calculates the total cost, and prints a summary of the optimal flows.\n\n#### All Together\n\n::: {#1a433e41 .cell execution_count=3}\n``` {.python .cell-code}\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Define nodes\nnodes = ['F1', 'F2', 'DC', 'W1', 'W2', 'Dummy']\n\n# Define supply/demand at each node\nsupply_demand = {\n    'F1': 80,    # Supply of 80 units\n    'F2': 40,    # Supply of 40 units\n    'DC': 0,     # Transshipment node (no net supply/demand)\n    'W1': -60,   # Demand of 60 units\n    'W2': -90,   # Demand of 90 units\n    'Dummy': 30  # Dummy supply of 30 units\n}\n\n# Define arcs with costs and capacities\narcs = {\n    ('F1', 'W1'): (7, float('inf')),  # Direct route from F1 to W1\n    ('F1', 'DC'): (3, 50),            # Route from F1 to DC with capacity 50\n    ('F2', 'DC'): (4, 50),            # Route from F2 to DC with capacity 50\n    ('DC', 'W1'): (0, float('inf')),  # Route from DC to W1\n    ('DC', 'W2'): (2, 60),            # Route from DC to W2 with capacity 60\n    ('Dummy', 'W2'): (0, float('inf'))  # Dummy route to W2\n}\n\n# Create a new model\nmodel = gp.Model(\"MinCostNetworkFlow\")\n\n# Create flow variables for each arc\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints for each node\nfor i in nodes:\n    # Sum of all flows leaving node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of all flows entering node i\n    inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Add capacity constraints for each arc\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity < float('inf'):\n        model.addConstr(flow[(i, j)] <= capacity, name=f'capacity_{i}_{j}')\n\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Optimize the model\nmodel.optimize()\n\n# Check if an optimal solution was found\nif model.Status == GRB.OPTIMAL:\n    # Extract the solution\n    flow_values = {}\n    total_cost = 0\n    \n    for (i, j), var in flow.items():\n        # Get the flow amount for this arc\n        flow_amount = var.X\n        \n        # Only include arcs with positive flow\n        if flow_amount > 0.001:  # Small threshold for floating-point errors\n            flow_values[(i, j)] = flow_amount\n            \n            # Add to the total cost\n            cost = arcs[(i, j)][0]\n            total_cost += flow_amount * cost\n    \n    print(\"Optimal flows:\")\n    for (i, j), flow in sorted(flow_values.items()):\n        cost = arcs[(i, j)][0]\n        print(f\"{i} → {j}: {flow:.1f} units (cost: ${cost}/unit)\")\n    \n    print(f\"<br/>Total transportation cost: ${total_cost:.1f}\")\nelse:\n    print(f\"No optimal solution found. Status code: {model.Status}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSet parameter Username\nSet parameter LicenseID to value 2609229\nGurobi Optimizer version 12.0.1 build v12.0.1rc0 (win64 - Windows 11.0 (26100.2))\n\nCPU model: 13th Gen Intel(R) Core(TM) i9-13900H, instruction set [SSE2|AVX|AVX2]\nThread count: 14 physical cores, 20 logical processors, using up to 20 threads\n\nOptimize a model with 9 rows, 6 columns and 15 nonzeros\nModel fingerprint: 0x34da7e99\nCoefficient statistics:\n  Matrix range     [1e+00, 1e+00]\n  Objective range  [2e+00, 7e+00]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [3e+01, 9e+01]\nPresolve removed 9 rows and 6 columns\nPresolve time: 0.00s\nPresolve: All rows and columns removed\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    6.4000000e+02   0.000000e+00   0.000000e+00      0s\n\nSolved in 0 iterations and 0.01 seconds (0.00 work units)\nOptimal objective  6.400000000e+02\nOptimal flows:\nDC → W1: 30.0 units (cost: $0/unit)\nDC → W2: 60.0 units (cost: $2/unit)\nDummy → W2: 30.0 units (cost: $0/unit)\nF1 → DC: 50.0 units (cost: $3/unit)\nF1 → W1: 30.0 units (cost: $7/unit)\nF2 → DC: 40.0 units (cost: $4/unit)\n<br/>Total transportation cost: $640.0\n```\n:::\n:::\n\n\n#### Advantages of the Python Approach\n\nThe Python/Gurobi approach offers several advantages:\n\n- Scales to very large networks (hundreds of nodes and arcs)\n- Easier to modify and analyze multiple scenarios\n- Can be integrated with other Python tools for data analysis and visualization\n- Faster for complex problems\n- More sophisticated error handling and reporting\n\nHere is a version of this problem with five factories, 3 distribution centers, and eight warehouse locations:\n\n\n\n\n```{mermaid}\nflowchart LR\n    %% Supply Nodes (Factories)\n    F1[Factory 1<br/>120 units]\n    F2[Factory 2<br/>150 units]\n    F3[Factory 3<br/>200 units]\n    F4[Factory 4<br/>180 units]\n    F5[Factory 5<br/>250 units]\n    \n    %% Transshipment Nodes (Distribution Centers)\n    DC1[Distribution Center 1]\n    DC2[Distribution Center 2]\n    DC3[Distribution Center 3]\n    \n    %% Demand Nodes (Warehouses)\n    W1[Warehouse 1<br/>-80 units]\n    W2[Warehouse 2<br/>-110 units]\n    W3[Warehouse 3<br/>-90 units]\n    W4[Warehouse 4<br/>-130 units]\n    W5[Warehouse 5<br/>-150 units]\n    W6[Warehouse 6<br/>-100 units]\n    W7[Warehouse 7<br/>-120 units]\n    W8[Warehouse 8<br/>-120 units]\n    \n    %% Factory to DC connections\n    F1 -->|$3/unit<br/>Max 100| DC1\n    F1 -->|$4/unit<br/>Max 80| DC2\n    F2 -->|$4/unit<br/>Max 90| DC1\n    F2 -->|$3/unit<br/>Max 100| DC2\n    F3 -->|$3/unit<br/>Max 120| DC2\n    F3 -->|$2/unit<br/>Max 150| DC3\n    F4 -->|$4/unit<br/>Max 100| DC2\n    F4 -->|$3/unit<br/>Max 110| DC3\n    F5 -->|$5/unit<br/>Max 80| DC1\n    F5 -->|$2/unit<br/>Max 200| DC3\n    \n    %% Sample direct Factory to Warehouse connections\n    F1 -.->|$8/unit| W1\n    F2 -.->|$8/unit| W2\n    F3 -.->|$9/unit| W4\n    F4 -.->|$10/unit| W5\n    F5 -.->|$8/unit| W8\n    \n    %% DC to Warehouse connections (showing representative examples)\n    DC1 -->|$3/unit<br/>Max 100| W1\n    DC1 -->|$4/unit<br/>Max 90| W2\n    DC1 -->|$2/unit<br/>Max 120| W3\n    DC2 -->|$3/unit<br/>Max 100| W3\n    DC2 -->|$2/unit<br/>Max 150| W4\n    DC2 -->|$4/unit<br/>Max 120| W5\n    DC3 -->|$4/unit<br/>Max 90| W6\n    DC3 -->|$3/unit<br/>Max 140| W7\n    DC3 -->|$2/unit<br/>Max 120| W8\n    \n    %% Inter-DC connections\n    DC1 -->|$1/unit<br/>Max 70| DC2\n    DC2 -->|$1/unit<br/>Max 90| DC3\n    DC3 -->|$2/unit<br/>Max 60| DC1\n    \n    %% Node styling\n    classDef supply fill:#d4f1c5,stroke:#333,stroke-width:1px\n    classDef transship fill:#f1e9c5,stroke:#333,stroke-width:1px\n    classDef demand fill:#c5daf1,stroke:#333,stroke-width:1px\n    \n    %% Apply styles\n    class F1,F2,F3,F4,F5 supply\n    class DC1,DC2,DC3 transship\n    class W1,W2,W3,W4,W5,W6,W7,W8 demand\n```\n\n::: {#1ab10d2a .cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\n\"\"\"\nMinimum Cost Network Flow Solver\n\nThis script reads supply chain network data from CSV files and \nsolves the minimum cost network flow problem using Gurobi optimizer.\n\"\"\"\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport pandas as pd\n\n# Read the node data\nprint(\"Reading node data from nodes.csv...\")\nnodes_df = pd.read_csv(r'data\\min_cost_ex_nodes.csv')\n\n# Read the arc data\nprint(\"Reading arc data from arcs.csv...\")\narcs_df = pd.read_csv(r'data\\min_cost_ex_arcs.csv')\n\n# Extract node information\nnodes = nodes_df['node_id'].tolist()\nsupply_demand = dict(zip(nodes_df['node_id'], nodes_df['supply_demand']))\nnode_types = dict(zip(nodes_df['node_id'], nodes_df['type']))\n\n# Group nodes by type for reporting\nfactories = [node for node, type_val in node_types.items() if type_val == 'Factory']\ndistribution_centers = [node for node, type_val in node_types.items() if type_val == 'DC']\nwarehouses = [node for node, type_val in node_types.items() if type_val == 'Warehouse']\n\n# Check supply/demand balance\ntotal_supply = sum(v for v in supply_demand.values() if v > 0)\ntotal_demand = -sum(v for v in supply_demand.values() if v < 0)\nprint(f\"Total supply: {total_supply}\")\nprint(f\"Total demand: {total_demand}\")\nif total_supply != total_demand:\n    print(\"Warning: Supply and demand are not balanced!\")\n\n# Create arcs dictionary from DataFrame\n# Convert 'inf' strings to actual infinity\narcs_df['capacity'] = arcs_df['capacity'].replace('inf', float('inf'))\narcs_df['capacity'] = pd.to_numeric(arcs_df['capacity'])\n\n# Create arcs dictionary\narcs = {}\nfor _, row in arcs_df.iterrows():\n    arcs[(row['from_node'], row['to_node'])] = (row['cost'], row['capacity'])\n\nprint(f\"Network has {len(nodes)} nodes and {len(arcs)} arcs\")\n\n# Create a new Gurobi model\nmodel = gp.Model(\"SupplyChainNetwork\")\n\n# Create flow variables for each arc\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints for each node\nfor i in nodes:\n    # Sum of flows leaving node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of flows entering node i\n    inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Add capacity constraints for each arc\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity < float('inf'):\n        model.addConstr(flow[(i, j)] <= capacity, name=f'capacity_{i}_{j}')\n\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Solve the model\nprint(\"\\nSolving the network flow problem...\")\nmodel.optimize()\n\n# Check if an optimal solution was found\nif model.Status == GRB.OPTIMAL:\n    # Calculate flow statistics\n    active_arcs = 0\n    capacity_limited_arcs = 0\n    total_cost = 0\n    \n    # Dictionaries to track flows by node type\n    factory_flows = {f: 0 for f in factories}\n    dc_throughput = {dc: 0 for dc in distribution_centers}\n    warehouse_inflows = {w: 0 for w in warehouses}\n    \n    # Extract solution\n    flow_values = {}\n    for (i, j), var in flow.items():\n        flow_amount = var.X\n        if flow_amount > 0.001:  # Only count non-zero flows\n            flow_values[(i, j)] = flow_amount\n            active_arcs += 1\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            total_cost += flow_amount * cost\n            \n            # Check if arc is at capacity\n            if capacity < float('inf') and abs(flow_amount - capacity) < 0.001:\n                capacity_limited_arcs += 1\n            \n            # Update node statistics\n            if i in factories:\n                factory_flows[i] += flow_amount\n            if i in distribution_centers:\n                dc_throughput[i] += flow_amount\n            if j in warehouses:\n                warehouse_inflows[j] += flow_amount\n    \n    # Print results\n    print(\"\\n========== OPTIMAL SOLUTION FOUND ==========\")\n    print(f\"Total transportation cost: ${total_cost:.2f}\")\n    print(f\"Active arcs: {active_arcs} out of {len(arcs)} possible\")\n    print(f\"Arcs at capacity: {capacity_limited_arcs}\")\n    \n    # Factory utilization\n    print(\"\\nFACTORY UTILIZATION:\")\n    for f in factories:\n        utilization_pct = (factory_flows[f] / supply_demand[f]) * 100\n        print(f\"  {f}: {factory_flows[f]} units shipped ({utilization_pct:.1f}% of capacity)\")\n    \n    # Distribution center throughput\n    print(\"\\nDISTRIBUTION CENTER THROUGHPUT:\")\n    for dc in distribution_centers:\n        print(f\"  {dc}: {dc_throughput[dc]} units processed\")\n    \n    # Warehouse demand fulfillment\n    print(\"\\nWAREHOUSE DEMAND FULFILLMENT:\")\n    for w in warehouses:\n        received_pct = (warehouse_inflows[w] / (-supply_demand[w])) * 100\n        print(f\"  {w}: {warehouse_inflows[w]} units received ({received_pct:.1f}% of demand)\")\n    \n    # Detailed flow report\n    print(\"\\nDETAILED FLOW REPORT (non-zero flows only):\")\n    \n    # Factory to warehouse direct\n    f_to_w = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n             if i in factories and j in warehouses]\n    if f_to_w:\n        print(\"\\n  Factory → Warehouse (Direct):\")\n        for i, j, amt in sorted(f_to_w):\n            cost = arcs[(i, j)][0]\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f})\")\n    \n    # Factory to DC\n    f_to_dc = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n              if i in factories and j in distribution_centers]\n    if f_to_dc:\n        print(\"\\n  Factory → Distribution Center:\")\n        for i, j, amt in sorted(f_to_dc):\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            at_capacity = \" (at capacity)\" if abs(amt - capacity) < 0.001 else \"\"\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f}){at_capacity}\")\n    \n    # DC to warehouse\n    dc_to_w = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n              if i in distribution_centers and j in warehouses]\n    if dc_to_w:\n        print(\"\\n  Distribution Center → Warehouse:\")\n        for i, j, amt in sorted(dc_to_w):\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            at_capacity = \" (at capacity)\" if abs(amt - capacity) < 0.001 else \"\"\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f}){at_capacity}\")\n    \n    # Inter-DC flows\n    dc_to_dc = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n               if i in distribution_centers and j in distribution_centers]\n    if dc_to_dc:\n        print(\"\\n  Distribution Center → Distribution Center:\")\n        for i, j, amt in sorted(dc_to_dc):\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            at_capacity = \" (at capacity)\" if abs(amt - capacity) < 0.001 else \"\"\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f}){at_capacity}\")\n    \n    # Export solution to CSV\n    solution_data = []\n    for (i, j), flow_amount in flow_values.items():\n        cost = arcs[(i, j)][0]\n        capacity = arcs[(i, j)][1]\n        solution_data.append({\n            'from_node': i,\n            'to_node': j,\n            'flow': flow_amount,\n            'cost_per_unit': cost,\n            'total_cost': flow_amount * cost,\n            'capacity': capacity if capacity < float('inf') else 'unlimited',\n            'at_capacity': 'Yes' if capacity < float('inf') and abs(flow_amount - capacity) < 0.001 else 'No'\n        })\n    \n    solution_df = pd.DataFrame(solution_data)\n    solution_df.to_csv('solution.csv', index=False)\n    print(\"\\nSolution details exported to 'solution.csv'\")\n    \nelse:\n    print(f\"No optimal solution found. Status code: {model.Status}\")\n    print(\"Check your data for inconsistencies in supply/demand balance or network connectivity.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading node data from nodes.csv...\nReading arc data from arcs.csv...\nTotal supply: 900\nTotal demand: 900\nNetwork has 16 nodes and 35 arcs\n\nSolving the network flow problem...\nGurobi Optimizer version 12.0.1 build v12.0.1rc0 (win64 - Windows 11.0 (26100.2))\n\nCPU model: 13th Gen Intel(R) Core(TM) i9-13900H, instruction set [SSE2|AVX|AVX2]\nThread count: 14 physical cores, 20 logical processors, using up to 20 threads\n\nOptimize a model with 41 rows, 35 columns and 95 nonzeros\nModel fingerprint: 0x46d73227\nCoefficient statistics:\n  Matrix range     [1e+00, 1e+00]\n  Objective range  [1e+00, 1e+01]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [6e+01, 3e+02]\nPresolve removed 29 rows and 3 columns\nPresolve time: 0.00s\nPresolved: 12 rows, 32 columns, 54 nonzeros\n\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    2.2300000e+03   1.675000e+02   0.000000e+00      0s\n      12    5.1200000e+03   0.000000e+00   0.000000e+00      0s\n\nSolved in 12 iterations and 0.01 seconds (0.00 work units)\nOptimal objective  5.120000000e+03\n\n========== OPTIMAL SOLUTION FOUND ==========\nTotal transportation cost: $5120.00\nActive arcs: 23 out of 35 possible\nArcs at capacity: 9\n\nFACTORY UTILIZATION:\n  F1: 120.0 units shipped (100.0% of capacity)\n  F2: 150.0 units shipped (100.0% of capacity)\n  F3: 200.0 units shipped (100.0% of capacity)\n  F4: 180.0 units shipped (100.0% of capacity)\n  F5: 250.0 units shipped (100.0% of capacity)\n\nDISTRIBUTION CENTER THROUGHPUT:\n  DC1: 240.0 units processed\n  DC2: 240.0 units processed\n  DC3: 460.0 units processed\n\nWAREHOUSE DEMAND FULFILLMENT:\n  W1: 80.0 units received (100.0% of demand)\n  W2: 110.0 units received (100.0% of demand)\n  W3: 90.0 units received (100.0% of demand)\n  W4: 130.0 units received (100.0% of demand)\n  W5: 150.0 units received (100.0% of demand)\n  W6: 100.0 units received (100.0% of demand)\n  W7: 120.0 units received (100.0% of demand)\n  W8: 120.0 units received (100.0% of demand)\n\nDETAILED FLOW REPORT (non-zero flows only):\n\n  Factory → Warehouse (Direct):\n    F2 → W2: 20.0 units (cost: $8/unit, total: $160.0)\n\n  Factory → Distribution Center:\n    F1 → DC1: 100.0 units (cost: $3/unit, total: $300.0) (at capacity)\n    F1 → DC2: 20.0 units (cost: $4/unit, total: $80.0)\n    F2 → DC1: 30.0 units (cost: $4/unit, total: $120.0)\n    F2 → DC2: 100.0 units (cost: $3/unit, total: $300.0) (at capacity)\n    F3 → DC2: 50.0 units (cost: $3/unit, total: $150.0)\n    F3 → DC3: 150.0 units (cost: $2/unit, total: $300.0) (at capacity)\n    F4 → DC2: 70.0 units (cost: $4/unit, total: $280.0)\n    F4 → DC3: 110.0 units (cost: $3/unit, total: $330.0) (at capacity)\n    F5 → DC1: 50.0 units (cost: $5/unit, total: $250.0)\n    F5 → DC3: 200.0 units (cost: $2/unit, total: $400.0) (at capacity)\n\n  Distribution Center → Warehouse:\n    DC1 → W1: 80.0 units (cost: $3/unit, total: $240.0)\n    DC1 → W2: 90.0 units (cost: $4/unit, total: $360.0) (at capacity)\n    DC1 → W3: 70.0 units (cost: $2/unit, total: $140.0)\n    DC2 → W3: 20.0 units (cost: $3/unit, total: $60.0)\n    DC2 → W4: 130.0 units (cost: $2/unit, total: $260.0)\n    DC2 → W5: 20.0 units (cost: $4/unit, total: $80.0)\n    DC2 → W6: 70.0 units (cost: $3/unit, total: $210.0)\n    DC3 → W5: 130.0 units (cost: $2/unit, total: $260.0) (at capacity)\n    DC3 → W6: 30.0 units (cost: $4/unit, total: $120.0)\n    DC3 → W7: 120.0 units (cost: $3/unit, total: $360.0)\n    DC3 → W8: 120.0 units (cost: $2/unit, total: $240.0) (at capacity)\n\n  Distribution Center → Distribution Center:\n    DC3 → DC1: 60.0 units (cost: $2/unit, total: $120.0) (at capacity)\n\nSolution details exported to 'solution.csv'\n```\n:::\n:::\n\n\n## Example 2: Oil Transport Problem\n\nLet's look at another example. The Conch Oil Company needs to transport 30 million barrels of crude oil from Doha, Qatar to three European refineries:\n\n- Rotterdam, Netherlands (6 million barrels)\n- Toulon, France (15 million barrels)\n- Palermo, Italy (9 million barrels)\n\nThere are three possible routes:\n\n1. Direct shipping around Africa (most expensive)\n2. Through the Suez Canal to Port Said, then to destinations\n3. From Suez to Damietta via pipeline (limited to 15 million barrels), then to destinations\n\n\n\n\n```{mermaid}\nflowchart LR\n    Doha(Doha<br/>30M barrels)\n    Suez(Suez)\n    PortSaid(Port Said)\n    Damietta(Damietta)\n    Rotterdam(Rotterdam<br/>-6M barrels)\n    Toulon(Toulon<br/>-15M barrels)\n    Palermo(Palermo<br/>-9M barrels)\n    \n    Doha -->|$1.20/barrel| Rotterdam\n    Doha -->|$1.40/barrel| Toulon\n    Doha -->|$1.35/barrel| Palermo\n    Doha -->|$0.35/barrel| Suez\n    Suez -->|$0.20/barrel| PortSaid\n    Suez -->|$0.16/barrel<br/>Max 15M barrels| Damietta\n    PortSaid -->|$0.27/barrel| Rotterdam\n    PortSaid -->|$0.28/barrel| Toulon\n    PortSaid -->|$0.19/barrel| Palermo\n    Damietta -->|$0.25/barrel| Rotterdam\n    Damietta -->|$0.20/barrel| Toulon\n    Damietta -->|$0.15/barrel| Palermo\n    \n    style Doha fill:#d4f1c5\n    style Rotterdam fill:#c5daf1\n    style Toulon fill:#c5daf1\n    style Palermo fill:#c5daf1\n    style Suez fill:#f1e9c5\n    style PortSaid fill:#f1e9c5\n    style Damietta fill:#f1e9c5\n```\n\n\n\n\n### Optimal Solution to Oil Transport Problem\n\nThe optimal solution ships all 30 million barrels from Doha to Suez. From there:\n\n- 15 million barrels go through the pipeline to Damietta (at capacity)\n- 15 million barrels go to Port Said\n\nThe oil is then distributed to the refineries using the cheapest routes.\n\n## Understanding Flow Conservation Constraints\n\nThe most important constraint in network flow models is the flow conservation constraint. This ensures that for each node:\n\n- **Supply nodes**: outflow - inflow = supply amount\n- **Demand nodes**: outflow - inflow = -demand amount\n- **Transshipment nodes**: outflow - inflow = 0\n\nFor example, at the distribution center (DC) in our first example:\n\n- Inflow: 50 units from F1 + 40 units from F2 = 90 units\n- Outflow: 30 units to W1 + 60 units to W2 = 90 units\n- Net flow: 90 - 90 = 0 (as required for a transshipment node)\n\n## Scenario Analysis\n\nLet's examine how the optimal solution changes when we modify the network:\n\n### Scenario 1: Route Closure\n\nIf we close the route from F1 to DC (by setting its capacity to 0), the model must find alternative routes. This might involve:\n\n- Shipping more from F1 to W1 directly\n- Using more of the dummy supply\n- Potentially increasing total cost\n\n### Scenario 2: Demand Change\n\nIf demand at W1 increases or decreases, the optimal flow pattern will change:\n\n- More units might flow through the DC\n- Direct shipments might become more or less economical\n- The model will automatically find the new cost-minimizing solution\n\n## Key Takeaways\n\n1. **Network Structure**: Identify supply, demand, and transshipment nodes, as well as all potential shipping routes.\n\n2. **Supply-Demand Balance**: Check if total supply equals total demand. If not, add dummy nodes as needed.\n\n3. **Flow Conservation**: Ensure that flow is conserved at each node (what comes in must equal what goes out, except at supply/demand nodes).\n\n4. **Capacity Constraints**: Some routes may have limits on how much can flow through them, which can significantly affect the optimal solution.\n\n5. **Excel vs. Python**:\n   - Excel is good for smaller problems and quick changes\n   - Python/Gurobi is better for larger problems and automated scenario analysis\n\n6. **Scenario Analysis**: By modifying parameters (costs, capacities, demands), you can analyze how the network would respond to different conditions.\n\n## Practice Exercises\n\n1. **Basic Network Flow Problem**: Consider a simple network with two supply nodes (50 and 70 units), two demand nodes (-40 and -80 units), and arcs connecting each supply node to each demand node with different costs. Solve this manually.\n\n2. **Adding Transshipment Nodes**: Extend the previous problem by adding one transshipment node that can be used as an intermediate point.\n\n3. **Capacity Constraints**: Modify the problem further by adding capacity constraints to some arcs and observe how the solution changes.\n\n## References and Resources\n\n1. Hillier & Lieberman, \"Introduction to Operations Research,\" Chapter 9\n2. The [Gurobi Modeling Examples](https://gurobi.github.io/modeling-examples/) repository\n\n",
    "supporting": [
      "06-minimum-cost-network-flow-modeling_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}