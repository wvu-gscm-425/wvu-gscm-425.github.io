{
  "hash": "85c17f3874f3c816432b43bfcbb0a904",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"05 | Introduction to Optimization with Gurobi (gurobipy)\"\nsubtitle: \"Linear Programming: Formulation and Solution Methods\"\nformat: \n  html:\n    other-links:\n      - text: \"Wyndor Excel - Solved\"\n        href: \"resources/wyndor-solved.xlsx\"\n        icon: file-earmark-spreadsheet\n      - text: \"Apex Television Excel - Solved\"\n        href: \"resources/apex_television-solved.xlsx\"\n        icon: file-earmark-spreadsheet\norder: 5\n---\n\n\n\n\n## Overview\n\nLinear Programming (LP) is a fundamental optimization technique that helps decision-makers allocate limited resources optimally. In this module, we'll explore how to formulate linear programming models, identify their components, and solve them using both Excel Solver and Python with Gurobi.\n\nAfter completing this module, you will be able to:\n\n1. Identify the three key components of a linear programming model\n2. Formulate linear programming models from problem descriptions\n3. Determine whether a function is linear or nonlinear\n4. Solve linear programming problems using graphical methods\n5. Implement and solve LP models using Excel Solver\n6. Implement and solve LP models using Python with Gurobi\n7. Interpret the results of your optimization models\n\n## Introduction to Linear Programming\n\nLinear Programming (LP) is a powerful optimization technique used to find the best outcome in mathematical models with linear relationships. LP has wide applications in business and supply chain management, including:\n\n- Production planning and scheduling\n- Resource allocation\n- Transportation and distribution problems\n- Financial portfolio optimization\n- Network flow problems\n\n### What Makes a Problem Suitable for Linear Programming?\n\nA problem can be solved using linear programming if:\n\n1. The objective (what you're trying to maximize or minimize) can be expressed as a linear function\n2. All constraints can be expressed as linear inequalities or equations\n3. All variables can take non-negative values (in standard form)\n\n### Components of a Linear Programming Model\n\nEvery LP model consists of three essential components:\n\n1. **Decision Variables**: What you're trying to decide (usually denoted as $X_1$, $X_2$, etc.)\n2. **Objective Function**: The goal you're trying to maximize or minimize ($profit$, $cost$, etc.)\n3. **Constraints**: Limitations on resources or requirements that must be satisfied\n\n### Linear vs. Nonlinear Functions\n\nA **linear function** has the form:\n\n$$y = a_1x_1 + a_2x_2 + ... + a_nx_n + b$$\n\nWhere:\n\n- $x_1, x_2, ..., x_n$ are variables\n- $a_1, a_2, ..., a_n, b$ are constants\n\nIn a linear function:\n\n- Variables appear only to the first power (no squares, cubes, etc.)\n- Variables don't multiply or divide each other\n- There are no transcendental functions (log, sin, etc.) of variables\n\nExamples of linear functions:\n\n- $y = 2.5x + 5$\n- $y = -x + 5$\n- $y = 5$ (constant function)\n- $x = 5$ (can be rewritten as $1x = 5$)\n\nExamples of nonlinear functions:\n\n- $y = 2x^2$ (variables raised to powers other than 1)\n- $y = 3x/(2x+1)$ (variables dividing each other)\n- $y = 3x*(2x+1)$ (variables multiplying each other)\n\n## The Wyndor Glass Co. Problem\n\nLet's examine a classic LP problem that we'll use throughout this module. The Wyndor Glass Company produces high-quality glass products in three plants and is considering launching two new products:\n\n1. Aluminum-framed glass doors (Product 1)\n2. Wood-framed windows (Product 2)\n\nEach plant has a limited number of production hours available per week:\n\n- Plant 1: 4 hours available for Product 1 only\n- Plant 2: 12 hours available for Product 2 only\n- Plant 3: 18 hours available for both products\n\nThe company earns:\n\n- $3,000 profit per batch of Product 1\n- $5,000 profit per batch of Product 2\n\nThe problem: How many batches of each product should Wyndor produce weekly to maximize profit?\n\n### Formulating the Wyndor Glass LP Model\n\n1. **Decision Variables**:\n    - $X_1$ = Number of batches of Product 1 (aluminum-framed doors)\n    - $X_2$ = Number of batches of Product 2 (wood-framed windows)\n2. **Objective Function**:\n    - Maximize $Z = 3X_1 + 5X_2$ (profit in thousands of dollars)\n3. **Constraints**:\n    - Plant 1: $1X_1 + 0X_2 \\leq 4$ (hours available in Plant 1)\n    - Plant 2: $0X_1 + 2X_2 \\leq 12$ (hours available in Plant 2)\n    - Plant 3: $3X_1 + 2X_2 \\leq 18$ (hours available in Plant 3)\n    - Non-negativity: $X_1, X_2 \\geq 0$ (can't produce negative amounts)\n\nThis complete mathematical model represents our optimization problem.\n\n## Solving LP Models Graphically\n\nFor LP problems with two decision variables, we can solve them graphically by:\n\n1. Plotting each constraint on a graph\n2. Identifying the feasible region (the area that satisfies all constraints)\n3. Finding the optimal solution at one of the corner points of the feasible region\n\n### Steps to Solve the Wyndor Glass Problem Graphically:\n\n1. **Plot the constraints**:\n    - Plant 1: $X_1 \\leq 4$ (vertical line at $X_1 = 4$)\n    - Plant 2: $X_2 \\leq 6$ (horizontal line at $X_2 = 6$)\n    - Plant 3: $3X_1 + 2X_2 \\leq 18$ (line connecting points $(6,0)$ and $(0,9)$)\n    - Non-negativity: $X_1 \\geq 0$ and $X_2 \\geq 0$ (the positive quadrant)\n2. **Identify the feasible region**:\n    - The region bounded by these lines forms a polygon. Any point inside this polygon represents a feasible solution.\n3. **Find the optimal solution**:\n    - The optimal solution will be at one of the corner points of the feasible region\n    - For a maximization problem, we want the corner point that gives the highest value of the objective function\n\nLet's calculate the objective function value at each corner point:\n\n| Corner Point | $X_1$ | $X_2$ | $Z = 3X_1 + 5X_2$ |\n|--------------|-------|-------|-------------------|\n| (0,0)        | 0     | 0     | 0                 |\n| (4,0)        | 4     | 0     | 12                |\n| (0,6)        | 0     | 6     | 30                |\n| (2,6)        | 2     | 6     | 36                |\n\nThe optimal solution is $X_1 = 2$, $X_2 = 6$, which gives a maximum profit of $36,000.\n\n### Using Level Curves to Find the Optimal Solution\n\nAnother approach is to use **level curves** of the objective function:\n\n1. Draw the level curve $Z = 3X_1 + 5X_2 = C$ for some value of $C$\n2. Increase $C$ until the level curve is about to leave the feasible region\n3. The last point of contact is the optimal solution\n\nThis graphical method helps visualize how the optimal solution is found, though it becomes impractical for problems with more than two variables.\n\n### Visualization of the Wyndor Glass Problem\n\nLet's visualize the solution to better understand the constraints and optimal point:\n\n::: {#a9129587 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create a new figure with a specific size for better visibility\nplt.figure(figsize=(7, 6))\n\n# Define the range for x and y axes\nx_range = np.linspace(0, 6, 100)\ny_range = np.linspace(0, 9, 100)\n\n# Create a meshgrid for contour plotting\nX, Y = np.meshgrid(x_range, y_range)\nZ = 3 * X + 5 * Y  # Objective function: 3x₁ + 5x₂\n\n# Plot the constraints\n# Constraint 1: x₁ ≤ 4 (Plant 1)\nplt.axvline(x=4, color='red', linestyle='-', linewidth=2, label='Plant 1: x₁ ≤ 4')\n\n# Constraint 2: x₂ ≤ 6 (Plant 2)\nplt.axhline(y=6, color='green', linestyle='-', linewidth=2, label='Plant 2: x₂ ≤ 6')\n\n# Constraint 3: 3x₁ + 2x₂ ≤ 18 (Plant 3)\n# Convert to y = mx + b form: y ≤ (18 - 3x₁)/2 = 9 - 1.5x₁\nconstraint3_y = lambda x: (18 - 3 * x) / 2\nplt.plot(x_range, [constraint3_y(x) for x in x_range], 'blue', \n            linestyle='-', linewidth=2, label='Plant 3: 3x₁ + 2x₂ ≤ 18')\n\n# Non-negativity constraints\nplt.axhline(y=0, color='black', linestyle='-', linewidth=1.5)\nplt.axvline(x=0, color='black', linestyle='-', linewidth=1.5)\n\n# Define the vertices of the feasible region\nfeasible_region_x = [0, 0, 2, 4, 4]\nfeasible_region_y = [0, 6, 6, 3, 0]\n\n# Shade the feasible region\nplt.fill(feasible_region_x, feasible_region_y, color='gray', alpha=0.2, label='Feasible Region')\n\n# Create contours for the objective function\ncontour_levels = np.arange(0, 45, 6)  # Levels at 0, 6, 12, 18, 24, 30, 36, 42\ncontour = plt.contour(X, Y, Z, levels=contour_levels, colors='purple', alpha=0.6)\nplt.clabel(contour, inline=True, fontsize=10, fmt='Z = %1.0f')\n\n# Mark the corner points of the feasible region and evaluate the objective function at each\ncorner_points = [(0, 0), (0, 6), (2, 6), (4, 3), (4, 0)]\ncorner_values = [3*x + 5*y for x, y in corner_points]\n\nfor i, point in enumerate(corner_points):\n    x, y = point\n    value = corner_values[i]\n    plt.plot(x, y, 'ko', markersize=8)  # Black dots for corner points\n    \n    # Add labels for each corner point with its coordinates and objective value\n    if point != (2, 6):  # Skip the optimal point as we'll label it differently\n        plt.annotate(f'({x}, {y}): Z = {value}', \n                    xy=point, xytext=(x+0.2, y+0.2),\n                    fontsize=10, arrowprops=dict(arrowstyle='->'))\n\n# Highlight the optimal solution\nplt.plot(2, 6, 'ro', markersize=12)  # Red dot for optimal solution\nplt.annotate(f'Optimal Solution (2, 6): Z = 36', \n                xy=(2, 6), xytext=(2.5, 7),\n                fontsize=12, fontweight='bold', color='red',\n                arrowprops=dict(facecolor='red', shrink=0.05))\n\n# Add axis labels and a title\nplt.xlabel('x₁ (Product 1: Doors)', fontsize=12)\nplt.ylabel('x₂ (Product 2: Windows)', fontsize=12)\nplt.title('Wyndor Glass Company Linear Programming Problem', fontsize=14, fontweight='bold')\n\n# Set the axis limits with some margin\nplt.xlim(-0.5, 6)\nplt.ylim(-0.5, 9)\n\n# Add a grid for better readability\nplt.grid(True, linestyle='--', alpha=0.6)\n\n# Add a legend\nplt.legend(loc='upper right', fontsize=10)\n\n# Add a text box explaining the problem\ntextbox_text = (\n    \"Wyndor Glass Company Problem:\\n\"\n    \"Maximize Z = 3x₁ + 5x₂\\n\"\n    \"Subject to:\\n\"\n    \"  x₁ ≤ 4 (Plant 1)\\n\"\n    \"  x₂ ≤ 6 (Plant 2)\\n\"\n    \"  3x₁ + 2x₂ ≤ 18 (Plant 3)\\n\"\n    \"  x₁, x₂ ≥ 0\"\n)\nplt.figtext(0.15, 0.02, textbox_text, fontsize=10, \n            bbox=dict(facecolor='white', alpha=0.7, boxstyle='round,pad=0.5'))\n\n# Make the layout tight\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](05-intro-to-gurobipy_files/figure-html/cell-2-output-1.png){width=663 height=572}\n:::\n:::\n\n\n## Special Cases in Linear Programming\n\nLinear programming problems can sometimes have special cases:\n\n### Infeasible Solution\n\nIf the constraints are contradictory, there's no feasible region, and the problem has no solution.\n\nExample: If we added a constraint $X_1 + X_2 ≥ 20$ to the Wyndor problem, it would conflict with our other constraints, making the problem infeasible.\n\n### Multiple Optimal Solutions\n\nIf the objective function is parallel to one of the constraint boundaries, there could be infinitely many optimal solutions along that boundary.\n\nExample: If the Wyndor objective function were $Z = 3X_1 + 2X_2$ (instead of $3X_1 + 5X_2$), there might be multiple optimal solutions.\n\n### Unbounded Solution\n\nIf the feasible region extends infinitely in the direction of improvement for the objective function, the problem is unbounded.\n\nExample: If we removed the Plant 3 constraint from the Wyndor problem, the profit could increase without limit by producing more of Product 2.\n\n## Solving LP with Excel Solver\n\nWhile graphical methods are educational, real-world problems typically have many variables and constraints. We need computational tools like Excel Solver.\n\n### Setting Up the Wyndor Glass Problem in Excel\n\n1. Create a spreadsheet with cells for:\n   - Decision variables ($X_1$ and $X_2$)\n   - Objective function calculation\n   - Left-hand side of each constraint\n   - Right-hand side of each constraint\n2. Set up the Excel Solver:\n   - Go to Data tab → Solver\n   - Set Objective: Cell containing the objective function value\n   - By Changing Variable Cells: Cells containing $X_1$ and $X_2$\n   - Subject to the Constraints: Add each constraint\n   - Select \"Simplex LP\" as the solving method\n3. Click Solve and review the solution\n\nExcel Solver will find:\n\n- $X_1 = 2$, $X_2 = 6$\n- Maximum profit = $36,000\n\n### Sensitivity Analysis in Excel Solver\n\nExcel Solver also provides sensitivity analysis, showing how changes in parameters affect the optimal solution:\n\n1. After solving, click on \"Sensitivity Report\"\n2. This shows:\n   - Shadow prices (dual values) for constraints\n   - Allowable increases/decreases for coefficients\n\nFor example, we can answer questions like:\n\n- What if the profit of Product 2 decreases to $3,000?\n- What if Plant 3 capacity increases by 2 hours?\n\n## Solving LP with Python and Gurobi\n\nFor more complex problems or when integrating optimization into larger systems, Python with the Gurobi solver provides a powerful alternative.\n\n### Setting Up the Wyndor Glass Problem in Python\n\nHere's how to formulate and solve the Wyndor Glass problem using Gurobi in Python:\n\n::: {#04d23639 .cell execution_count=2}\n``` {.python .cell-code}\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"wyndor\")\n\n# Create variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Product 1\nx2 = model.addVar(lb=0, name=\"x2\")  # Product 2\n\n# Set objective: Maximize 3x1 + 5x2\nmodel.setObjective(3 * x1 + 5 * x2, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(1 * x1 + 0 * x2 <= 4, \"Plant1\")\nmodel.addConstr(0 * x1 + 2 * x2 <= 12, \"Plant2\")\nmodel.addConstr(3 * x1 + 2 * x2 <= 18, \"Plant3\")\n\n# Optimize model\nmodel.optimize()\n\n# Print solution\nif model.status == GRB.OPTIMAL:\n    print(\"Optimal solution found:\")\n    print(f\"X1 = {x1.x:.2f}, X2 = {x2.x:.2f}\")\n    print(f\"Optimal profit = ${model.objVal * 1000:.2f}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGurobi Optimizer version 12.0.1 build v12.0.1rc0 (win64 - Windows 11.0 (26100.2))\n\nCPU model: 13th Gen Intel(R) Core(TM) i9-13900H, instruction set [SSE2|AVX|AVX2]\nThread count: 14 physical cores, 20 logical processors, using up to 20 threads\n\nOptimize a model with 3 rows, 2 columns and 4 nonzeros\nModel fingerprint: 0xc030cf3a\nCoefficient statistics:\n  Matrix range     [1e+00, 3e+00]\n  Objective range  [3e+00, 5e+00]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [4e+00, 2e+01]\nPresolve removed 2 rows and 0 columns\nPresolve time: 0.00s\nPresolved: 1 rows, 2 columns, 2 nonzeros\n\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    4.5000000e+01   1.500000e+00   0.000000e+00      0s\n       1    3.6000000e+01   0.000000e+00   0.000000e+00      0s\n\nSolved in 1 iterations and 0.01 seconds (0.00 work units)\nOptimal objective  3.600000000e+01\nOptimal solution found:\nX1 = 2.00, X2 = 6.00\nOptimal profit = $36000.00\n```\n:::\n:::\n\n\nThis code:\n\n1. Creates a Gurobi model\n2. Adds decision variables with lower bounds of 0\n3. Sets the objective function to maximize profit\n4. Adds the three plant constraints\n5. Solves the model and prints the results\n\nThe solution will match what we found graphically and with Excel Solver: $X_1 = 2$, $X_2 = 6$, with a profit of $36,000.\n\n### Sensitivity Analysis with Gurobi\n\nWe can also perform sensitivity analysis with Gurobi:\n\n::: {#b4e72b7f .cell execution_count=3}\n``` {.python .cell-code}\n# Get shadow prices (dual values)\nfor constr in model.getConstrs():\n    print(f\"{constr.ConstrName}: Shadow Price = {constr.Pi}\")\n\n# Get reduced costs\nfor var in model.getVars():\n    print(f\"{var.VarName}: Reduced Cost = {var.RC}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPlant1: Shadow Price = 0.0\nPlant2: Shadow Price = 1.5\nPlant3: Shadow Price = 1.0\nx1: Reduced Cost = 0.0\nx2: Reduced Cost = 0.0\n```\n:::\n:::\n\n\n## Another Example: Apex Television Company\n\nLet's look at another example: The Apex Television Company needs to decide how many 60-inch and 42-inch TV sets to produce to maximize profit.\n\n- Market limitations: At most 40 of the 60-inch sets and 10 of the 42-inch sets can be sold per month\n- Available work hours: 500 hours per month\n- Production requirements:\n    - 60-inch set: 20 work-hours, $120 profit\n    - 42-inch set: 10 work-hours, $80 profit\n\n### Formulating the Apex Television LP Model\n\n1. **Decision Variables**:\n    - $X_1$ = Number of 60-inch sets produced\n    - $X_2$ = Number of 42-inch sets produced\n\n2. **Objective Function**:\n    - Maximize $Z = 120X_1 + 80X_2$ (profit in dollars)\n\n3. **Constraints**:\n    - Market constraint for 60-inch: $X_1 \\leq 40$\n    - Market constraint for 42-inch: $X_2 \\leq 10$\n    - Work hours: $20X_1 + 10X_2 \\leq 500$\n    - Non-negativity: $X_1, X_2 \\geq 0$\n\n### Solving the Apex Television Problem with Excel\n\nUsing Excel Solver as before, we would find:\n\n- $X_1 = 20$, $X_2 = 10$\n- Maximum profit = $3,200\n\n### Solving the Apex Television Problem with Python and Gurobi\n\n::: {#3ef89abd .cell execution_count=4}\n``` {.python .cell-code}\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"apex\")\n\n# Create variables\nx1 = model.addVar(lb=0, name=\"x1\")  # 60-inch TVs\nx2 = model.addVar(lb=0, name=\"x2\")  # 42-inch TVs\n\n# Set objective: Maximize 120x1 + 80x2\nmodel.setObjective(120 * x1 + 80 * x2, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 <= 40, \"Market60\")\nmodel.addConstr(x2 <= 10, \"Market42\")\nmodel.addConstr(20 * x1 + 10 * x2 <= 500, \"WorkHours\")\n\n# Optimize model\nmodel.optimize()\n\n# Print solution\nif model.status == GRB.OPTIMAL:\n    print(\"Optimal solution found:\")\n    print(f\"X1 = {x1.x:.2f}, X2 = {x2.x:.2f}\")\n    print(f\"Optimal profit = ${model.objVal:.2f}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGurobi Optimizer version 12.0.1 build v12.0.1rc0 (win64 - Windows 11.0 (26100.2))\n\nCPU model: 13th Gen Intel(R) Core(TM) i9-13900H, instruction set [SSE2|AVX|AVX2]\nThread count: 14 physical cores, 20 logical processors, using up to 20 threads\n\nOptimize a model with 3 rows, 2 columns and 4 nonzeros\nModel fingerprint: 0xbc523b33\nCoefficient statistics:\n  Matrix range     [1e+00, 2e+01]\n  Objective range  [8e+01, 1e+02]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [1e+01, 5e+02]\nPresolve removed 3 rows and 2 columns\nPresolve time: 0.00s\nPresolve: All rows and columns removed\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    3.2000000e+03   0.000000e+00   0.000000e+00      0s\n\nSolved in 0 iterations and 0.01 seconds (0.00 work units)\nOptimal objective  3.200000000e+03\nOptimal solution found:\nX1 = 20.00, X2 = 10.00\nOptimal profit = $3200.00\n```\n:::\n:::\n\n\n### Visualization of the Apex Television Problem\n\nLet's visualize the solution to better understand the constraints and optimal point:\n\n::: {#9e14b405 .cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create figure and axes\nfig, ax = plt.subplots(figsize=(7, 6))\n\n# Define the boundaries of the plot\nx1_range = np.linspace(0, 45, 100)\nx2_range = np.linspace(0, 15, 100)\nX1, X2 = np.meshgrid(x1_range, x2_range)\n\n# Plot the constraints\nax.plot(x1_range, np.zeros_like(x1_range), 'k-', lw=2)  # X2 = 0\nax.plot(np.zeros_like(x2_range), x2_range, 'k-', lw=2)  # X1 = 0\nax.plot(np.ones_like(x2_range) * 40, x2_range, 'r-', lw=2, label='X1 ≤ 40')  # X1 = 40\nax.plot(x1_range, np.ones_like(x1_range) * 10, 'g-', lw=2, label='X2 ≤ 10')  # X2 = 10\nax.plot(x1_range, (500 - 20 * x1_range) / 10, 'b-', lw=2, label='20X1 + 10X2 ≤ 500')  # Work hours\n\n# Shade the feasible region\nx1_vertices = [0, 0, 20, 25]\nx2_vertices = [0, 10, 10, 0]\nax.fill(x1_vertices, x2_vertices, alpha=0.2, color='gray')\n\n# Mark the optimal solution\nax.plot(20, 10, 'ro', markersize=10)\nax.annotate('Optimal (20, 10)', xy=(20, 10), xytext=(22, 10.5),\n            arrowprops=dict(facecolor='black', shrink=0.05))\n\n# Add objective function contour\nZ = 120 * X1 + 80 * X2\ncontours = ax.contour(X1, X2, Z, levels=np.linspace(500, 3200, 7), alpha=0.6, colors='purple')\nplt.clabel(contours, inline=True, fontsize=8, fmt='Z = %.0f')\n\n# Set plot limits and labels\nax.set_xlim(0, 45)\nax.set_ylim(0, 15)\nax.set_xlabel('X1 (60-inch TVs)')\nax.set_ylabel('X2 (42-inch TVs)')\nax.set_title('Apex Television LP Problem')\nax.grid(True)\nax.legend()\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](05-intro-to-gurobipy_files/figure-html/cell-6-output-1.png){width=662 height=566}\n:::\n:::\n\n\n## Summary\n\nLinear Programming is a powerful optimization technique with wide applications in supply chain management and operations. These skills provide a foundation for more advanced optimization models that we'll explore in future modules, including network flow models, facility location problems, and integer programming.\n\n## Exercises\n\n### Production Planning\n\nA manufacturing plant produces two types of products: standard and deluxe. Each standard product requires 4 hours of machining time and 2 hours of assembly time. Each deluxe product requires 6 hours of machining time and 3 hours of assembly time. The plant has 240 hours of machining time and 120 hours of assembly time available per week. The profit is $7 per standard product and $10 per deluxe product.\n\nFormulate this as an LP model and solve it using both Excel Solver and Python with Gurobi to determine the optimal production levels.\n\n",
    "supporting": [
      "05-intro-to-gurobipy_files"
    ],
    "filters": [],
    "includes": {}
  }
}