{
  "hash": "58aa21d25e649e0004e19d0817a77f05",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"07 | Facility Location Models\" \nsubtitle: \"Optimizing Facility Placement in Supply Chain Networks\" \nformat: \n  html: \n    other-links: \n      - text: \"Customer Data (20 locations)\" \n        href: \"data/multi_city_data.csv\"\n        icon: file-earmark-spreadsheet\n      - text: \"Exercise Data\" \n        href: \"data/multi_city_data_2.csv\"\n        icon: file-earmark-spreadsheet\norder: 7\n---\n\n\n\n\n## Overview\n\nFacility location problems involve finding the best positions for one or more facilities (e.g. warehouses, plants, service centers) to minimize costs or improve service in a supply chain. These decisions are critical because facility locations impact transportation costs, response times, and customer service levels. In this module, you will learn how to:\n\n1. Formulate single-facility location problems (one new facility) to minimize transportation cost, using Euclidean distance-based objectives.\n2. Extend to multi-facility location problems (multiple new facilities) where customer demand points must be assigned to the nearest facility.\n3. Understand nonlinear distance-based formulations (using Euclidean distance) and how to handle them in optimization (using squared distances for tractability).\n4. Implement and solve location models in Python with Gurobi, using simple data structures (lists/dictionaries) and loops for clarity.\n5. Interpret solutions and discuss trade-offs, including diminishing returns from adding more facilities.\n6. Throughout, we include conceptual questions and hands-on Python exercises to reinforce understanding. By the end, you will be able to model facility location decisions and solve them using optimization techniques.\n\nThroughout, we include conceptual questions and hands-on Python exercises to reinforce understanding. By the end, you will be able to model facility location decisions and solve them using optimization techniques.\n\n## Key Concepts in Facility Location\n\n**Facility location** decisions aim to position facilities such that **transportation costs or distances** are minimized (or service metrics optimized). Key concepts include:\n\n- **Demand points (customers)**: Locations that require service (with given coordinates on a plane and demand volume).\n- **Facility (warehouse/plant) location**: The decision variables, typically the $(x, y)$ coordinates, of the facility to be located.\n- **Distance and cost**: Usually, cost is proportional to distance traveled * demand. We often use Euclidean distance (straight-line distance) between a facility and a customer: $\\text{Distance}_i(x, y) = \\sqrt{(x - x_i)^2 + (y - y_i)^2}$, where $(x_i, y_i)$ are coordinates of customer $i$ and $(x,y)$ is the facility location.\n  - Total transport cost = $\\sum_{i} (\\text{distance}{i}) \\times (\\text{demand}{i}) \\times (\\text{transport cost per unit distance})$.\n- **Nonlinearity:** The objective involving Euclidean distance is **nonlinear** (the distance formula has a square root). This makes the problem a **non-linear programming (NLP)** problem. However, it is a convex problem for a single facility (no local minima besides the global minimum).\n- **Squared distance approximation**: To use solvers like Gurobi (which handle linear and quadratic objectives), we often minimize the **squared distance**; $(x-x_i)^2 + (y-y_i)^2$ instead. Minimizing squared distance will locate the facility similarly to minimizing actual distance (it places more weight on farther distances). The optimal location for squared distance is known as the **weighted center of gravity** of the demand points.\n\n### Single-facility vs Multi-facility\n\n- *Single-facility location*: One facility to serve all demand points. We seek the best single location to minimize total distance costs.\n- *Multi-facility location*: Placing multiple facilities (e.g. multiple warehouses) and assigning each customer to the nearest (or most appropriate) facility. This is more complex because we must decide both **facility locations** and **customer-facility assignments** simultaneously. The problem becomes a location-allocation problem, often requiring heuristic or iterative methods (as it is generally an NP-hard problem when formulated exactly).\n\n### Why is facility location important?\n\nProper placement of facilities can dramatically reduce transportation costs and improve service. For example, a company may reduce delivery distances by building regional warehouses closer to customers rather than serving an entire country from one central location. However, more facilities also mean higher fixed costs (which we **do not** explicitly model here, but in practice there is a trade-off).\n\n### Metrics\n\nWhile this module focuses on minimizing total distance (or cost) to customers (a typical objective, yielding a **1-median** problem on a plane), other metrics could be optimized:\n\n- *Minimize average distance per customer*: similar to total distance if total demand is fixed.\n- *Minimize maximum distance to any customer*: a minimax or covering radius objective (placing facility to minimize the farthest customer distance).\n- *Satisfy distance constraints*: e.g. ensure all customers are within a certain distance (which may require multiple facilities if one cannot cover all within the limit).\n\nWe will primarily use the total (or weighted) distance objective, which is most common in cost minimization.\n\n## Single-Facility Location Model\n\nIn a single-facility problem, we want to find the coordinates $(x, y)$ for a new facility that minimize the sum of distances to all customers weighted by their demand (and any transport cost rate).\n\nMathematically:\n\n- Let $N$ be the set of customer locations.\n- For each customer $i \\in N$:\n  - $(x_i, y_i)$ are known coordinates.\n  - $d_i$ is the demand (or shipment volume) from the facility to $i$ (e.g. annual demand).\n  - $t_i$ is the transport cost per unit distance for customer $i$ (if transport cost differs by route; often $t_i$ is the same for all if using the same transport mode)\n- Decision variables: $x$ and $y$ (continuous) = coordinates of the facility.\n\n**Objective (nonlinear)**: Minimize total transport cost = $\\sum_{i \\in N} d_i \\cdot t_i \\cdot \\sqrt{(x - x_i)^2 + (y - y_i)^2}$. There are no explicit constraints on $(x,y)$ (the facility can be located anywhere on the plane, unless specified otherwise).\n\nThis is a **continuous nonlinear optimization** problem. The objective function is convex in $(x,y)$, so a global optimum can be found via calculus or iterative algorithms. However, standard linear solvers cannot be used directly due to the square root.\n\n**Using Squared Distances**: To solve with a quadratic solver (like Gurobi’s QP capabilities), we often minimize $\\sum_i d_i t_i \\big[(x - x_i)^2 + (y - y_i)^2\\big]$ instead. This removes the square root, making it a quadratic objective. The optimal $(x,y)$ for the squared-distance objective is the weighted center-of-gravity:\n\n$$\nx^* = \\frac{\\sum_i d_i t_i x_i}{\\sum_i d_i t_i}, \\quad\ny^* = \\frac{\\sum_i d_i t_i y_i}{\\sum_i d_i t_i}\n$$\n\n::: {.callout-tip}\nIf transport cost per unit distance $t_i$ is uniform for all customers, it cancels out. Then $x^*, y^*$ are just demand-weighted averages of customer coordinates. This center-of-gravity is often used as a heuristic solution for the actual distance-based problem. For the true distance objective (with sqrt), the optimum tends to be somewhat closer to high-demand or far-away points than the center-of-gravity (since each additional mile hurts the objective linearly, not quadratically). In practice, the difference may be small, and the center-of-gravity provides a good starting point.\n:::\n\n### Example 1: Single Warehouse for Sunshine Tire Company\n\n*Sunshine Tire Company* is considering building a new distribution center to serve three major clients. The clients’ locations (in an XY grid coordinate system) and annual shipment volumes are given below:\n\n- **Toledo** – demand = 15,000 tons/year, coordinates $(1360, 1160)$.\n- **Macomb** – demand = 5,000 tons/year, coordinates $(980, 1070)$.\n- **Allentown** – demand = 11,000 tons/year, coordinates $(1840, 1150)$.\n\nTransport cost per ton-mile varies by client due to different freight contracts:\n\n- **Toledo**: $t = $0.95$ per ton-mile\n- **Macomb**: $t = $1.25$ per ton-mile\n- **Allentown**: $t = $0.85$ per ton-mile\n\n**Problem**: Find the location $(x,y)$ for the new DC that minimizes total annual transportation cost to these three clients.\n\nFirst, let’s formulate the model. Using squared distances for tractability, our objective is:\n\n$$\n\\min \\Big[\n15000(0.95)\\big((x - 1360)^2 + (y - 1160)^2\\big) +\n5000(1.25)\\big((x - 980)^2 + (y - 1070)^2\\big) +\n11000(0.85)\\big((x - 1840)^2 + (y - 1150)^2\\big)\n\\Big]\n$$\n\nWe can solve this using Python and Gurobi (as a quadratic program). We expect the optimal solution to correspond to a weighted average of the coordinates, weighted by $d_i t_i$ for each city.\n\n#### Solving with Python (Gurobi)\n\nWe'll use `gurobipy` to set up the decision variables and quadratic objective.\n\n::: {#6fb51e26 .cell execution_count=1}\n``` {.python .cell-code}\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data for Sunshine Tire example\nclients = {\n    \"Toledo\":    {\"x\": 1360, \"y\": 1160, \"demand\": 15000, \"cost_per_ton_mile\": 0.95},\n    \"Macomb\":    {\"x\": 980,  \"y\": 1070, \"demand\": 5000,  \"cost_per_ton_mile\": 1.25},\n    \"Allentown\": {\"x\": 1840, \"y\": 1150, \"demand\": 11000, \"cost_per_ton_mile\": 0.85}\n}\n\n# Create model\nm = gp.Model(\"SunshineTire_SingleFacility\")\n\n# Decision variables: coordinates (x, y)\nx = m.addVar(name=\"x_coord\", lb=-GRB.INFINITY, ub=GRB.INFINITY)\ny = m.addVar(name=\"y_coord\", lb=-GRB.INFINITY, ub=GRB.INFINITY)\n\n# Build quadratic objective\nquad_expr = gp.QuadExpr()\nfor city, data in clients.items():\n    xi, yi = data[\"x\"], data[\"y\"]\n    w = data[\"demand\"] * data[\"cost_per_ton_mile\"]  # weight for this term\n    quad_expr += w * ((x - xi)**2 + (y - yi)**2) # Add w * [ (x - xi)^2 + (y - yi)^2 ] to objective\n\nm.setObjective(quad_expr, GRB.MINIMIZE)\nm.optimize()\n\n# Output solution\nif m.Status == GRB.OPTIMAL:\n    print(f\"Optimal location: x = {x.X:.3f}, y = {y.X:.3f}\")\n    # Compute total annual transport cost using actual distances:\n    total_cost = 0\n    for city, data in clients.items():\n        dist = ((x.X - data[\"x\"])**2 + (y.X - data[\"y\"])**2)**0.5  # Euclidean distance\n        cost = data[\"demand\"] * data[\"cost_per_ton_mile\"] * dist\n        total_cost += cost\n        print(f\"Distance to {city}: {dist:.1f}, Annual cost: ${cost:,.0f}\")\n    print(f\"Total annual transport cost: ${total_cost:,.0f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSet parameter Username\nSet parameter LicenseID to value 2609229\nGurobi Optimizer version 12.0.1 build v12.0.1rc0 (win64 - Windows 11.0 (26100.2))\n\nCPU model: 13th Gen Intel(R) Core(TM) i9-13900H, instruction set [SSE2|AVX|AVX2]\nThread count: 14 physical cores, 20 logical processors, using up to 20 threads\n\nOptimize a model with 0 rows, 2 columns and 0 nonzeros\nModel fingerprint: 0xb23fb48c\nModel has 2 quadratic objective terms\nCoefficient statistics:\n  Matrix range     [0e+00, 0e+00]\n  Objective range  [7e+07, 9e+07]\n  QObjective range [6e+04, 6e+04]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [0e+00, 0e+00]\nPresolve removed 0 rows and 2 columns\nPresolve time: 0.00s\nPresolve: All rows and columns removed\n\nBarrier solved model in 0 iterations and 0.00 seconds (0.00 work units)\nOptimal objective 2.94430988e+09\nOptimal location: x = 1430.787, y = 1138.023\nDistance to Toledo: 74.1, Annual cost: $1,056,213\nDistance to Macomb: 455.9, Annual cost: $2,849,317\nDistance to Allentown: 409.4, Annual cost: $3,827,777\nTotal annual transport cost: $7,733,307\n```\n:::\n:::\n\n\nRunning this model, Gurobi will find the optimal coordinates that minimize the quadratic objective. We then calculate the total cost at that location to interpret the result.\n\n#### Solution\n\nThe optimal coordinates are approximately **(1430, 1138)**. This point is essentially the weighted center-of-gravity of the three clients, heavily influenced by Toledo and Allentown (the larger shipments) and their relatively lower transport rates. In fact, if we compute the weighted average manually:\n\n- Horizontal (x) coordinate: $\\frac{(15000 \\cdot 0.95 \\cdot 1360) + (5000 \\cdot 1.25 \\cdot 980) + (11000 \\cdot 0.85 \\cdot 1840)}{(15000 \\cdot 0.95) + (5000 \\cdot 1.25) + (11000 \\cdot 0.85)} \\approx 1430$\n- Vertical (y) coordinate: $\\approx 1138$\n\nThis matches the solver result, confirming the center-of-gravity logic for the squared distance formulation.\n\n- **Interpreting the cost**: The total annual cost at this optimal location is about $7.73 million. Note that being closest to Toledo (which had the cheapest per-mile cost) is not as crucial as being centrally located to balance all costs. The chosen point lies somewhat between Toledo and Allentown. Interestingly, the solution coincides roughly with Toledo’s x-coordinate and Allentown’s y-coordinate – but that may be a coincidence of data.\n\n- **Euclidean vs Squared Objective**: If we had minimized actual distance (with the `sqrt`), the optimal point might shift slightly. For example, you could use specialized algorithms (like the Weiszfeld algorithm) to find the true distance-minimizing location (the geometric median). In this case, because Toledo and Allentown dominate, the true optimum might move a bit closer to those cities compared to the center-of-gravity. However, the difference is often minor for many practical cases. The squared-distance solution is a reasonable approximation.\n\n- **Concept Check**: *Why might the optimal location not be exactly at one of the customer cities?* Because that would favor that one customer too much while increasing distance to others. The optimum balances all weighted distances. Only in special cases—like one customer having an overwhelmingly large demand or cost weight—would the best location coincide with that customer’s location.\n\n#### Adding Constraints or Alternative Objectives\n\nIn some scenarios, you might have additional constraints. For example, Sunshine Tire could require that the new DC be within a certain maximum distance of each customer for service reasons. This would impose constraints like $\\sqrt{(x-x_i)^2+(y-y_i)^2} \\leq D_{\\max}$ for each customer $i$. These are nonlinear constraints (defining a feasible region as the intersection of circles of radius $D_{\\max}$ around each customer). If $D_{\\max}$ is too small to cover all points, the problem becomes infeasible unless we add more facilities.\n\nAlternatively, consider if Sunshine Tire wanted to **minimize the maximum distance** to any client (a minimax objective). The solution would try to centrally locate such that the farthest client is as close as possible. This is a different optimization criterion and might yield a different location than the min-sum solution. (Such a problem can be formulated by introducing a variable $R$ to represent the max distance and minimizing $R$ with constraints $\\sqrt{(x-x_i)^2+(y-y_i)^2} \\le R$ for all $i$.)\n\nThese variations highlight how objectives and constraints can change the outcome. In practice, you’d choose the formulation that best fits the company’s service targets.\n\n**Takeaway**: For a single facility, the center-of-gravity method (weighted by demand and cost) gives a quick answer when using squared distance or as a starting point for iterative methods. If using a solver like Gurobi, we can implement the exact formulation with quadratic objective (or even the true distance using second-order cone techniques, albeit that’s more advanced). The optimal location balances the pull of all demand points according to their weight.\n\n## Multi-Facility Location Model\n\nNow suppose Sunshine Tire (or another company) can build **multiple facilities**. Multi-facility location problems involve deciding both *how to place several facilities and which facility serves each customer*.\n\nThis is commonly referred to as a **Location-Allocation problem**: we are effectively clustering customers to the nearest facility and finding optimal facility positions for each cluster.\n\n**Key challenge**: The assignment of customers to facilities and the facility locations influence each other. If we knew the assignments (which customers go to facility A vs facility B, etc.), we could compute the best location for each facility (as a single-facility problem on its cluster). Conversely, if we fix facility locations, customers should be assigned to the nearest (to minimize cost). But we don't know either upfront, it's a chicken-and-egg problem, and solving it exactly in one go is difficult because it becomes a large non-linear, non-convex optimization.\n\nIn fact, an exact formulation of the multi-facility problem would involve binary assignment variables (for which facility serves which customer) and continuous location variables. This becomes a **mixed-integer non-linear program (MINLP)** that is generally hard to solve to optimality for large sets. Instead, we rely on heuristic or iterative methods. One common approach is analogous to the **k-means clustering algorithm** used in data science:\n\n**Iterative Algorithm for Multi-Facility Location** (for a given number of facilities $K$):\n\n1. **Initialization**: Guess initial locations for the $K$ facilities. (For example, choose $K$ customer locations as initial facility sites, or randomly distribute them, or even take the solution of the single-facility problem and perturb it for multiple centers.)\n2. **Assignment step**: Assign each customer to the **nearest** facility (compute distance from each customer to each facility and pick the smallest). This creates $K$ clusters of customers.\n3. **Re-optimization step**: For each cluster, recompute the best facility location for that cluster *independently*. In other words, treat each cluster as a single-facility problem and find the optimal $(x,y)$ for that facility (usually the demand-weighted centroid of that cluster, using the squared-distance approach).\n4. Update the facility locations to these new coordinates.\n5. Repeat steps 2–4 until assignments no longer change (i.e., it converges). This usually yields a locally optimal solution.\n\nThis heuristic is essentially the *K-means algorithm* (with demand weights, sometimes called **weighted K-means** or **K-medians** when minimizing distances). It will converge, although it might converge to a local (not global) optimum depending on the initial start. In practice, running the algorithm with multiple different initial guesses and picking the best solution can help.\n\n### Example 2: Multiple Warehouses for *Excellent Foods Inc.*\n\nConsider *Excellent Foods Inc.*, a company that supplies canned goods. They have 20 customer locations (retailers/wholesalers) across a region. Each customer has a yearly demand (in truckloads) and known coordinates on a grid. The transport cost is approximately $1 per unit per distance (so we can just use distance × demand as the cost). The company wants to determine where to build warehouses to minimize total distribution cost.\n\nInitially, consider just **one warehouse** (this reduces to the single-facility problem we already solved conceptually). Then, evaluate **two**, **three**, up to **ten** warehouses to see how additional facilities reduce cost. Instead of formulating a giant MINLP, we’ll use the iterative location-allocation heuristic.\n\nThe full dataset of 20 customers with their coordinates and demands is provided in the linked spreadsheet:\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\n| Customer    |    Y |    X |   Demand |\n|:------------|-----:|-----:|---------:|\n| Customer 1  | 9.74 | 8.18 |       41 |\n| Customer 2  | 8.14 | 7.46 |       62 |\n| Customer 3  | 9.96 | 3.56 |       72 |\n| Customer 4  | 5.13 | 6.51 |      103 |\n| Customer 5  | 3.72 | 2.1  |        2 |\n| Customer 6  | 7.04 | 0.28 |        3 |\n| Customer 7  | 1.48 | 5.23 |        4 |\n| Customer 8  | 9.72 | 4.09 |       78 |\n| Customer 9  | 5.98 | 7.91 |       87 |\n| Customer 10 | 0.54 | 3.2  |       94 |\n\n:::\n\n::: {.column width=\"10%\"}\n:::\n\n::: {.column width=\"45%\"}\n\n| Customer    |    Y |    X |   Demand |\n|:------------|-----:|-----:|---------:|\n| Customer 11 | 5.39 | 4.22 |      118 |\n| Customer 12 | 1.56 | 2.65 |        1 |\n| Customer 13 | 9.45 | 8.58 |        6 |\n| Customer 14 | 6.74 | 4.91 |        3 |\n| Customer 15 | 2.15 | 6.34 |       81 |\n| Customer 16 | 5.69 | 8.04 |      105 |\n| Customer 17 | 0.8  | 7.51 |      156 |\n| Customer 18 | 6.96 | 2.18 |      105 |\n| Customer 19 | 6.03 | 4.35 |        2 |\n| Customer 20 | 9.48 | 5.77 |        7 |\n\n:::\n\n::::\n\n::: {.callout-note}\nCoordinates are in some consistent unit, say tens of miles; demand is units of product shipped per year. Higher-numbered customers like 17 have large demands, in this case 156, which will influence optimal facility placement.\n:::\n\n#### Assignment and Re-optimization with Python\n\nWe'll solve this step by step for a given set of $K$ (number of warehouses). We will use the following packages to manipulate the data, run the k-means algorithm, and plot our results:\n\n::: {#4e9c26a2 .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport altair as alt\nfrom math import hypot\n```\n:::\n\n\n::: {.callout}\nYou can use the following to add them to your environment: `uv add pandas numpy altair`\n:::\n\n##### Helper Functions\n\nFirst, we are going to create a few custom helper functions (use these in future exercises):\n\n1. Shared utility functions for location-allocation (returned as callables):\n\n::: {#46b9339e .cell execution_count=3}\n``` {.python .cell-code}\ndef prepare_location_model(df):\n    df = df.rename(columns={\"X\": \"x\", \"Y\": \"y\", \"Demand\": \"demand\"}).copy()\n\n    def assign_customers(df, facilities):\n        assignments = []\n        for _, row in df.iterrows():\n            distances = [hypot(row['x'] - fx, row['y'] - fy) for fx, fy in facilities]\n            assignments.append(np.argmin(distances))\n        return np.array(assignments)\n\n    def update_facilities(df, assignments, K):\n        facilities = []\n        for k in range(K):\n            cluster = df[assignments == k]\n            if not cluster.empty:\n                total_demand = cluster['demand'].sum()\n                x_center = (cluster['x'] * cluster['demand']).sum() / total_demand\n                y_center = (cluster['y'] * cluster['demand']).sum() / total_demand\n                facilities.append((x_center, y_center))\n            else:\n                facilities.append((0, 0))\n        return facilities\n\n    def compute_total_cost(df, facilities, assignments):\n        total_cost = 0\n        for i, (fx, fy) in enumerate(facilities):\n            cluster = df[assignments == i]\n            for _, row in cluster.iterrows():\n                dist = hypot(row['x'] - fx, row['y'] - fy)\n                total_cost += row['demand'] * dist\n        return total_cost\n\n    return assign_customers, update_facilities, compute_total_cost\n```\n:::\n\n\n2. Solve the facility location problem for a specific range of K:\n\n::: {#11eec33e .cell execution_count=4}\n``` {.python .cell-code}\ndef solve_multi_facility_problem(df, K_values):\n    assign_customers, update_facilities, compute_total_cost = prepare_location_model(df)\n    df = df.rename(columns={\"X\": \"x\", \"Y\": \"y\", \"Demand\": \"demand\"}).copy()\n\n    results = []\n    for K in K_values:\n        initial = df.sort_values('demand', ascending=False).head(K)\n        facilities = list(zip(initial['x'], initial['y']))\n\n        prev_assignments = None\n        for _ in range(100):\n            assignments = assign_customers(df, facilities)\n            if np.array_equal(assignments, prev_assignments):\n                break\n            prev_assignments = assignments\n            facilities = update_facilities(df, assignments, K)\n\n        cost = compute_total_cost(df, facilities, assignments)\n        results.append({\"K\": K, \"Cost\": cost})\n\n    return pd.DataFrame(results)\n```\n:::\n\n\n3. Plot cost vs. number of warehouses\n\n::: {#9abf1264 .cell execution_count=5}\n``` {.python .cell-code}\ndef plot_elbow_curve(results_df):\n    return alt.Chart(results_df).mark_line(point=True).encode(\n        x=alt.X('K:O', title='Number of Warehouses (K)'),\n        y=alt.Y('Cost', title='Total Distribution Cost'),\n        tooltip=['K', 'Cost']\n    ).properties(\n        title='Elbow Method: Cost vs. Number of Warehouses'\n    )\n```\n:::\n\n\n4. Run the algorithm for a specific K:\n\n::: {#5c6a08f7 .cell execution_count=6}\n``` {.python .cell-code}\ndef run_k_facilities(df, K):\n    assign_customers, update_facilities, _ = prepare_location_model(df)\n    df = df.rename(columns={\"X\": \"x\", \"Y\": \"y\", \"Demand\": \"demand\"}).copy()\n\n    initial = df.sort_values('demand', ascending=False).head(K)\n    facilities = list(zip(initial['x'], initial['y']))\n\n    prev_assignments = None\n    for _ in range(100):\n        assignments = assign_customers(df, facilities)\n        if np.array_equal(assignments, prev_assignments):\n            break\n        prev_assignments = assignments\n        facilities = update_facilities(df, assignments, K)\n\n    df['cluster'] = assignments\n    facilities_df = pd.DataFrame(facilities, columns=['x', 'y'])\n    facilities_df['cluster'] = [str(i) for i in range(K)]\n    return df, facilities_df\n```\n:::\n\n\n5. Plot customer and warehouse locations\n\n::: {#3a51ee0e .cell execution_count=7}\n``` {.python .cell-code}\ndef plot_facilities_and_customers(df_customers, df_facilities):\n    df_customers['type'] = 'Customer'\n    df_customers['size'] = df_customers['demand'] * 5\n    df_customers['label'] = ''\n\n    df_facilities['type'] = 'Warehouse'\n    df_facilities['size'] = 500\n    df_facilities['label'] = ['W' + str(i) for i in range(len(df_facilities))]\n\n    combined = pd.concat([\n        df_customers[['x', 'y', 'cluster', 'type', 'size', 'label']],\n        df_facilities[['x', 'y', 'cluster', 'type', 'size', 'label']]\n    ])\n\n    combined['type'] = combined['type'].astype(str)  # ensure clean shape mapping\n\n    points = (\n        alt.Chart(combined)\n        .mark_point(filled=True)\n        .encode(\n            x='x', y='y',\n            color=alt.Color('cluster:N', title='Cluster'),\n            shape=alt.Shape(\n                'type:N', \n                scale=alt.Scale(\n                    domain=['Customer', 'Warehouse'], \n                    range=['circle', 'triangle']\n                )\n            ),\n            size='size',\n            tooltip=['type', 'x', 'y', 'label']\n        )\n    )\n\n    labels = alt.Chart(df_facilities).mark_text(\n        align='left', dx=8, dy=-8, fontSize=13\n    ).encode(\n        x='x', y='y', text='label'\n    )\n\n    return (points + labels).properties(\n        title='Customer and Warehouse Locations'\n    )\n```\n:::\n\n\n##### Solving Steps\n\n1. Load in the data:\n\n::: {#dec238b2 .cell execution_count=8}\n``` {.python .cell-code}\n# The dataset contains customer coordinates (X, Y) and their demand.\ndf = pd.read_csv('data/multi_city_data.csv')  # Update path as needed\n```\n:::\n\n\n2. Solve the multi-facility problem and look at costs for different number of warehouses.\n\n**Total Cost**: The total cost with multiple facilities is the sum of each customer’s demand * distance to its assigned facility. As we add facilities, customers have shorter distances, so total cost decreases. We can plot or tabulate the cost vs $K$:\n\n::: {#7beab2f2 .cell execution_count=9}\n``` {.python .cell-code}\nresults = solve_multi_facility_problem(df, range(1, 11))\nplot_elbow_curve(results)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n\n<style>\n  #altair-viz-e12319978fba48a2a642f6dd6ef8c5dd.vega-embed {\n    width: 100%;\n    display: flex;\n  }\n\n  #altair-viz-e12319978fba48a2a642f6dd6ef8c5dd.vega-embed details,\n  #altair-viz-e12319978fba48a2a642f6dd6ef8c5dd.vega-embed details summary {\n    position: relative;\n  }\n</style>\n<div id=\"altair-viz-e12319978fba48a2a642f6dd6ef8c5dd\"></div>\n<script type=\"text/javascript\">\n  var VEGA_DEBUG = (typeof VEGA_DEBUG == \"undefined\") ? {} : VEGA_DEBUG;\n  (function(spec, embedOpt){\n    let outputDiv = document.currentScript.previousElementSibling;\n    if (outputDiv.id !== \"altair-viz-e12319978fba48a2a642f6dd6ef8c5dd\") {\n      outputDiv = document.getElementById(\"altair-viz-e12319978fba48a2a642f6dd6ef8c5dd\");\n    }\n\n    const paths = {\n      \"vega\": \"https://cdn.jsdelivr.net/npm/vega@5?noext\",\n      \"vega-lib\": \"https://cdn.jsdelivr.net/npm/vega-lib?noext\",\n      \"vega-lite\": \"https://cdn.jsdelivr.net/npm/vega-lite@5.20.1?noext\",\n      \"vega-embed\": \"https://cdn.jsdelivr.net/npm/vega-embed@6?noext\",\n    };\n\n    function maybeLoadScript(lib, version) {\n      var key = `${lib.replace(\"-\", \"\")}_version`;\n      return (VEGA_DEBUG[key] == version) ?\n        Promise.resolve(paths[lib]) :\n        new Promise(function(resolve, reject) {\n          var s = document.createElement('script');\n          document.getElementsByTagName(\"head\")[0].appendChild(s);\n          s.async = true;\n          s.onload = () => {\n            VEGA_DEBUG[key] = version;\n            return resolve(paths[lib]);\n          };\n          s.onerror = () => reject(`Error loading script: ${paths[lib]}`);\n          s.src = paths[lib];\n        });\n    }\n\n    function showError(err) {\n      outputDiv.innerHTML = `<div class=\"error\" style=\"color:red;\">${err}</div>`;\n      throw err;\n    }\n\n    function displayChart(vegaEmbed) {\n      vegaEmbed(outputDiv, spec, embedOpt)\n        .catch(err => showError(`Javascript Error: ${err.message}<br>This usually means there's a typo in your chart specification. See the javascript console for the full traceback.`));\n    }\n\n    if(typeof define === \"function\" && define.amd) {\n      requirejs.config({paths});\n      let deps = [\"vega-embed\"];\n      require(deps, displayChart, err => showError(`Error loading script: ${err.message}`));\n    } else {\n      maybeLoadScript(\"vega\", \"5\")\n        .then(() => maybeLoadScript(\"vega-lite\", \"5.20.1\"))\n        .then(() => maybeLoadScript(\"vega-embed\", \"6\"))\n        .catch(showError)\n        .then(() => displayChart(vegaEmbed));\n    }\n  })({\"config\": {\"view\": {\"continuousWidth\": 300, \"continuousHeight\": 300}}, \"data\": {\"name\": \"data-d4a0a73816d17b7081b07d742ca3e578\"}, \"mark\": {\"type\": \"line\", \"point\": true}, \"encoding\": {\"tooltip\": [{\"field\": \"K\", \"type\": \"quantitative\"}, {\"field\": \"Cost\", \"type\": \"quantitative\"}], \"x\": {\"field\": \"K\", \"title\": \"Number of Warehouses (K)\", \"type\": \"ordinal\"}, \"y\": {\"field\": \"Cost\", \"title\": \"Total Distribution Cost\", \"type\": \"quantitative\"}}, \"title\": \"Elbow Method: Cost vs. Number of Warehouses\", \"$schema\": \"https://vega.github.io/schema/vega-lite/v5.20.1.json\", \"datasets\": {\"data-d4a0a73816d17b7081b07d742ca3e578\": [{\"K\": 1, \"Cost\": 3907.359383316418}, {\"K\": 2, \"Cost\": 2808.2705949252045}, {\"K\": 3, \"Cost\": 2052.0029910352378}, {\"K\": 4, \"Cost\": 1644.837078936239}, {\"K\": 5, \"Cost\": 1486.7734288320141}, {\"K\": 6, \"Cost\": 1081.2306034343005}, {\"K\": 7, \"Cost\": 780.2422166947916}, {\"K\": 8, \"Cost\": 590.3770418781171}, {\"K\": 9, \"Cost\": 217.4822446854844}, {\"K\": 10, \"Cost\": 182.94480961114346}]}}, {\"mode\": \"vega-lite\"});\n</script>\n```\n:::\n:::\n\n\nFrom these results, we observe **diminishing marginal benefit** for additional facilities. Going from 1 to 2 warehouses yielded a large cost reduction; 2 to 3 also yielded a large reduction; but by 4 to 5, the incremental savings were smaller. This is typical: the first few facilities dramatically cut distance because they eliminate the longest transport lanes, but beyond a point, new facilities only shave off smaller remaining distances.\n\nIf we continued to $K=20$ (a warehouse for every customer), cost would drop to 0 because each customer would be at the same location as a warehouse (in theory). But of course, in reality, building 20 warehouses is impractical – and our model doesn’t include any fixed facility cost to penalize that.\n\n3. Solve for facility locations & create a plot:\n\n::: {#25822c36 .cell execution_count=10}\n``` {.python .cell-code}\ndf_k4, facilities_k4 = run_k_facilities(df, K=4)\n```\n:::\n\n\n::: {#7b6d3144 .cell execution_count=11}\n``` {.python .cell-code}\ndf_k4\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Customer</th>\n      <th>y</th>\n      <th>x</th>\n      <th>demand</th>\n      <th>cluster</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Customer 1</td>\n      <td>9.74</td>\n      <td>8.18</td>\n      <td>41</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Customer 2</td>\n      <td>8.14</td>\n      <td>7.46</td>\n      <td>62</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Customer 3</td>\n      <td>9.96</td>\n      <td>3.56</td>\n      <td>72</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Customer 4</td>\n      <td>5.13</td>\n      <td>6.51</td>\n      <td>103</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Customer 5</td>\n      <td>3.72</td>\n      <td>2.10</td>\n      <td>2</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>Customer 6</td>\n      <td>7.04</td>\n      <td>0.28</td>\n      <td>3</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>Customer 7</td>\n      <td>1.48</td>\n      <td>5.23</td>\n      <td>4</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>Customer 8</td>\n      <td>9.72</td>\n      <td>4.09</td>\n      <td>78</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>Customer 9</td>\n      <td>5.98</td>\n      <td>7.91</td>\n      <td>87</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>Customer 10</td>\n      <td>0.54</td>\n      <td>3.20</td>\n      <td>94</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>Customer 11</td>\n      <td>5.39</td>\n      <td>4.22</td>\n      <td>118</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>Customer 12</td>\n      <td>1.56</td>\n      <td>2.65</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>Customer 13</td>\n      <td>9.45</td>\n      <td>8.58</td>\n      <td>6</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>Customer 14</td>\n      <td>6.74</td>\n      <td>4.91</td>\n      <td>3</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>14</th>\n      <td>Customer 15</td>\n      <td>2.15</td>\n      <td>6.34</td>\n      <td>81</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>15</th>\n      <td>Customer 16</td>\n      <td>5.69</td>\n      <td>8.04</td>\n      <td>105</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>16</th>\n      <td>Customer 17</td>\n      <td>0.80</td>\n      <td>7.51</td>\n      <td>156</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>17</th>\n      <td>Customer 18</td>\n      <td>6.96</td>\n      <td>2.18</td>\n      <td>105</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>18</th>\n      <td>Customer 19</td>\n      <td>6.03</td>\n      <td>4.35</td>\n      <td>2</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>19</th>\n      <td>Customer 20</td>\n      <td>9.48</td>\n      <td>5.77</td>\n      <td>7</td>\n      <td>2</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#8f21802b .cell execution_count=12}\n``` {.python .cell-code}\nfacilities_k4\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>x</th>\n      <th>y</th>\n      <th>cluster</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>5.980565</td>\n      <td>1.063065</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4.204720</td>\n      <td>5.405920</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3.190453</td>\n      <td>8.654943</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>7.555149</td>\n      <td>6.452525</td>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#8a5700bb .cell execution_count=13}\n``` {.python .cell-code}\nplot_facilities_and_customers(df_k4, facilities_k4)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n\n<style>\n  #altair-viz-757616e504664231b8f568de55056797.vega-embed {\n    width: 100%;\n    display: flex;\n  }\n\n  #altair-viz-757616e504664231b8f568de55056797.vega-embed details,\n  #altair-viz-757616e504664231b8f568de55056797.vega-embed details summary {\n    position: relative;\n  }\n</style>\n<div id=\"altair-viz-757616e504664231b8f568de55056797\"></div>\n<script type=\"text/javascript\">\n  var VEGA_DEBUG = (typeof VEGA_DEBUG == \"undefined\") ? {} : VEGA_DEBUG;\n  (function(spec, embedOpt){\n    let outputDiv = document.currentScript.previousElementSibling;\n    if (outputDiv.id !== \"altair-viz-757616e504664231b8f568de55056797\") {\n      outputDiv = document.getElementById(\"altair-viz-757616e504664231b8f568de55056797\");\n    }\n\n    const paths = {\n      \"vega\": \"https://cdn.jsdelivr.net/npm/vega@5?noext\",\n      \"vega-lib\": \"https://cdn.jsdelivr.net/npm/vega-lib?noext\",\n      \"vega-lite\": \"https://cdn.jsdelivr.net/npm/vega-lite@5.20.1?noext\",\n      \"vega-embed\": \"https://cdn.jsdelivr.net/npm/vega-embed@6?noext\",\n    };\n\n    function maybeLoadScript(lib, version) {\n      var key = `${lib.replace(\"-\", \"\")}_version`;\n      return (VEGA_DEBUG[key] == version) ?\n        Promise.resolve(paths[lib]) :\n        new Promise(function(resolve, reject) {\n          var s = document.createElement('script');\n          document.getElementsByTagName(\"head\")[0].appendChild(s);\n          s.async = true;\n          s.onload = () => {\n            VEGA_DEBUG[key] = version;\n            return resolve(paths[lib]);\n          };\n          s.onerror = () => reject(`Error loading script: ${paths[lib]}`);\n          s.src = paths[lib];\n        });\n    }\n\n    function showError(err) {\n      outputDiv.innerHTML = `<div class=\"error\" style=\"color:red;\">${err}</div>`;\n      throw err;\n    }\n\n    function displayChart(vegaEmbed) {\n      vegaEmbed(outputDiv, spec, embedOpt)\n        .catch(err => showError(`Javascript Error: ${err.message}<br>This usually means there's a typo in your chart specification. See the javascript console for the full traceback.`));\n    }\n\n    if(typeof define === \"function\" && define.amd) {\n      requirejs.config({paths});\n      let deps = [\"vega-embed\"];\n      require(deps, displayChart, err => showError(`Error loading script: ${err.message}`));\n    } else {\n      maybeLoadScript(\"vega\", \"5\")\n        .then(() => maybeLoadScript(\"vega-lite\", \"5.20.1\"))\n        .then(() => maybeLoadScript(\"vega-embed\", \"6\"))\n        .catch(showError)\n        .then(() => displayChart(vegaEmbed));\n    }\n  })({\"config\": {\"view\": {\"continuousWidth\": 300, \"continuousHeight\": 300}}, \"layer\": [{\"data\": {\"name\": \"data-9c53f69566674ce95ae3cb4693ea3921\"}, \"mark\": {\"type\": \"point\", \"filled\": true}, \"encoding\": {\"color\": {\"field\": \"cluster\", \"title\": \"Cluster\", \"type\": \"nominal\"}, \"shape\": {\"field\": \"type\", \"scale\": {\"domain\": [\"Customer\", \"Warehouse\"], \"range\": [\"circle\", \"triangle\"]}, \"type\": \"nominal\"}, \"size\": {\"field\": \"size\", \"type\": \"quantitative\"}, \"tooltip\": [{\"field\": \"type\", \"type\": \"nominal\"}, {\"field\": \"x\", \"type\": \"quantitative\"}, {\"field\": \"y\", \"type\": \"quantitative\"}, {\"field\": \"label\", \"type\": \"nominal\"}], \"x\": {\"field\": \"x\", \"type\": \"quantitative\"}, \"y\": {\"field\": \"y\", \"type\": \"quantitative\"}}}, {\"data\": {\"name\": \"data-097ae311b5d8cac676640360e221e8a6\"}, \"mark\": {\"type\": \"text\", \"align\": \"left\", \"dx\": 8, \"dy\": -8, \"fontSize\": 13}, \"encoding\": {\"text\": {\"field\": \"label\", \"type\": \"nominal\"}, \"x\": {\"field\": \"x\", \"type\": \"quantitative\"}, \"y\": {\"field\": \"y\", \"type\": \"quantitative\"}}}], \"title\": \"Customer and Warehouse Locations\", \"$schema\": \"https://vega.github.io/schema/vega-lite/v5.20.1.json\", \"datasets\": {\"data-9c53f69566674ce95ae3cb4693ea3921\": [{\"x\": 8.18, \"y\": 9.74, \"cluster\": 3, \"type\": \"Customer\", \"size\": 205, \"label\": \"\"}, {\"x\": 7.46, \"y\": 8.14, \"cluster\": 3, \"type\": \"Customer\", \"size\": 310, \"label\": \"\"}, {\"x\": 3.56, \"y\": 9.96, \"cluster\": 2, \"type\": \"Customer\", \"size\": 360, \"label\": \"\"}, {\"x\": 6.51, \"y\": 5.13, \"cluster\": 3, \"type\": \"Customer\", \"size\": 515, \"label\": \"\"}, {\"x\": 2.1, \"y\": 3.72, \"cluster\": 1, \"type\": \"Customer\", \"size\": 10, \"label\": \"\"}, {\"x\": 0.28, \"y\": 7.04, \"cluster\": 2, \"type\": \"Customer\", \"size\": 15, \"label\": \"\"}, {\"x\": 5.23, \"y\": 1.48, \"cluster\": 0, \"type\": \"Customer\", \"size\": 20, \"label\": \"\"}, {\"x\": 4.09, \"y\": 9.72, \"cluster\": 2, \"type\": \"Customer\", \"size\": 390, \"label\": \"\"}, {\"x\": 7.91, \"y\": 5.98, \"cluster\": 3, \"type\": \"Customer\", \"size\": 435, \"label\": \"\"}, {\"x\": 3.2, \"y\": 0.54, \"cluster\": 0, \"type\": \"Customer\", \"size\": 470, \"label\": \"\"}, {\"x\": 4.22, \"y\": 5.39, \"cluster\": 1, \"type\": \"Customer\", \"size\": 590, \"label\": \"\"}, {\"x\": 2.65, \"y\": 1.56, \"cluster\": 0, \"type\": \"Customer\", \"size\": 5, \"label\": \"\"}, {\"x\": 8.58, \"y\": 9.45, \"cluster\": 3, \"type\": \"Customer\", \"size\": 30, \"label\": \"\"}, {\"x\": 4.91, \"y\": 6.74, \"cluster\": 1, \"type\": \"Customer\", \"size\": 15, \"label\": \"\"}, {\"x\": 6.34, \"y\": 2.15, \"cluster\": 0, \"type\": \"Customer\", \"size\": 405, \"label\": \"\"}, {\"x\": 8.04, \"y\": 5.69, \"cluster\": 3, \"type\": \"Customer\", \"size\": 525, \"label\": \"\"}, {\"x\": 7.51, \"y\": 0.8, \"cluster\": 0, \"type\": \"Customer\", \"size\": 780, \"label\": \"\"}, {\"x\": 2.18, \"y\": 6.96, \"cluster\": 2, \"type\": \"Customer\", \"size\": 525, \"label\": \"\"}, {\"x\": 4.35, \"y\": 6.03, \"cluster\": 1, \"type\": \"Customer\", \"size\": 10, \"label\": \"\"}, {\"x\": 5.77, \"y\": 9.48, \"cluster\": 2, \"type\": \"Customer\", \"size\": 35, \"label\": \"\"}, {\"x\": 5.980565476190476, \"y\": 1.0630654761904763, \"cluster\": \"0\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W0\"}, {\"x\": 4.20472, \"y\": 5.40592, \"cluster\": \"1\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W1\"}, {\"x\": 3.1904528301886788, \"y\": 8.654943396226415, \"cluster\": \"2\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W2\"}, {\"x\": 7.555148514851484, \"y\": 6.452524752475248, \"cluster\": \"3\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W3\"}], \"data-097ae311b5d8cac676640360e221e8a6\": [{\"x\": 5.980565476190476, \"y\": 1.0630654761904763, \"cluster\": \"0\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W0\"}, {\"x\": 4.20472, \"y\": 5.40592, \"cluster\": \"1\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W1\"}, {\"x\": 3.1904528301886788, \"y\": 8.654943396226415, \"cluster\": \"2\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W2\"}, {\"x\": 7.555148514851484, \"y\": 6.452524752475248, \"cluster\": \"3\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W3\"}]}}, {\"mode\": \"vega-lite\"});\n</script>\n```\n:::\n:::\n\n\nJust for curiosity, we can also look at `k=3` to compare:\n\n::: {#ccc18dae .cell execution_count=14}\n``` {.python .cell-code}\ndf_k3, facilities_k3 = run_k_facilities(df, K=3)\nplot_facilities_and_customers(df_k3, facilities_k3)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n\n<style>\n  #altair-viz-8121307b038f4bc0950ebf3af08abc3e.vega-embed {\n    width: 100%;\n    display: flex;\n  }\n\n  #altair-viz-8121307b038f4bc0950ebf3af08abc3e.vega-embed details,\n  #altair-viz-8121307b038f4bc0950ebf3af08abc3e.vega-embed details summary {\n    position: relative;\n  }\n</style>\n<div id=\"altair-viz-8121307b038f4bc0950ebf3af08abc3e\"></div>\n<script type=\"text/javascript\">\n  var VEGA_DEBUG = (typeof VEGA_DEBUG == \"undefined\") ? {} : VEGA_DEBUG;\n  (function(spec, embedOpt){\n    let outputDiv = document.currentScript.previousElementSibling;\n    if (outputDiv.id !== \"altair-viz-8121307b038f4bc0950ebf3af08abc3e\") {\n      outputDiv = document.getElementById(\"altair-viz-8121307b038f4bc0950ebf3af08abc3e\");\n    }\n\n    const paths = {\n      \"vega\": \"https://cdn.jsdelivr.net/npm/vega@5?noext\",\n      \"vega-lib\": \"https://cdn.jsdelivr.net/npm/vega-lib?noext\",\n      \"vega-lite\": \"https://cdn.jsdelivr.net/npm/vega-lite@5.20.1?noext\",\n      \"vega-embed\": \"https://cdn.jsdelivr.net/npm/vega-embed@6?noext\",\n    };\n\n    function maybeLoadScript(lib, version) {\n      var key = `${lib.replace(\"-\", \"\")}_version`;\n      return (VEGA_DEBUG[key] == version) ?\n        Promise.resolve(paths[lib]) :\n        new Promise(function(resolve, reject) {\n          var s = document.createElement('script');\n          document.getElementsByTagName(\"head\")[0].appendChild(s);\n          s.async = true;\n          s.onload = () => {\n            VEGA_DEBUG[key] = version;\n            return resolve(paths[lib]);\n          };\n          s.onerror = () => reject(`Error loading script: ${paths[lib]}`);\n          s.src = paths[lib];\n        });\n    }\n\n    function showError(err) {\n      outputDiv.innerHTML = `<div class=\"error\" style=\"color:red;\">${err}</div>`;\n      throw err;\n    }\n\n    function displayChart(vegaEmbed) {\n      vegaEmbed(outputDiv, spec, embedOpt)\n        .catch(err => showError(`Javascript Error: ${err.message}<br>This usually means there's a typo in your chart specification. See the javascript console for the full traceback.`));\n    }\n\n    if(typeof define === \"function\" && define.amd) {\n      requirejs.config({paths});\n      let deps = [\"vega-embed\"];\n      require(deps, displayChart, err => showError(`Error loading script: ${err.message}`));\n    } else {\n      maybeLoadScript(\"vega\", \"5\")\n        .then(() => maybeLoadScript(\"vega-lite\", \"5.20.1\"))\n        .then(() => maybeLoadScript(\"vega-embed\", \"6\"))\n        .catch(showError)\n        .then(() => displayChart(vegaEmbed));\n    }\n  })({\"config\": {\"view\": {\"continuousWidth\": 300, \"continuousHeight\": 300}}, \"layer\": [{\"data\": {\"name\": \"data-b5ec07eeb85a3a60f3aa92e64b02be0a\"}, \"mark\": {\"type\": \"point\", \"filled\": true}, \"encoding\": {\"color\": {\"field\": \"cluster\", \"title\": \"Cluster\", \"type\": \"nominal\"}, \"shape\": {\"field\": \"type\", \"scale\": {\"domain\": [\"Customer\", \"Warehouse\"], \"range\": [\"circle\", \"triangle\"]}, \"type\": \"nominal\"}, \"size\": {\"field\": \"size\", \"type\": \"quantitative\"}, \"tooltip\": [{\"field\": \"type\", \"type\": \"nominal\"}, {\"field\": \"x\", \"type\": \"quantitative\"}, {\"field\": \"y\", \"type\": \"quantitative\"}, {\"field\": \"label\", \"type\": \"nominal\"}], \"x\": {\"field\": \"x\", \"type\": \"quantitative\"}, \"y\": {\"field\": \"y\", \"type\": \"quantitative\"}}}, {\"data\": {\"name\": \"data-0ac26df43d938cd74c513a2f0c94a586\"}, \"mark\": {\"type\": \"text\", \"align\": \"left\", \"dx\": 8, \"dy\": -8, \"fontSize\": 13}, \"encoding\": {\"text\": {\"field\": \"label\", \"type\": \"nominal\"}, \"x\": {\"field\": \"x\", \"type\": \"quantitative\"}, \"y\": {\"field\": \"y\", \"type\": \"quantitative\"}}}], \"title\": \"Customer and Warehouse Locations\", \"$schema\": \"https://vega.github.io/schema/vega-lite/v5.20.1.json\", \"datasets\": {\"data-b5ec07eeb85a3a60f3aa92e64b02be0a\": [{\"x\": 8.18, \"y\": 9.74, \"cluster\": 1, \"type\": \"Customer\", \"size\": 205, \"label\": \"\"}, {\"x\": 7.46, \"y\": 8.14, \"cluster\": 1, \"type\": \"Customer\", \"size\": 310, \"label\": \"\"}, {\"x\": 3.56, \"y\": 9.96, \"cluster\": 2, \"type\": \"Customer\", \"size\": 360, \"label\": \"\"}, {\"x\": 6.51, \"y\": 5.13, \"cluster\": 1, \"type\": \"Customer\", \"size\": 515, \"label\": \"\"}, {\"x\": 2.1, \"y\": 3.72, \"cluster\": 0, \"type\": \"Customer\", \"size\": 10, \"label\": \"\"}, {\"x\": 0.28, \"y\": 7.04, \"cluster\": 2, \"type\": \"Customer\", \"size\": 15, \"label\": \"\"}, {\"x\": 5.23, \"y\": 1.48, \"cluster\": 0, \"type\": \"Customer\", \"size\": 20, \"label\": \"\"}, {\"x\": 4.09, \"y\": 9.72, \"cluster\": 2, \"type\": \"Customer\", \"size\": 390, \"label\": \"\"}, {\"x\": 7.91, \"y\": 5.98, \"cluster\": 1, \"type\": \"Customer\", \"size\": 435, \"label\": \"\"}, {\"x\": 3.2, \"y\": 0.54, \"cluster\": 0, \"type\": \"Customer\", \"size\": 470, \"label\": \"\"}, {\"x\": 4.22, \"y\": 5.39, \"cluster\": 1, \"type\": \"Customer\", \"size\": 590, \"label\": \"\"}, {\"x\": 2.65, \"y\": 1.56, \"cluster\": 0, \"type\": \"Customer\", \"size\": 5, \"label\": \"\"}, {\"x\": 8.58, \"y\": 9.45, \"cluster\": 1, \"type\": \"Customer\", \"size\": 30, \"label\": \"\"}, {\"x\": 4.91, \"y\": 6.74, \"cluster\": 1, \"type\": \"Customer\", \"size\": 15, \"label\": \"\"}, {\"x\": 6.34, \"y\": 2.15, \"cluster\": 0, \"type\": \"Customer\", \"size\": 405, \"label\": \"\"}, {\"x\": 8.04, \"y\": 5.69, \"cluster\": 1, \"type\": \"Customer\", \"size\": 525, \"label\": \"\"}, {\"x\": 7.51, \"y\": 0.8, \"cluster\": 0, \"type\": \"Customer\", \"size\": 780, \"label\": \"\"}, {\"x\": 2.18, \"y\": 6.96, \"cluster\": 2, \"type\": \"Customer\", \"size\": 525, \"label\": \"\"}, {\"x\": 4.35, \"y\": 6.03, \"cluster\": 1, \"type\": \"Customer\", \"size\": 10, \"label\": \"\"}, {\"x\": 5.77, \"y\": 9.48, \"cluster\": 2, \"type\": \"Customer\", \"size\": 35, \"label\": \"\"}, {\"x\": 5.9576035502958575, \"y\": 1.0787869822485208, \"cluster\": \"0\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W0\"}, {\"x\": 6.781157495256166, \"y\": 6.214648956356737, \"cluster\": \"1\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W1\"}, {\"x\": 3.1904528301886788, \"y\": 8.654943396226415, \"cluster\": \"2\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W2\"}], \"data-0ac26df43d938cd74c513a2f0c94a586\": [{\"x\": 5.9576035502958575, \"y\": 1.0787869822485208, \"cluster\": \"0\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W0\"}, {\"x\": 6.781157495256166, \"y\": 6.214648956356737, \"cluster\": \"1\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W1\"}, {\"x\": 3.1904528301886788, \"y\": 8.654943396226415, \"cluster\": \"2\", \"type\": \"Warehouse\", \"size\": 500, \"label\": \"W2\"}]}}, {\"mode\": \"vega-lite\"});\n</script>\n```\n:::\n:::\n\n\n## Summary\n\nIn this module, we explored facility location models for supply chain network design:\n\n- **Single-facility location**: We learned to formulate the problem of finding the optimal single facility location to minimize total weighted distance to customers. By using a squared-distance approximation, we could solve it with Gurobi as a quadratic program. The solution is essentially a weighted average of customer locations (center-of-gravity), which balances the travel cost to all customers. We also discussed how additional constraints (like limiting maximum distance) or different objectives (minimax vs min-sum) could affect the solution.\n- **Multi-facility location**: We tackled the harder problem of placing multiple facilities. We introduced an iterative location-allocation heuristic (analogous to k-means clustering) to assign customers to the nearest facility and recompute facility positions until reaching a good solution. Through an example with 20 customers, we saw that adding more facilities reduces total transport cost but with diminishing returns. This method gave us insight into how customers naturally cluster around local \"centers of gravity\" when multiple warehouses are allowed.\n\n**Practical implications**: Companies often use such models to decide how many warehouses or plants to operate and where to locate them. The models can become more complex if including factors like facility fixed costs, capacities, or discrete candidate locations (those aspects lead to MILP formulations, which we will explore later). However, the fundamental trade-off remains: more facilities mean higher fixed costs but lower transportation costs (and vice versa). The tools learned here allow analyzing the transportation cost side of that trade-off by optimally placing a given number of facilities.\n\n## Exercises\n\n### Center of Gravity Calculation (Single Facility)\n\nConsider three customer locations with coordinates and demands: A at $(0,0)$ with demand 10, B at $(10,0)$ with demand 5, and C at $(5, 5)$ with demand 5:\n\n1. Compute the weighted center of gravity of these points (assuming equal transport cost per unit distance).\n2. If the facility is located at that center of gravity, what is the total distance-weighted cost?\n3. Try shifting the facility a bit in any direction, would the total cost increase or decrease? (This is a conceptual check to confirm it's an optimum.)\n\n::: {.callout-tip}\nFor 1: $x^* = \\frac{100 + 510 + 55}{10+5+5}$, $y^ = \\frac{100 + 50 + 55}{20}$. \nFor 2: calculate $10d(A,facility)+5d(B,facility)+5d(C,facility)$. \nFor 3: consider symmetry, the center-of-gravity should balance the pull of all points, so moving any direction increases distance to some heavily weighted point more than it decreases to another.\n:::\n\n::: {.callout title=\"Solution\" collapse=\"true\"}\n**Customer Data:**\n\n| Customer | Coordinates (x, y) | Demand |\n|----------|--------------------|--------|\n| A        | (0, 0)             | 10     |\n| B        | (10, 0)            | 5      |\n| C        | (5, 5)             | 5      |\n\n**Weighted Center of Gravity:**\n\n$$\nx^* = \\frac{10 \\cdot 0 + 5 \\cdot 10 + 5 \\cdot 5}{20} = 3.75, \\quad\ny^* = \\frac{10 \\cdot 0 + 5 \\cdot 0 + 5 \\cdot 5}{20} = 1.25\n$$\n\n**Total Distance-Weighted Cost:**\n\n$$\n\\text{Total Cost} = 10 \\cdot d(A, \\text{facility}) + 5 \\cdot d(B, \\text{facility}) + 5 \\cdot d(C, \\text{facility}) \\approx \\textbf{91.16}\n$$\n:::\n\n### Multi-facility Assignment Intuition\n\nSuppose you have four customers located at the four corners of a square region and all have equal demand. If you are to place $K=2$ facilities, where would you intuitively place them and which customers would each serve?\n\n1. Draw a diagram of the four points and show two facility locations that make sense.\n2. Explain why your assignment of customers to facilities is optimal in terms of distance.\n3. How would the solution change if one of the four customers had a much higher demand than the others?\n\n### Solving a Multi-Facility Problem\n\nUse the new dataset of 15 customers provided in the sidebar (`Exercise Data`). Implement the iterative algorithm (or use the provided k-means helper functions) for different values of $K$:\n\n1. Load the dataset and plot the customer locations.\n2. For $K = 2, 3, 4$, run the algorithm and record:\n  - The final total cost.\n  - The coordinates of the facility locations.\n3. Plot customer clusters and facility positions using Altair or Matplotlib.\n4. Think about the trade-off you see between the number of warehouses and cost:\n  - At what point do diminishing returns appear?\n  - If the fixed cost of operating a warehouse is 500 units, how many warehouses should the company build?\n\n::: {.callout title=\"Solution\" collapse=\"true\"}\n**Results:**\n\n| K | Total Cost | Cluster Centers (x, y) |\n|---|------------|-------------------------|\n| 2 | 1571.11    | (1.66, 3.79), (7.82, 6.62) |\n| 3 | 1207.61    | (1.93, 1.65), (7.82, 6.62), (3.14, 9.55) |\n| 4 | 799.36     | (1.93, 1.65), (6.94, 4.67), (3.14, 9.55), (8.70, 2.39) |\n\n**Interpretation:**\n\n- As the number of warehouses $K$ increases, the total cost decreases.\n- The largest drop in cost occurs between $K = 2$ and $K = 3$.\n- Diminishing returns start to appear around $K = 4$.\n:::\n\n",
    "supporting": [
      "07-facility-location_files\\figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}