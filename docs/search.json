[
  {
    "objectID": "learning-modules/06-minimum-cost-network-flow-modeling.html",
    "href": "learning-modules/06-minimum-cost-network-flow-modeling.html",
    "title": "06 | Minimum Cost Network Flow Models",
    "section": "",
    "text": "Network flow models are powerful tools for optimizing the movement of\ngoods through a supply chain network. The minimum cost network flow\nmodel helps determine the most cost-effective way to transport products\nfrom origins (like factories) to destinations (like warehouses).\nIn this module, you will learn how to:\n\nUnderstand the key components of network flow problems\nFormulate these as linear programming models\nImplement and solve them using both Excel Solver and\nPython/Gurobi\nAnalyze different scenarios to make better supply chain\ndecisions",
    "crumbs": [
      "Learning Modules",
      "06 | Minimum Cost Network Flow Models"
    ]
  },
  {
    "objectID": "learning-modules/06-minimum-cost-network-flow-modeling.html#overview",
    "href": "learning-modules/06-minimum-cost-network-flow-modeling.html#overview",
    "title": "06 | Minimum Cost Network Flow Models",
    "section": "",
    "text": "Network flow models are powerful tools for optimizing the movement of\ngoods through a supply chain network. The minimum cost network flow\nmodel helps determine the most cost-effective way to transport products\nfrom origins (like factories) to destinations (like warehouses).\nIn this module, you will learn how to:\n\nUnderstand the key components of network flow problems\nFormulate these as linear programming models\nImplement and solve them using both Excel Solver and\nPython/Gurobi\nAnalyze different scenarios to make better supply chain\ndecisions",
    "crumbs": [
      "Learning Modules",
      "06 | Minimum Cost Network Flow Models"
    ]
  },
  {
    "objectID": "learning-modules/06-minimum-cost-network-flow-modeling.html#key-components-of-network-flow-problems",
    "href": "learning-modules/06-minimum-cost-network-flow-modeling.html#key-components-of-network-flow-problems",
    "title": "06 | Minimum Cost Network Flow Models",
    "section": "2 Key\nComponents of Network Flow Problems",
    "text": "2 Key\nComponents of Network Flow Problems\nA minimum cost network flow problem has three main components:\n\nNodes: Points in the network representing locations\n\nSupply nodes: Where products originate (factories,\nplants)\nTransshipment nodes: Intermediate points\n(distribution centers)\nDemand nodes: Where products are required\n(warehouses, customers)\n\nArcs: Connections between nodes representing\npossible flow paths\n\nEach arc has a cost per unit of flow\nEach arc may have a capacity limit\n\nFlows: The amount of resource moving along each arc\n\nFlow must be conserved at each node (total inflow = total outflow,\nexcept at supply/demand nodes)\nTotal supply must equal total demand for the problem to have\nfeasible solutions",
    "crumbs": [
      "Learning Modules",
      "06 | Minimum Cost Network Flow Models"
    ]
  },
  {
    "objectID": "learning-modules/06-minimum-cost-network-flow-modeling.html#mathematical-formulation",
    "href": "learning-modules/06-minimum-cost-network-flow-modeling.html#mathematical-formulation",
    "title": "06 | Minimum Cost Network Flow Models",
    "section": "3\nMathematical Formulation",
    "text": "3\nMathematical Formulation\nLet’s define:\n\n\\(x_{ij}\\) = flow from node \\(i\\) to node \\(j\\)\n\\(c_{ij}\\) = cost per unit flow\nfrom node \\(i\\) to node \\(j\\)\n\\(u_{ij}\\) = capacity of arc from\nnode \\(i\\) to node \\(j\\)\n\\(b_i\\) = net flow at node \\(i\\) (positive for supply, negative for\ndemand, zero for transshipment)\n\nThe general formulation is:\nObjective: Minimize \\(\\sum_{(i,j)} c_{ij} \\cdot x_{ij}\\)\nSubject to:\n\nFlow Conservation: \\(\\sum_{j:(i,j)} x_{ij}\n- \\sum_{j:(j,i)} x_{ji} = b_i\\) for all nodes \\(i\\)\nCapacity Constraints: \\(0 \\leq x_{ij} \\leq\nu_{ij}\\) for all arcs \\((i,j)\\)",
    "crumbs": [
      "Learning Modules",
      "06 | Minimum Cost Network Flow Models"
    ]
  },
  {
    "objectID": "learning-modules/06-minimum-cost-network-flow-modeling.html#example-01-distribution-unlimited-co.",
    "href": "learning-modules/06-minimum-cost-network-flow-modeling.html#example-01-distribution-unlimited-co.",
    "title": "06 | Minimum Cost Network Flow Models",
    "section": "4 Example\n01: Distribution Unlimited Co.",
    "text": "4 Example\n01: Distribution Unlimited Co.\nLet’s apply this to a concrete example. Distribution Unlimited\nCo. has two factories (F1, F2) that need to ship products to two\nwarehouses (W1, W2). There’s also a distribution center (DC) that can be\nused as an intermediate point.\n\n\n\n\n\nflowchart LR\n    F1(Factory 1&lt;br/&gt;80 units)\n    F2(Factory 2&lt;br/&gt;40 units)\n    DC(Distribution Center)\n    W1(Warehouse 1&lt;br/&gt;-60 units)\n    W2(Warehouse 2&lt;br/&gt;-90 units)\n    \n    F1 --&gt;|$7/unit| W1\n    F1 --&gt;|$3/unit&lt;br/&gt;Max 50 units| DC\n    F2 --&gt;|$4/unit&lt;br/&gt;Max 50 units| DC\n    DC --&gt;|$0/unit| W1\n    DC --&gt;|$2/unit&lt;br/&gt;Max 60 units| W2\n\n\n\n\n\n\nThe network includes:\n\nFactory 1 (F1) produces 80 units\nFactory 2 (F2) produces 40 units\nWarehouse 1 (W1) requires 60 units\nWarehouse 2 (W2) requires 90 units\n\nNotice that total demand (150 units) exceeds total supply (120\nunits). This means we’ll need to handle unfulfilled demand in our\nmodel.\n\n4.1\nHandling Supply-Demand Imbalance\nWhen total supply doesn’t equal total demand, we can:\n\nAdd a dummy supply node (if supply &lt;\ndemand)\nAdd a dummy demand node (if supply &gt;\ndemand)\n\nFor Distribution Unlimited Co., we’ll add a dummy supply of 30 units\nwith zero transportation cost to make the problem feasible:\n\n\n\n\n\nflowchart LR\n    F1(Factory 1&lt;br/&gt;80 units)\n    F2(Factory 2&lt;br/&gt;40 units)\n    DC(Distribution Center)\n    W1(Warehouse 1&lt;br/&gt;-60 units)\n    W2(Warehouse 2&lt;br/&gt;-90 units)\n    DS(Dummy Supply&lt;br/&gt;30 units)\n    \n    F1 --&gt;|$7/unit| W1\n    F1 --&gt;|$3/unit&lt;br/&gt;Max 50 units| DC\n    F2 --&gt;|$4/unit&lt;br/&gt;Max 50 units| DC\n    DC --&gt;|$0/unit| W1\n    DC --&gt;|$2/unit&lt;br/&gt;Max 60 units| W2\n    DS --&gt;|$0/unit| W2\n\n\n\n\n\n\n\n\n4.2\nSolving with Python\nThe Python implementation uses Gurobi Optimizer through its Python\ninterface, gurobipy. Unlike Excel, which uses a tabular\nformat, Python builds the model programmatically. Let’s break down how\nthis works step by step.\nHere’s the basic structure:\n\nDefine nodes and their supply/demand values\nDefine arcs with costs and capacities\nCreate decision variables for flows\nAdd flow conservation constraints\nAdd capacity constraints\nSet the objective and solve the model\n\nFirst, we need to import the necessary libraries:\nimport gurobipy as gp\nfrom gurobipy import GRB\nGurobipy is Gurobi’s Python API, and GRB provides constants like\nGRB.MINIMIZE for setting the optimization direction.\n\n4.2.1\nDefining the Problem Structure\nNext, we define our network structure using Python data\nstructures:\n\n# Define nodes\nnodes = ['F1', 'F2', 'DC', 'W1', 'W2', 'Dummy']\n\n# Define supply/demand at each node\nsupply_demand = {\n    'F1': 80,    # Supply of 80 units\n    'F2': 40,    # Supply of 40 units\n    'DC': 0,     # Transshipment node (no net supply/demand)\n    'W1': -60,   # Demand of 60 units\n    'W2': -90,   # Demand of 90 units\n    'Dummy': 30  # Dummy supply of 30 units\n}\n\n# Define arcs with costs and capacities\narcs = {\n    ('F1', 'W1'): (7, float('inf')),  # Direct route from F1 to W1\n    ('F1', 'DC'): (3, 50),            # Route from F1 to DC with capacity 50\n    ('F2', 'DC'): (4, 50),            # Route from F2 to DC with capacity 50\n    ('DC', 'W1'): (0, float('inf')),  # Route from DC to W1\n    ('DC', 'W2'): (2, 60),            # Route from DC to W2 with capacity 60\n    ('Dummy', 'W2'): (0, float('inf'))  # Dummy route to W2\n}\n\nThis approach is very flexible. We can easily add or remove nodes and\narcs by modifying these data structures.\n\n\n4.2.2\nCreating the Optimization Model\nNow we create a Gurobi model and define the flow variables:\n# Create a new model\nmodel = gp.Model(\"MinCostNetworkFlow\")\n\n# Create flow variables for each arc\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\nEach variable flow[(i, j)] represents the amount flowing\nfrom node i to node j. The\nobj=cost parameter sets the coefficient in the objective\nfunction.\n\n4.2.2.1 flow = {}\nThis initializes an empty Python dictionary called flow.\nThis dictionary will store our decision variables, which represent the\namount of product flowing along each arc in the network. The\ndictionary’s keys will be tuples representing arcs (from node \\(i\\) to node \\(j\\)), and the values will be Gurobi\nvariable objects.\n\n\n4.2.2.2\narcs.items()\nThe arcs variable is a dictionary where:\n\nEach key is a tuple (i, j) representing an arc from\nnode \\(i\\) to node \\(j\\).\nEach value is another tuple (cost, capacity) containing\nthe cost per unit of flow and the maximum capacity for that arc.\n\nThe items() method returns an iterator over the\nkey-value pairs in the dictionary, so arcs.items() produces\npairs like: ((i, j), (cost, capacity)).\n\nfor value in arcs.items():\n    print(value)\n\n(('F1', 'W1'), (7, inf))\n(('F1', 'DC'), (3, 50))\n(('F2', 'DC'), (4, 50))\n(('DC', 'W1'), (0, inf))\n(('DC', 'W2'), (2, 60))\n(('Dummy', 'W2'), (0, inf))\n\n\n\n\n4.2.2.3\nfor (i, j), (cost, _) in arcs.items():\nThis line uses Python’s tuple unpacking to extract values. For each\niteration:\n\n(i, j) captures the origin and destination nodes from\nthe arc tuple.\n(cost, _) captures the cost while ignoring the capacity\n(the underscore _ is a Python convention for a variable you\ndon’t intend to use).\n\nFor example, if one entry in arcs is\n('F1', 'DC'): (3, 50), then in that iteration:\n\ni would be 'F1' (the origin node)\nj would be 'DC' (the destination\nnode)\ncost would be 3 (the cost per unit of\nflow)\n_ would be 50 (the capacity, which we’re\nignoring for now)\n\n\n\n4.2.2.4\nflow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\nFor each arc, this line creates a Gurobi decision variable and adds\nit to our flow dictionary:\n\nmodel.addVar() creates a new decision variable in the\nGurobi model.\nname=f'flow_{i}_{j}' gives the variable a descriptive\nname like \"flow_F1_DC\".\nobj=cost sets the variable’s coefficient in the\nobjective function to the cost of this arc.\nflow[(i, j)] = ... stores the created variable in our\ndictionary with the arc tuple as the key.\n\nBy default, Gurobi variables are non-negative (lb = 0)\nand continuous, which is what we want for flow variables in this network\nproblem.\n\n\n4.2.2.5 What’s Happening\nOverall\nThis loop iterates through each possible shipping route (arc) in our\nnetwork. For each arc, it:\n\nExtracts the origin node, destination node, and shipping cost\nCreates a variable representing “how much to ship from origin to\ndestination”\nAssociates that variable with the arc’s cost in the objective\nfunction\nStores the variable in a dictionary for later use when creating\nconstraints\n\nAfter this loop completes, the flow dictionary contains\nall the decision variables our model needs, with each variable properly\nconnected to its cost in the objective function. This is the foundation\nof our optimization model, we’re creating variables for each possible\nshipment route and telling Gurobi that we want to minimize the total\nshipping cost.\nThe next parts of the code will add constraints to ensure flow\nconservation (what comes in equals what goes out at each node) and to\nenforce capacity limits on certain routes.\n\n\n\n4.2.3\nAdding Flow Conservation Constraints\nThe most important constraints ensure flow conservation at each\nnode:\n# Add flow conservation constraints for each node\nfor i in nodes:\n    # Sum of all flows leaving node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of all flows entering node i\n    inflow  = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\nThis loop creates one constraint for each node. The constraint\nensures that:\n\nFor supply nodes: \\(outflow - inflow =\nsupply amount\\)\nFor demand nodes: \\(outflow - inflow =\n-demand amount\\)\nFor transshipment nodes: \\(outflow -\ninflow = 0\\)\n\n\n4.2.3.1\nfor i in nodes:\nThis loop iterates through each node in our network. For every node\n(whether it’s a factory, warehouse, or distribution center), we need to\ncreate a flow conservation constraint.\nFlow conservation is a fundamental principle in network flow models.\nIt states that for any node in the network:\n\nThe amount of flow entering the node, minus\nThe amount of flow leaving the node,\nMust equal the node’s supply or demand value\n\nThis mirrors real-world physical constraints: products don’t\ndisappear or materialize within the network (except at supply or demand\nnodes).\n\n\n4.2.3.2\noutflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\nThis line calculates the total flow leaving node i:\n\narcs.keys() gives us all the arc tuples\n(i2, j) in our network.\nif i2 == i filters for only those arcs where the origin\nnode matches our current node i.\nflow[(i, j)] retrieves the decision variable\nrepresenting flow on the arc from node i to some other node\nj.\ngp.quicksum(...) sums up all these flow variables.\n\nEssentially, we’re adding up all the flow variables for arcs that\noriginate from node i.\nThe reason for using i2 here is that we’re unpacking\ntuples from arcs.keys(). Each tuple is an arc represented\nas (origin, destination). We use i2 as a\ntemporary variable name to compare with our current node\ni.\n\n\n4.2.3.3\ninflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\nSimilarly, this line calculates the total flow entering node\ni:\n\narcs.keys() gives us all the arc tuples\n(j, i2) in our network.\nif i2 == i filters for only those arcs where the\ndestination node matches our current node i.\nflow[(j, i)] retrieves the decision variable\nrepresenting flow on the arc from some other node j to node\ni.\ngp.quicksum(...) sums up all these flow variables.\n\nThis time, we’re adding up all the flow variables for arcs that\nterminate at node i.\n\n\n4.2.3.4\nmodel.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\nFinally, we add the constraint to our model:\n\noutflow - inflow calculates the net flow (outgoing\nminus incoming) at node i.\nsupply_demand[i] retrieves the supply/demand value for\nnode i:\n\nPositive supply for supply nodes (more going out than coming\nin)\nNegative for demand nodes (more coming in than going out)\nZero for transshipment nodes (what comes in must equal what goes\nout)\n\nmodel.addConstr(...) adds this constraint to the Gurobi\nmodel.\nname=f'node_{i}' gives the constraint a unique name for\nidentification.\n\nThe constraint enforces different behaviors depending on the node\ntype:\n\nSupply Nodes: If\nsupply_demand[i] = 50, then\noutflow - inflow = 50, meaning the node sends out 50 more\nunits than it receives.\nDemand Nodes: If\nsupply_demand[i] = -30, then\noutflow - inflow = -30, meaning the node receives 30 more\nunits than it sends out.\nTransshipment Nodes: If\nsupply_demand[i] = 0, then\noutflow - inflow = 0, meaning everything that enters the\nnode must also leave it.\n\n\n\n\n4.2.4\nAdding Capacity Constraints\nSome arcs have capacity limits:\n# Add capacity constraints for each arc\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity &lt; float('inf'):\n        model.addConstr(flow[(i, j)] &lt;= capacity, name=f'capacity_{i}_{j}')\nThis only adds constraints for arcs with finite capacity. We use\nfloat('inf') to represent unlimited capacity.\n\n4.2.4.1\nfor (i, j), (_, capacity) in arcs.items():\nThis loop iterates through each arc in our network and its\ncorresponding capacity. Let’s break down the unpacking:\n\narcs.items() returns pairs of\n((i, j), (cost, capacity)) where:\n\n(i, j) is the arc from node i to node\nj\n(cost, capacity) contains the shipping cost and maximum\ncapacity\n\n(i, j), (_, capacity) unpacks these values:\n\ni is the origin node\nj is the destination node\n_ is the cost (we use underscore because we don’t need\nthe cost for capacity constraints)\ncapacity is the maximum amount that can flow on this\narc\n\n\nFor example, if arcs contains (‘F1’, ‘DC’): (3, 50), then in that\niteration:\n\ni would be 'F1' (origin)\nj would be 'DC' (destination)\n_ would be 3 (cost, ignored here)\ncapacity would be 50 (maximum flow\nallowed)\n\n\n\n4.2.4.2\nif capacity &lt; float('inf'):\nNot all arcs need capacity constraints. Many routes have no practical\nlimit, or their limit is so large that it won’t affect the optimal\nsolution. In our code:\n\nfloat('inf') represents infinity in Python\ncapacity &lt; float('inf') checks if the capacity is a\nfinite number\n\nIf true, we need to add a capacity constraint\nIf false (capacity is infinite), no constraint is needed\n\n\nThis condition ensures we only add constraints where necessary,\nkeeping our model streamlined.\n\n\n4.2.4.3\nmodel.addConstr(flow[(i, j)] &lt;= capacity, name=f'capacity_{i}_{j}')\nThis line creates and adds the actual capacity constraint to our\nmodel:\n\nflow[(i, j)] accesses the decision variable\nrepresenting flow on this arc\nflow[(i, j)] &lt;= capacity creates a constraint saying\nthe flow cannot exceed the capacity\nmodel.addConstr(...) adds this constraint to the Gurobi\nmodel\nname=f'capacity_{i}_{j}' gives the constraint a\ndescriptive name like “capacity_F1_DC”\n\n\n\n\n4.2.5\nSetting the Objective and Solving\nFinally, we set the objective function and solve the model:\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Optimize the model\nmodel.optimize()\n\n\n4.2.6\nExtracting and Analyzing the Solution\nAfter solving, we can extract and analyze the results:\n# Check if an optimal solution was found\nif model.Status == GRB.OPTIMAL:\n    # Extract the solution\n    flow_values = {}\n    total_cost = 0\n    \n    for (i, j), var in flow.items():\n        # Get the flow amount for this arc\n        flow_amount = var.X\n        \n        # Only include arcs with positive flow\n        if flow_amount &gt; 0.001:  # Small threshold for floating-point errors\n            flow_values[(i, j)] = flow_amount\n            \n            # Add to the total cost\n            cost = arcs[(i, j)][0]\n            total_cost += flow_amount * cost\n    \n    print(\"Optimal flows:\")\n    for (i, j), flow in sorted(flow_values.items()):\n        cost = arcs[(i, j)][0]\n        print(f\"{i} → {j}: {flow:.1f} units (cost: ${cost}/unit)\")\n    \n    print(f\"&lt;br/&gt;Total transportation cost: ${total_cost:.1f}\")\nelse:\n    print(f\"No optimal solution found. Status code: {model.Status}\")\nThis code extracts the flow values from the solution, calculates the\ntotal cost, and prints a summary of the optimal flows.\n\n\n4.2.7\nAll Together\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Define nodes\nnodes = ['F1', 'F2', 'DC', 'W1', 'W2', 'Dummy']\n\n# Define supply/demand at each node\nsupply_demand = {\n    'F1': 80,    # Supply of 80 units\n    'F2': 40,    # Supply of 40 units\n    'DC': 0,     # Transshipment node (no net supply/demand)\n    'W1': -60,   # Demand of 60 units\n    'W2': -90,   # Demand of 90 units\n    'Dummy': 30  # Dummy supply of 30 units\n}\n\n# Define arcs with costs and capacities\narcs = {\n    ('F1', 'W1'): (7, float('inf')),  # Direct route from F1 to W1\n    ('F1', 'DC'): (3, 50),            # Route from F1 to DC with capacity 50\n    ('F2', 'DC'): (4, 50),            # Route from F2 to DC with capacity 50\n    ('DC', 'W1'): (0, float('inf')),  # Route from DC to W1\n    ('DC', 'W2'): (2, 60),            # Route from DC to W2 with capacity 60\n    ('Dummy', 'W2'): (0, float('inf'))  # Dummy route to W2\n}\n\n# Create a new model\nmodel = gp.Model(\"MinCostNetworkFlow\")\nmodel.Params.LogToConsole = 0 # should turn off unwanted gurobipy output\n\n# Create flow variables for each arc\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints for each node\nfor i in nodes:\n    # Sum of all flows leaving node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of all flows entering node i\n    inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Add capacity constraints for each arc\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity &lt; float('inf'):\n        model.addConstr(flow[(i, j)] &lt;= capacity, name=f'capacity_{i}_{j}')\n\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Optimize the model\nmodel.optimize()\n\n# Check if an optimal solution was found\nif model.Status == GRB.OPTIMAL:\n    # Extract the solution\n    flow_values = {}\n    total_cost = 0\n    \n    for (i, j), var in flow.items():\n        # Get the flow amount for this arc\n        flow_amount = var.X\n        \n        # Only include arcs with positive flow\n        if flow_amount &gt; 0.001:  # Small threshold for floating-point errors\n            flow_values[(i, j)] = flow_amount\n            \n            # Add to the total cost\n            cost = arcs[(i, j)][0]\n            total_cost += flow_amount * cost\n    \n    print(\"Optimal flows:\")\n    for (i, j), flow in sorted(flow_values.items()):\n        cost = arcs[(i, j)][0]\n        print(f\"{i} → {j}: {flow:.1f} units (cost: ${cost}/unit)\")\n    \n    print(f\"&lt;br/&gt;Total transportation cost: ${total_cost:.1f}\")\nelse:\n    print(f\"No optimal solution found. Status code: {model.Status}\")\n\nSet parameter Username\nSet parameter LicenseID to value 2609229\nSet parameter LogToConsole to value 0\nOptimal flows:\nDC → W1: 30.0 units (cost: $0/unit)\nDC → W2: 60.0 units (cost: $2/unit)\nDummy → W2: 30.0 units (cost: $0/unit)\nF1 → DC: 50.0 units (cost: $3/unit)\nF1 → W1: 30.0 units (cost: $7/unit)\nF2 → DC: 40.0 units (cost: $4/unit)\n&lt;br/&gt;Total transportation cost: $640.0\n\n\n\n\n\n\n\nflowchart LR\n    F1(Factory 1&lt;br/&gt;80 units)\n    F2(Factory 2&lt;br/&gt;40 units)\n    DC(Distribution Center)\n    W1(Warehouse 1&lt;br/&gt;-60 units)\n    W2(Warehouse 2&lt;br/&gt;-90 units)\n    DS(Dummy Supply&lt;br/&gt;30 units)\n    \n    F1 --&gt;|30 units&lt;br/&gt;$7/unit| W1\n    F1 --&gt;|50 units&lt;br/&gt;$3/unit| DC\n    F2 --&gt;|40 units&lt;br/&gt;$4/unit| DC\n    DC --&gt;|30 units&lt;br/&gt;$0/unit| W1\n    DC --&gt;|60 units&lt;br/&gt;$2/unit| W2\n    DS --&gt;|30 units&lt;br/&gt;$0/unit| W2\n    \n    style F1 fill:#d4f1c5\n    style F2 fill:#d4f1c5\n    style DS fill:#d4f1c5\n    style W1 fill:#c5daf1\n    style W2 fill:#c5daf1\n    style DC fill:#f1e9c5\n\n\n\n\n\n\n\n\n4.2.8\nAdvantages of the Python Approach\nThe Python/Gurobi approach offers several advantages:\n\nScales to very large networks (hundreds of nodes and arcs)\nEasier to modify and analyze multiple scenarios\nCan be integrated with other Python tools for data analysis and\nvisualization\nFaster for complex problems\nMore sophisticated error handling and reporting\n\nHere is a version of this problem with five factories, 3 distribution\ncenters, and eight warehouse locations:\n\n\n\n\n\nflowchart LR\n    %% Supply Nodes (Factories)\n    F1[Factory 1&lt;br/&gt;120 units]\n    F2[Factory 2&lt;br/&gt;150 units]\n    F3[Factory 3&lt;br/&gt;200 units]\n    F4[Factory 4&lt;br/&gt;180 units]\n    F5[Factory 5&lt;br/&gt;250 units]\n    \n    %% Transshipment Nodes (Distribution Centers)\n    DC1[Distribution Center 1]\n    DC2[Distribution Center 2]\n    DC3[Distribution Center 3]\n    \n    %% Demand Nodes (Warehouses)\n    W1[Warehouse 1&lt;br/&gt;-80 units]\n    W2[Warehouse 2&lt;br/&gt;-110 units]\n    W3[Warehouse 3&lt;br/&gt;-90 units]\n    W4[Warehouse 4&lt;br/&gt;-130 units]\n    W5[Warehouse 5&lt;br/&gt;-150 units]\n    W6[Warehouse 6&lt;br/&gt;-100 units]\n    W7[Warehouse 7&lt;br/&gt;-120 units]\n    W8[Warehouse 8&lt;br/&gt;-120 units]\n    \n    %% Factory to DC connections\n    F1 --&gt;|$3/unit&lt;br/&gt;Max 100| DC1\n    F1 --&gt;|$4/unit&lt;br/&gt;Max 80| DC2\n    F2 --&gt;|$4/unit&lt;br/&gt;Max 90| DC1\n    F2 --&gt;|$3/unit&lt;br/&gt;Max 100| DC2\n    F3 --&gt;|$3/unit&lt;br/&gt;Max 120| DC2\n    F3 --&gt;|$2/unit&lt;br/&gt;Max 150| DC3\n    F4 --&gt;|$4/unit&lt;br/&gt;Max 100| DC2\n    F4 --&gt;|$3/unit&lt;br/&gt;Max 110| DC3\n    F5 --&gt;|$5/unit&lt;br/&gt;Max 80| DC1\n    F5 --&gt;|$2/unit&lt;br/&gt;Max 200| DC3\n    \n    %% Sample direct Factory to Warehouse connections\n    F1 -.-&gt;|$8/unit| W1\n    F2 -.-&gt;|$8/unit| W2\n    F3 -.-&gt;|$9/unit| W4\n    F4 -.-&gt;|$10/unit| W5\n    F5 -.-&gt;|$8/unit| W8\n    \n    %% DC to Warehouse connections (showing representative examples)\n    DC1 --&gt;|$3/unit&lt;br/&gt;Max 100| W1\n    DC1 --&gt;|$4/unit&lt;br/&gt;Max 90| W2\n    DC1 --&gt;|$2/unit&lt;br/&gt;Max 120| W3\n    DC2 --&gt;|$3/unit&lt;br/&gt;Max 100| W3\n    DC2 --&gt;|$2/unit&lt;br/&gt;Max 150| W4\n    DC2 --&gt;|$4/unit&lt;br/&gt;Max 120| W5\n    DC3 --&gt;|$4/unit&lt;br/&gt;Max 90| W6\n    DC3 --&gt;|$3/unit&lt;br/&gt;Max 140| W7\n    DC3 --&gt;|$2/unit&lt;br/&gt;Max 120| W8\n    \n    %% Inter-DC connections\n    DC1 --&gt;|$1/unit&lt;br/&gt;Max 70| DC2\n    DC2 --&gt;|$1/unit&lt;br/&gt;Max 90| DC3\n    DC3 --&gt;|$2/unit&lt;br/&gt;Max 60| DC1\n    \n    %% Node styling\n    classDef supply fill:#d4f1c5,stroke:#333,stroke-width:1px\n    classDef transship fill:#f1e9c5,stroke:#333,stroke-width:1px\n    classDef demand fill:#c5daf1,stroke:#333,stroke-width:1px\n    \n    %% Apply styles\n    class F1,F2,F3,F4,F5 supply\n    class DC1,DC2,DC3 transship\n    class W1,W2,W3,W4,W5,W6,W7,W8 demand\n\n\n\n\n\n\n\n\nCode\n\"\"\"\nMinimum Cost Network Flow Solver\n\nThis script reads supply chain network data from CSV files and \nsolves the minimum cost network flow problem using Gurobi optimizer.\n\"\"\"\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport pandas as pd\n\n# Read the node data\nprint(\"Reading node data from nodes.csv...\")\nnodes_df = pd.read_csv(r'data\\min_cost_ex_nodes.csv')\n\n# Read the arc data\nprint(\"Reading arc data from arcs.csv...\")\narcs_df = pd.read_csv(r'data\\min_cost_ex_arcs.csv')\n\n# Extract node information\nnodes = nodes_df['node_id'].tolist()\nsupply_demand = dict(zip(nodes_df['node_id'], nodes_df['supply_demand']))\nnode_types = dict(zip(nodes_df['node_id'], nodes_df['type']))\n\n# Group nodes by type for reporting\nfactories = [node for node, type_val in node_types.items() if type_val == 'Factory']\ndistribution_centers = [node for node, type_val in node_types.items() if type_val == 'DC']\nwarehouses = [node for node, type_val in node_types.items() if type_val == 'Warehouse']\n\n# Check supply/demand balance\ntotal_supply = sum(v for v in supply_demand.values() if v &gt; 0)\ntotal_demand = -sum(v for v in supply_demand.values() if v &lt; 0)\nprint(f\"Total supply: {total_supply}\")\nprint(f\"Total demand: {total_demand}\")\nif total_supply != total_demand:\n    print(\"Warning: Supply and demand are not balanced!\")\n\n# Create arcs dictionary from DataFrame\n# Convert 'inf' strings to actual infinity\narcs_df['capacity'] = arcs_df['capacity'].replace('inf', float('inf'))\narcs_df['capacity'] = pd.to_numeric(arcs_df['capacity'])\n\n# Create arcs dictionary\narcs = {}\nfor _, row in arcs_df.iterrows():\n    arcs[(row['from_node'], row['to_node'])] = (row['cost'], row['capacity'])\n\nprint(f\"Network has {len(nodes)} nodes and {len(arcs)} arcs\")\n\n# Create a new Gurobi model\nmodel = gp.Model(\"SupplyChainNetwork\")\nmodel.Params.LogToConsole = 0\n\n# Create flow variables for each arc\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints for each node\nfor i in nodes:\n    # Sum of flows leaving node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of flows entering node i\n    inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Add capacity constraints for each arc\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity &lt; float('inf'):\n        model.addConstr(flow[(i, j)] &lt;= capacity, name=f'capacity_{i}_{j}')\n\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Solve the model\nprint(\"\\nSolving the network flow problem...\")\nmodel.optimize()\n\n# Check if an optimal solution was found\nif model.Status == GRB.OPTIMAL:\n    # Calculate flow statistics\n    active_arcs = 0\n    capacity_limited_arcs = 0\n    total_cost = 0\n    \n    # Dictionaries to track flows by node type\n    factory_flows = {f: 0 for f in factories}\n    dc_throughput = {dc: 0 for dc in distribution_centers}\n    warehouse_inflows = {w: 0 for w in warehouses}\n    \n    # Extract solution\n    flow_values = {}\n    for (i, j), var in flow.items():\n        flow_amount = var.X\n        if flow_amount &gt; 0.001:  # Only count non-zero flows\n            flow_values[(i, j)] = flow_amount\n            active_arcs += 1\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            total_cost += flow_amount * cost\n            \n            # Check if arc is at capacity\n            if capacity &lt; float('inf') and abs(flow_amount - capacity) &lt; 0.001:\n                capacity_limited_arcs += 1\n            \n            # Update node statistics\n            if i in factories:\n                factory_flows[i] += flow_amount\n            if i in distribution_centers:\n                dc_throughput[i] += flow_amount\n            if j in warehouses:\n                warehouse_inflows[j] += flow_amount\n    \n    # Print results\n    print(\"\\n========== OPTIMAL SOLUTION FOUND ==========\")\n    print(f\"Total transportation cost: ${total_cost:.2f}\")\n    print(f\"Active arcs: {active_arcs} out of {len(arcs)} possible\")\n    print(f\"Arcs at capacity: {capacity_limited_arcs}\")\n    \n    # Factory utilization\n    print(\"\\nFACTORY UTILIZATION:\")\n    for f in factories:\n        utilization_pct = (factory_flows[f] / supply_demand[f]) * 100\n        print(f\"  {f}: {factory_flows[f]} units shipped ({utilization_pct:.1f}% of capacity)\")\n    \n    # Distribution center throughput\n    print(\"\\nDISTRIBUTION CENTER THROUGHPUT:\")\n    for dc in distribution_centers:\n        print(f\"  {dc}: {dc_throughput[dc]} units processed\")\n    \n    # Warehouse demand fulfillment\n    print(\"\\nWAREHOUSE DEMAND FULFILLMENT:\")\n    for w in warehouses:\n        received_pct = (warehouse_inflows[w] / (-supply_demand[w])) * 100\n        print(f\"  {w}: {warehouse_inflows[w]} units received ({received_pct:.1f}% of demand)\")\n    \n    # Detailed flow report\n    print(\"\\nDETAILED FLOW REPORT (non-zero flows only):\")\n    \n    # Factory to warehouse direct\n    f_to_w = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n             if i in factories and j in warehouses]\n    if f_to_w:\n        print(\"\\n  Factory → Warehouse (Direct):\")\n        for i, j, amt in sorted(f_to_w):\n            cost = arcs[(i, j)][0]\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f})\")\n    \n    # Factory to DC\n    f_to_dc = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n              if i in factories and j in distribution_centers]\n    if f_to_dc:\n        print(\"\\n  Factory → Distribution Center:\")\n        for i, j, amt in sorted(f_to_dc):\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            at_capacity = \" (at capacity)\" if abs(amt - capacity) &lt; 0.001 else \"\"\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f}){at_capacity}\")\n    \n    # DC to warehouse\n    dc_to_w = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n              if i in distribution_centers and j in warehouses]\n    if dc_to_w:\n        print(\"\\n  Distribution Center → Warehouse:\")\n        for i, j, amt in sorted(dc_to_w):\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            at_capacity = \" (at capacity)\" if abs(amt - capacity) &lt; 0.001 else \"\"\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f}){at_capacity}\")\n    \n    # Inter-DC flows\n    dc_to_dc = [(i, j, flow_values[(i, j)]) for (i, j) in flow_values.keys() \n               if i in distribution_centers and j in distribution_centers]\n    if dc_to_dc:\n        print(\"\\n  Distribution Center → Distribution Center:\")\n        for i, j, amt in sorted(dc_to_dc):\n            cost = arcs[(i, j)][0]\n            capacity = arcs[(i, j)][1]\n            at_capacity = \" (at capacity)\" if abs(amt - capacity) &lt; 0.001 else \"\"\n            print(f\"    {i} → {j}: {amt:.1f} units (cost: ${cost}/unit, total: ${amt*cost:.1f}){at_capacity}\")\n    \n    # Export solution to CSV\n    solution_data = []\n    for (i, j), flow_amount in flow_values.items():\n        cost = arcs[(i, j)][0]\n        capacity = arcs[(i, j)][1]\n        solution_data.append({\n            'from_node': i,\n            'to_node': j,\n            'flow': flow_amount,\n            'cost_per_unit': cost,\n            'total_cost': flow_amount * cost,\n            'capacity': capacity if capacity &lt; float('inf') else 'unlimited',\n            'at_capacity': 'Yes' if capacity &lt; float('inf') and abs(flow_amount - capacity) &lt; 0.001 else 'No'\n        })\n    \n    solution_df = pd.DataFrame(solution_data)\n    solution_df.to_csv('solution.csv', index=False)\n    print()\n    print(solution_df)\n    \nelse:\n    print(f\"No optimal solution found. Status code: {model.Status}\")\n    print(\"Check your data for inconsistencies in supply/demand balance or network connectivity.\")\n\n\nReading node data from nodes.csv...\nReading arc data from arcs.csv...\nTotal supply: 900\nTotal demand: 900\nNetwork has 16 nodes and 35 arcs\nSet parameter LogToConsole to value 0\n\nSolving the network flow problem...\n\n========== OPTIMAL SOLUTION FOUND ==========\nTotal transportation cost: $5120.00\nActive arcs: 23 out of 35 possible\nArcs at capacity: 9\n\nFACTORY UTILIZATION:\n  F1: 120.0 units shipped (100.0% of capacity)\n  F2: 150.0 units shipped (100.0% of capacity)\n  F3: 200.0 units shipped (100.0% of capacity)\n  F4: 180.0 units shipped (100.0% of capacity)\n  F5: 250.0 units shipped (100.0% of capacity)\n\nDISTRIBUTION CENTER THROUGHPUT:\n  DC1: 240.0 units processed\n  DC2: 240.0 units processed\n  DC3: 460.0 units processed\n\nWAREHOUSE DEMAND FULFILLMENT:\n  W1: 80.0 units received (100.0% of demand)\n  W2: 110.0 units received (100.0% of demand)\n  W3: 90.0 units received (100.0% of demand)\n  W4: 130.0 units received (100.0% of demand)\n  W5: 150.0 units received (100.0% of demand)\n  W6: 100.0 units received (100.0% of demand)\n  W7: 120.0 units received (100.0% of demand)\n  W8: 120.0 units received (100.0% of demand)\n\nDETAILED FLOW REPORT (non-zero flows only):\n\n  Factory → Warehouse (Direct):\n    F2 → W2: 20.0 units (cost: $8/unit, total: $160.0)\n\n  Factory → Distribution Center:\n    F1 → DC1: 100.0 units (cost: $3/unit, total: $300.0) (at capacity)\n    F1 → DC2: 20.0 units (cost: $4/unit, total: $80.0)\n    F2 → DC1: 30.0 units (cost: $4/unit, total: $120.0)\n    F2 → DC2: 100.0 units (cost: $3/unit, total: $300.0) (at capacity)\n    F3 → DC2: 50.0 units (cost: $3/unit, total: $150.0)\n    F3 → DC3: 150.0 units (cost: $2/unit, total: $300.0) (at capacity)\n    F4 → DC2: 70.0 units (cost: $4/unit, total: $280.0)\n    F4 → DC3: 110.0 units (cost: $3/unit, total: $330.0) (at capacity)\n    F5 → DC1: 50.0 units (cost: $5/unit, total: $250.0)\n    F5 → DC3: 200.0 units (cost: $2/unit, total: $400.0) (at capacity)\n\n  Distribution Center → Warehouse:\n    DC1 → W1: 80.0 units (cost: $3/unit, total: $240.0)\n    DC1 → W2: 90.0 units (cost: $4/unit, total: $360.0) (at capacity)\n    DC1 → W3: 70.0 units (cost: $2/unit, total: $140.0)\n    DC2 → W3: 20.0 units (cost: $3/unit, total: $60.0)\n    DC2 → W4: 130.0 units (cost: $2/unit, total: $260.0)\n    DC2 → W5: 20.0 units (cost: $4/unit, total: $80.0)\n    DC2 → W6: 70.0 units (cost: $3/unit, total: $210.0)\n    DC3 → W5: 130.0 units (cost: $2/unit, total: $260.0) (at capacity)\n    DC3 → W6: 30.0 units (cost: $4/unit, total: $120.0)\n    DC3 → W7: 120.0 units (cost: $3/unit, total: $360.0)\n    DC3 → W8: 120.0 units (cost: $2/unit, total: $240.0) (at capacity)\n\n  Distribution Center → Distribution Center:\n    DC3 → DC1: 60.0 units (cost: $2/unit, total: $120.0) (at capacity)\n\n   from_node to_node   flow  cost_per_unit  total_cost   capacity at_capacity\n0         F1     DC1  100.0              3       300.0      100.0         Yes\n1         F1     DC2   20.0              4        80.0       80.0          No\n2         F2     DC1   30.0              4       120.0       90.0          No\n3         F2     DC2  100.0              3       300.0      100.0         Yes\n4         F3     DC2   50.0              3       150.0      120.0          No\n5         F3     DC3  150.0              2       300.0      150.0         Yes\n6         F4     DC2   70.0              4       280.0      100.0          No\n7         F4     DC3  110.0              3       330.0      110.0         Yes\n8         F5     DC1   50.0              5       250.0       80.0          No\n9         F5     DC3  200.0              2       400.0      200.0         Yes\n10        F2      W2   20.0              8       160.0  unlimited          No\n11       DC1      W1   80.0              3       240.0      100.0          No\n12       DC1      W2   90.0              4       360.0       90.0         Yes\n13       DC1      W3   70.0              2       140.0      120.0          No\n14       DC2      W3   20.0              3        60.0      100.0          No\n15       DC2      W4  130.0              2       260.0      150.0          No\n16       DC2      W5   20.0              4        80.0      120.0          No\n17       DC2      W6   70.0              3       210.0      110.0          No\n18       DC3      W5  130.0              2       260.0      130.0         Yes\n19       DC3      W6   30.0              4       120.0       90.0          No\n20       DC3      W7  120.0              3       360.0      140.0          No\n21       DC3      W8  120.0              2       240.0      120.0         Yes\n22       DC3     DC1   60.0              2       120.0       60.0         Yes\n\n\nThis is just for example, we will not being doing any problems like\nthis in this course.",
    "crumbs": [
      "Learning Modules",
      "06 | Minimum Cost Network Flow Models"
    ]
  },
  {
    "objectID": "learning-modules/06-minimum-cost-network-flow-modeling.html#example-02-oil-transport-problem",
    "href": "learning-modules/06-minimum-cost-network-flow-modeling.html#example-02-oil-transport-problem",
    "title": "06 | Minimum Cost Network Flow Models",
    "section": "5 Example\n02: Oil Transport Problem",
    "text": "5 Example\n02: Oil Transport Problem\nLet’s look at another example. The Conch Oil Company needs to\ntransport 30 million barrels of crude oil from Doha, Qatar to three\nEuropean refineries:\n\nRotterdam, Netherlands (6 million barrels)\nToulon, France (15 million barrels)\nPalermo, Italy (9 million barrels)\n\nThere are three possible routes:\n\nDirect shipping around Africa (most expensive)\nThrough the Suez Canal to Port Said, then to destinations\nFrom Suez to Damietta via pipeline (limited to 15 million barrels),\nthen to destinations\n\n\n\n\n\n\nflowchart LR\n    Doha(Doha&lt;br/&gt;30M barrels)\n    Suez(Suez)\n    PortSaid(Port Said)\n    Damietta(Damietta)\n    Rotterdam(Rotterdam&lt;br/&gt;-6M barrels)\n    Toulon(Toulon&lt;br/&gt;-15M barrels)\n    Palermo(Palermo&lt;br/&gt;-9M barrels)\n    \n    Doha --&gt;|$1.20/barrel| Rotterdam\n    Doha --&gt;|$1.40/barrel| Toulon\n    Doha --&gt;|$1.35/barrel| Palermo\n    Doha --&gt;|$0.35/barrel| Suez\n    Suez --&gt;|$0.20/barrel| PortSaid\n    Suez --&gt;|$0.16/barrel&lt;br/&gt;Max 15M barrels| Damietta\n    PortSaid --&gt;|$0.27/barrel| Rotterdam\n    PortSaid --&gt;|$0.28/barrel| Toulon\n    PortSaid --&gt;|$0.19/barrel| Palermo\n    Damietta --&gt;|$0.25/barrel| Rotterdam\n    Damietta --&gt;|$0.20/barrel| Toulon\n    Damietta --&gt;|$0.15/barrel| Palermo\n    \n    style Doha fill:#d4f1c5\n    style Rotterdam fill:#c5daf1\n    style Toulon fill:#c5daf1\n    style Palermo fill:#c5daf1\n    style Suez fill:#f1e9c5\n    style PortSaid fill:#f1e9c5\n    style Damietta fill:#f1e9c5\n\n\n\n\n\n\n\n5.1\nOptimal Solution to Oil Transport Problem\nLet’s implement a complete Python solution for the Conch Oil Company\nproblem. We’ll structure this similar to our previous example but add\nmore detailed code comments to explain the logic.\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Define the nodes in our network\nnodes = ['Doha', 'Suez', 'PortSaid', 'Damietta', 'Rotterdam', 'Toulon', 'Palermo']\n\n# Define supply/demand at each node (in millions of barrels)\nsupply_demand = {\n    'Doha': 30,        # Supply: 30M barrels at origin\n    'Suez': 0,         # Transshipment node: no net supply/demand\n    'PortSaid': 0,     # Transshipment node: no net supply/demand\n    'Damietta': 0,     # Transshipment node: no net supply/demand\n    'Rotterdam': -6,   # Demand: 6M barrels\n    'Toulon': -15,     # Demand: 15M barrels\n    'Palermo': -9      # Demand: 9M barrels\n}\n\n# Define arcs with (cost, capacity) tuples\n# Format: (origin, destination): (cost per barrel, capacity in millions of barrels)\narcs = {\n    # Direct routes from Doha to refineries\n    ('Doha', 'Rotterdam'): (1.20, float('inf')),\n    ('Doha', 'Toulon'): (1.40, float('inf')),\n    ('Doha', 'Palermo'): (1.35, float('inf')),\n    \n    # Route via Suez\n    ('Doha', 'Suez'): (0.35, float('inf')),\n    ('Suez', 'PortSaid'): (0.20, float('inf')),\n    ('Suez', 'Damietta'): (0.16, 15),  # Pipeline has 15M barrel capacity\n    \n    # Routes from Port Said to refineries\n    ('PortSaid', 'Rotterdam'): (0.27, float('inf')),\n    ('PortSaid', 'Toulon'): (0.28, float('inf')),\n    ('PortSaid', 'Palermo'): (0.19, float('inf')),\n    \n    # Routes from Damietta to refineries\n    ('Damietta', 'Rotterdam'): (0.25, float('inf')),\n    ('Damietta', 'Toulon'): (0.20, float('inf')),\n    ('Damietta', 'Palermo'): (0.15, float('inf'))\n}\n\n# Create a new Gurobi model\nmodel = gp.Model(\"OilTransportProblem\")\nmodel.Params.LogToConsole = 0\n\n# Create decision variables for flow on each arc\n# Each variable represents millions of barrels flowing on that route\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    # obj=cost sets this variable's coefficient in the objective function\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints\n# For each node: outflow - inflow = supply/demand\nfor i in nodes:\n    # Calculate total outflow from node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Calculate total inflow to node i\n    inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Set constraint: outflow - inflow = supply/demand for this node\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Add capacity constraints for arcs with limited capacity\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity &lt; float('inf'):\n        model.addConstr(flow[(i, j)] &lt;= capacity, name=f'capacity_{i}_{j}')\n\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Solve the model\nmodel.optimize()\n\nSet parameter LogToConsole to value 0\n\n\nWhen executing this model, the solution shows that:\n\nAll 30 million barrels are shipped from Doha to Suez\nFrom Suez, 15 million barrels go through the pipeline to Damietta\n(utilizing full capacity)\nThe remaining 15 million barrels go to Port Said\nFrom Damietta and Port Said, the oil is distributed to the\nrefineries through the most cost-effective routes\n\nWe can extract values from our model with the following code. You\nshould be able to use the same code for similar models, like in the lab\n(hint hint):\n\nimport pandas as pd\n\n# Create a list to store flow data for the CSV\nflow_data = []\ntotal_cost = 0\n\n# Extract non-zero flows\nfor (i, j), var in flow.items():\n    flow_amount = var.X\n    \n    # Filter out very small flows (numerical precision issues)\n    if flow_amount &gt; 0.001:\n        # Get the cost for this arc\n        cost = arcs[(i, j)][0]\n        \n        # Calculate the cost contribution\n        flow_cost = flow_amount * cost\n        total_cost += flow_cost\n        \n        # Add a row with all relevant information\n        flow_data.append({\n            'origin': i,\n            'destination': j,\n            'flow': round(flow_amount, 2),\n            'cost_per_unit': cost,\n            'total_cost': round(flow_cost, 2),\n            'capacity': arcs[(i, j)][1] if arcs[(i, j)][1] &lt; float('inf') else 'Unlimited'\n        })\n\n# Check if we have any flow data before proceeding\nif flow_data:\n    # Create a DataFrame from the flow data\n    flow_df = pd.DataFrame(flow_data)\n    \n    # Sort the DataFrame without assuming column names\n    if 'origin' in flow_df.columns and 'destination' in flow_df.columns:\n        flow_df = flow_df.sort_values(by=['origin', 'destination'])\n    \n    # Save to CSV\n    flow_df.to_csv('optimal_flows.csv', index=False)\n    \n    # Create a summary DataFrame with additional statistics\n    summary_data = [{\n        'metric': 'Total Cost',\n        'value': round(total_cost, 2)\n    }, {\n        'metric': 'Total Flow Units',\n        'value': round(sum(item['flow'] for item in flow_data), 2)\n    }, {\n        'metric': 'Number of Active Routes',\n        'value': len(flow_data)\n    }]\n    \n    summary_df = pd.DataFrame(summary_data)\n    summary_df.to_csv('solution_summary.csv', index=False)\n    \n    print(f\"Solution exported to 'optimal_flows.csv' and 'solution_summary.csv'\")\n    print(f\"Total transportation cost: ${total_cost:.2f}\")\n    print()\n    print(summary_df)\n\nSolution exported to 'optimal_flows.csv' and 'solution_summary.csv'\nTotal transportation cost: $22.23\n\n                    metric  value\n0               Total Cost  22.23\n1         Total Flow Units  90.00\n2  Number of Active Routes   6.00\n\n\nThis code:\n\nCreates a structured dataset with all key information for each\nflow\nExports the detailed flows to ‘optimal_flows.csv’\nCreates a separate summary file with key metrics\nWorks with any network structure (not specific to the oil transport\nproblem)\nPreserves the total cost calculation from the original code\n\nYou can easily adapt this by:\n\nChanging the column names if needed\nAdding more metrics to the summary file\nModifying the rounding precision\nAdding more details to each flow record\n\nThe CSV output will have a clean, tabular structure that can be\nopened in Excel or other tools for further analysis or\nvisualization.",
    "crumbs": [
      "Learning Modules",
      "06 | Minimum Cost Network Flow Models"
    ]
  },
  {
    "objectID": "learning-modules/06-minimum-cost-network-flow-modeling.html#references-and-resources",
    "href": "learning-modules/06-minimum-cost-network-flow-modeling.html#references-and-resources",
    "title": "06 | Minimum Cost Network Flow Models",
    "section": "6\nReferences and Resources",
    "text": "6\nReferences and Resources\n\nHillier & Lieberman, “Introduction to Operations Research,”\nChapter 9\nThe Gurobi\nModeling Examples repository",
    "crumbs": [
      "Learning Modules",
      "06 | Minimum Cost Network Flow Models"
    ]
  },
  {
    "objectID": "learning-modules/06-minimum-cost-network-flow-modeling.html#exercises",
    "href": "learning-modules/06-minimum-cost-network-flow-modeling.html#exercises",
    "title": "06 | Minimum Cost Network Flow Models",
    "section": "7\nExercises",
    "text": "7\nExercises\n\n7.1\nSimple Network Flow Problem\nA shipping company needs to transport goods from two origins (O1, O2)\nto three destinations (D1, D2, D3). The shipping costs (in $ per unit)\nand supply/demand quantities are shown below:\nSupply and Demand:\n\nOrigin O1 has 150 units available\nOrigin O2 has 250 units available\nDestination D1 requires 100 units\nDestination D2 requires 200 units\nDestination D3 requires 100 units\n\nShipping Costs:\n\n\n\nFrom\nTo\nCost per unit\n\n\n\n\nO1\nD1\n$5\n\n\nO1\nD2\n$3\n\n\nO1\nD3\n$6\n\n\nO2\nD1\n$4\n\n\nO2\nD2\n$6\n\n\nO2\nD3\n$2\n\n\n\nFormulate and solve this minimum cost network flow problem.\n\n7.1.1\nSolution\nThe solution demonstrates how to model and solve a basic\ntransportation problem using Gurobi. The key components include:\n\nSetting up the network structure with origins (O1, O2) and\ndestinations (D1, D2, D3)\nDefining supply and demand quantities at each node\nCreating shipping costs between each origin-destination pair\nFormulating flow conservation constraints for all nodes\nSolving the model to find the minimum cost solution\n\n\n\nCode\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport pandas as pd\n\n# Define the nodes in our network\norigins = ['O1', 'O2']\ndestinations = ['D1', 'D2', 'D3']\nnodes = origins + destinations\n\n# Define supply/demand at each node\nsupply_demand = {\n    'O1':  150,  # Origin 1 supplies 150 units\n    'O2':  250,  # Origin 2 supplies 250 units\n    'D1': -100,  # Destination 1 demands 100 units\n    'D2': -200,  # Destination 2 demands 200 units\n    'D3': -100   # Destination 3 demands 100 units\n}\n\n# Define shipping costs\nshipping_costs = {\n    ('O1', 'D1'): 5,\n    ('O1', 'D2'): 3,\n    ('O1', 'D3'): 6,\n    ('O2', 'D1'): 4,\n    ('O2', 'D2'): 6,\n    ('O2', 'D3'): 2\n}\n\n# Define arcs with (cost, capacity)\narcs = {}\nfor (origin, dest), cost in shipping_costs.items():\n    arcs[(origin, dest)] = (cost, float('inf'))  # All routes have unlimited capacity initially\n\n# Create a new Gurobi model\nmodel = gp.Model(\"SimpleTransportationProblem\")\nmodel.Params.LogToConsole = 0\n\n# Create flow variables for each arc\nflow = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow[(i, j)] = model.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints\nfor i in nodes:\n    # Sum of flows leaving node i\n    outflow = gp.quicksum(flow[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of flows entering node i\n    inflow = gp.quicksum(flow[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Set objective to minimize total cost\nmodel.ModelSense = GRB.MINIMIZE\n\n# Solve the model\nmodel.optimize()\n\n# Extract the solution\nflow_values = {}\ntotal_cost = 0\n\nfor (i, j), var in flow.items():\n    flow_amount = var.X\n    \n    # Only include arcs with positive flow\n    if flow_amount &gt; 0.001:\n        flow_values[(i, j)] = flow_amount\n        \n        # Add to the total cost\n        cost = arcs[(i, j)][0]\n        total_cost += flow_amount * cost\n\nprint(\"\\nOptimal shipping plan:\")\nfor (origin, dest), amount in sorted(flow_values.items()):\n    cost = arcs[(origin, dest)][0]\n    print(f\"{origin} → {dest}: {amount:.1f} units (cost: ${cost}/unit, total: ${amount*cost:.1f})\")\n\nprint(f\"\\nTotal transportation cost: ${total_cost:.1f}\")\n\n# Export results to CSV (as requested)\nflow_data = []\nfor (i, j), amount in flow_values.items():\n    cost = arcs[(i, j)][0]\n    flow_data.append({\n        'origin': i,\n        'destination': j,\n        'flow': round(amount, 1),\n        'cost_per_unit': cost,\n        'total_cost': round(amount * cost, 1)\n    })\n\nflow_df = pd.DataFrame(flow_data)\nflow_df.to_csv('exercise1_solution.csv', index=False)\nprint()\nprint(flow_df)\n\n\nSet parameter LogToConsole to value 0\n\nOptimal shipping plan:\nO1 → D2: 150.0 units (cost: $3/unit, total: $450.0)\nO2 → D1: 100.0 units (cost: $4/unit, total: $400.0)\nO2 → D2: 50.0 units (cost: $6/unit, total: $300.0)\nO2 → D3: 100.0 units (cost: $2/unit, total: $200.0)\n\nTotal transportation cost: $1350.0\n\n  origin destination   flow  cost_per_unit  total_cost\n0     O1          D2  150.0              3       450.0\n1     O2          D1  100.0              4       400.0\n2     O2          D2   50.0              6       300.0\n3     O2          D3  100.0              2       200.0\n\n\nThe optimal solution shows how to allocate shipments to minimize the\ntotal transportation cost. In the optimal solution, we typically see\nthat cheaper routes are preferred (like O1→D2 with cost $3/unit) over\nmore expensive alternatives. The CSV export functionality demonstrates\nhow to save results for further analysis.\nIf you’ve noticed by now, a lot of the Python code is cookie-cutter\nonce you create the initial setup.\n\n\n\n7.2\nNetwork with Capacity Constraints\nExtend Exercise 1 by adding the following capacity constraints:\n\nThe route from O1 to D2 can handle at most 80 units\nThe route from O2 to D3 can handle at most 60 units\n\nAnswer the following:\n\nHow do these constraints change the optimal solution?\nWhich routes are now at capacity?\nHow much does the total cost increase due to these constraints?\n\n\n7.2.1\nSolution\nThis solution extends Exercise 1 by adding capacity constraints on\nspecific routes:\n\nO1 to D2: maximum 80 units\nO2 to D3: maximum 60 units\n\nThe solution approach:\n\nSolves both the unconstrained and constrained versions of the\nproblem\nCompares the solutions to understand the impact of capacity\nconstraints\nIdentifies which routes are at capacity in the optimal solution\nCalculates the cost increase due to the constraints\n\n\n# Define capacity constraints\ncapacity_constraints = {\n    ('O1', 'D2'): 80,   # Route from O1 to D2 has max capacity of 80 units\n    ('O2', 'D3'): 60    # Route from O2 to D3 has max capacity of 60 units\n}\n\n# Update arcs with capacity constraints\nfor (origin, dest) in capacity_constraints:\n    cost = arcs[(origin, dest)][0]\n    arcs[(origin, dest)] = (cost, capacity_constraints[(origin, dest)])\n\n    # Create a new Gurobi model\nmodel_constrained = gp.Model(\"CapacitatedTransportationProblem\")\nmodel_constrained.Params.LogToConsole = 0\n\n# Create flow variables for each arc\nflow_constrained = {}\nfor (i, j), (cost, _) in arcs.items():\n    flow_constrained[(i, j)] = model_constrained.addVar(name=f'flow_{i}_{j}', obj=cost)\n\n# Add flow conservation constraints\nfor i in nodes:\n    # Sum of flows leaving node i\n    outflow = gp.quicksum(flow_constrained[(i, j)] for (i2, j) in arcs.keys() if i2 == i)\n    \n    # Sum of flows entering node i\n    inflow = gp.quicksum(flow_constrained[(j, i)] for (j, i2) in arcs.keys() if i2 == i)\n    \n    # Outflow - inflow = supply/demand\n    model_constrained.addConstr(outflow - inflow == supply_demand[i], name=f'node_{i}')\n\n# Add capacity constraints\nfor (i, j), (_, capacity) in arcs.items():\n    if capacity &lt; float('inf'):\n        model_constrained.addConstr(flow_constrained[(i, j)] &lt;= capacity, name=f'capacity_{i}_{j}')\n\n# Set objective to minimize total cost\nmodel_constrained.ModelSense = GRB.MINIMIZE\n\n# Solve the model\nmodel_constrained.optimize()\n\n# Extract the solution\nflow_values_constrained = {}\ntotal_cost_constrained = 0\n\nfor (i, j), var in flow_constrained.items():\n    flow_amount = var.X\n    \n    # Only include arcs with positive flow\n    if flow_amount &gt; 0.001:\n        flow_values_constrained[(i, j)] = flow_amount\n        \n        # Add to the total cost\n        cost = arcs[(i, j)][0]\n        total_cost_constrained += flow_amount * cost\n\nprint(\"\\nConstrained Solution:\")\nprint(\"-\" * 30)\n\nfor (origin, dest), amount in sorted(flow_values_constrained.items()):\n    cost = arcs[(origin, dest)][0]\n    capacity = arcs[(origin, dest)][1]\n    \n    capacity_info = \"\"\n    if capacity &lt; float('inf') and abs(amount - capacity) &lt; 0.1:\n        capacity_info = \" (AT CAPACITY)\"\n    \n    print(f\"{origin} → {dest}: {amount:.1f} units (cost: ${cost}/unit, total: ${amount*cost:.1f}){capacity_info}\")\n\nprint(f\"\\nTotal transportation cost: ${total_cost_constrained:.1f}\")\n\n# Calculate cost difference\ncost_difference = total_cost_constrained - total_cost # from ex 1 solution\npercentage_increase = (cost_difference / total_cost) * 100\n\nprint(\"\\nCost Comparison:\")\nprint(f\"Cost increase due to capacity constraints: ${cost_difference:.1f} ({percentage_increase:.1f}%)\")\n\n# Export results to CSV\nflow_data = []\n\n# Add unconstrained solution data\nfor (i, j), amount in flow_values.items():\n    cost = arcs[(i, j)][0]\n    capacity = arcs[(i, j)][1]\n    at_capacity = \"Yes\" if capacity &lt; float('inf') and abs(amount - capacity) &lt; 0.1 else \"No\"\n    \n    flow_data.append({\n        'scenario': \"Unconstrained\",\n        'origin': i,\n        'destination': j,\n        'flow': round(amount, 1),\n        'cost_per_unit': cost,\n        'total_cost': round(amount * cost, 1),\n        'capacity': capacity if capacity &lt; float('inf') else \"Unlimited\",\n        'at_capacity': at_capacity\n    })\n\n# Add constrained solution data\nfor (i, j), amount in flow_values_constrained.items():\n    cost = arcs[(i, j)][0]\n    capacity = arcs[(i, j)][1]\n    at_capacity = \"Yes\" if capacity &lt; float('inf') and abs(amount - capacity) &lt; 0.1 else \"No\"\n    \n    flow_data.append({\n        'scenario': \"Constrained\",\n        'origin': i,\n        'destination': j,\n        'flow': round(amount, 1),\n        'cost_per_unit': cost,\n        'total_cost': round(amount * cost, 1),\n        'capacity': capacity if capacity &lt; float('inf') else \"Unlimited\",\n        'at_capacity': at_capacity\n    })\n\nflow_df = pd.DataFrame(flow_data)\nprint(flow_df)\n\nSet parameter LogToConsole to value 0\n\nConstrained Solution:\n------------------------------\nO1 → D1: 30.0 units (cost: $5/unit, total: $150.0)\nO1 → D2: 80.0 units (cost: $3/unit, total: $240.0) (AT CAPACITY)\nO1 → D3: 40.0 units (cost: $6/unit, total: $240.0)\nO2 → D1: 70.0 units (cost: $4/unit, total: $280.0)\nO2 → D2: 120.0 units (cost: $6/unit, total: $720.0)\nO2 → D3: 60.0 units (cost: $2/unit, total: $120.0) (AT CAPACITY)\n\nTotal transportation cost: $1750.0\n\nCost Comparison:\nCost increase due to capacity constraints: $400.0 (29.6%)\n        scenario origin destination   flow  cost_per_unit  total_cost  \\\n0  Unconstrained     O1          D2  150.0              3       450.0   \n1  Unconstrained     O2          D1  100.0              4       400.0   \n2  Unconstrained     O2          D2   50.0              6       300.0   \n3  Unconstrained     O2          D3  100.0              2       200.0   \n4    Constrained     O1          D1   30.0              5       150.0   \n5    Constrained     O1          D2   80.0              3       240.0   \n6    Constrained     O1          D3   40.0              6       240.0   \n7    Constrained     O2          D1   70.0              4       280.0   \n8    Constrained     O2          D2  120.0              6       720.0   \n9    Constrained     O2          D3   60.0              2       120.0   \n\n    capacity at_capacity  \n0         80          No  \n1  Unlimited          No  \n2  Unlimited          No  \n3         60          No  \n4  Unlimited          No  \n5         80         Yes  \n6  Unlimited          No  \n7  Unlimited          No  \n8  Unlimited          No  \n9         60         Yes  \n\n\nThe comparison provides an important real-world insight: limited\nshipping capacity often leads to higher transportation costs as\ncompanies are forced to use less efficient routes. The solution exports\ndetailed results to a CSV file for further analysis, showing both the\nunconstrained and constrained flows side by side.\nThis exercise demonstrates how to implement and analyze capacity\nconstraints in transportation networks, which is a common challenge in\nreal-world supply chain management.",
    "crumbs": [
      "Learning Modules",
      "06 | Minimum Cost Network Flow Models"
    ]
  },
  {
    "objectID": "learning-modules/04-data-structures.html",
    "href": "learning-modules/04-data-structures.html",
    "title": "04 | Strings, Lists, Dictionaries, and Tuples",
    "section": "",
    "text": "In this module, you will learn about Python’s most commonly used\ndata structures: strings,\nlists, dictionaries, and\ntuples. You will also explore how to leverage\nregular expressions to search for patterns in text.\nFinally, you will see examples that combine these structures to solve\nmore advanced tasks, followed by tips for debugging and practice\nexercises.\nWhy are these data structures important?\n\nStrings handle textual data, which is central to\nuser input, file processing, and general communication in software.\nLists store ordered collections, perfect for\ndynamic or changing sets of elements.\nDictionaries map from keys to\nvalues for fast lookups and flexible data storage.\nTuples group multiple items into a single,\nimmutable structure (and can serve as dictionary keys).\nRegular expressions simplify complex text matching\nand replacement tasks.",
    "crumbs": [
      "Learning Modules",
      "04 | Strings, Lists, Dictionaries, and Tuples"
    ]
  },
  {
    "objectID": "learning-modules/04-data-structures.html#overview",
    "href": "learning-modules/04-data-structures.html#overview",
    "title": "04 | Strings, Lists, Dictionaries, and Tuples",
    "section": "",
    "text": "In this module, you will learn about Python’s most commonly used\ndata structures: strings,\nlists, dictionaries, and\ntuples. You will also explore how to leverage\nregular expressions to search for patterns in text.\nFinally, you will see examples that combine these structures to solve\nmore advanced tasks, followed by tips for debugging and practice\nexercises.\nWhy are these data structures important?\n\nStrings handle textual data, which is central to\nuser input, file processing, and general communication in software.\nLists store ordered collections, perfect for\ndynamic or changing sets of elements.\nDictionaries map from keys to\nvalues for fast lookups and flexible data storage.\nTuples group multiple items into a single,\nimmutable structure (and can serve as dictionary keys).\nRegular expressions simplify complex text matching\nand replacement tasks.",
    "crumbs": [
      "Learning Modules",
      "04 | Strings, Lists, Dictionaries, and Tuples"
    ]
  },
  {
    "objectID": "learning-modules/04-data-structures.html#strings",
    "href": "learning-modules/04-data-structures.html#strings",
    "title": "04 | Strings, Lists, Dictionaries, and Tuples",
    "section": "2\nStrings",
    "text": "2\nStrings\nStrings store text and are immutable sequences of\ncharacters. In Python, they form the foundation of almost all\nuser-facing output and file processing.\n\n2.1 A\nstring is a sequence\nA string is a sequence of characters in a specific\norder. A character can be a letter, digit, punctuation mark, or\nwhitespace. You can select any character in a string using the bracket\noperator:\n\nfruit = \"banana\"\nletter = fruit[1]\nletter\n\n'a'\n\n\nThe index in brackets starts at 0, so\nfruit[0] is the first character ('b'),\nfruit[1] is the second character ('a'), and so\non.\n\nfruit[0]\n\n'b'\n\n\nYou can use variables or expressions as indices:\n\ni = 1\nfruit[i+1]  # fruit[2]\n\n'n'\n\n\nIf you use a non-integer index, you get a TypeError. You\ncan use len() to determine a string’s length:\n\nn = len(fruit)  # 6 for \"banana\"\n\nBecause indices start at 0, the last character is at\nposition len(fruit) - 1, which is fruit[n-1].\nAlternatively, negative indices let you count backward:\n\nprint(fruit[-1])  # last character\nprint(fruit[-2])  # second to last\n\na\nn\n\n\nYou can quickly access any position in the string without manual\nloops.\n\n\n2.2\nString slices\nA slice selects a substring by indicating a range of\nindices with [start:end]. It includes the\nstart index but excludes the end.\n\nfruit = 'banana'\nprint(fruit[0:3])  # 'ban'\nprint(fruit[3:6])  # 'ana'\n\nban\nana\n\n\nOmitting start means “from the beginning”, and omitting\nend means “to the end”:\n\nprint(fruit[:3])   # 'ban'\nprint(fruit[3:])   # 'ana'\n\nban\nana\n\n\nIf the first index is greater than or equal to the second, you get an\nempty string. For example, fruit[3:3] returns\n''.\nUse slices to easily extract segments of text, such as prefixes,\nsuffixes, or partial filenames.\n\n\n2.3\nStrings are immutable\nStrings are immutable, so you cannot modify them in\nplace. An assignment like greeting[0] = 'J' causes a\nTypeError. Instead, create a new string:\n\ngreeting = 'Hello, world!'\nnew_greeting = 'J' + greeting[1:]\n\nThis prevents accidental data corruption, making string handling more\npredictable.\n\n\n2.4\nString comparison\nYou can compare strings using relational\noperators:\n\nword = 'banana'\n\nif word == 'banana':\n    print('All right, banana.')\n\nAll right, banana.\n\n\nOther operators let you determine alphabetical ordering:\n\ndef compare_word(word):\n    if word &lt; 'banana':\n        print(word, 'comes before banana.')\n    elif word &gt; 'banana':\n        print(word, 'comes after banana.')\n    else:\n        print('All right, banana.')\n\ncompare_word(\"apple\")\ncompare_word(\"Orange\")\n\napple comes before banana.\nOrange comes before banana.\n\n\nUppercase letters come before lowercase letters in Python’s default\nsort order, so be mindful of case differences. You can convert strings\nto lowercase or uppercase for case-insensitive comparisons.\n\n\n2.5\nString methods\nA method is like a function but follows the\nobject-dot-method syntax. For example:\n\ntext = \"Hello World\"\nprint(text.lower())\nprint(text.upper())\nprint(text.replace(\"Hello\", \"Hi\"))\nprint(text.split())\n\nhello world\nHELLO WORLD\nHi World\n['Hello', 'World']\n\n\nThese help easily perform text transformations for data cleaning or\nuser-facing output.\n\n\n2.6\nRegular expressions\nRegular expressions (regex) help you search for\ncomplex patterns in text. Python’s built-in re module\nprovides powerful tools for matching and manipulating text.\nFor example, you can verify formats (phone numbers, emails), capture\nspecific bits of text, or do advanced replacements.\n\n2.6.1\nA simple search example\n\nimport re\n\ntext = \"Hello, my name is Jane. It's nice to meet you.\"\npattern = 'Jane'\n\nresult = re.search(pattern, text)\nif result:\n    print(\"Found:\", result.group())\nelse:\n    print(\"Not found.\")\n\nFound: Jane\n\n\n\nIf the pattern is found, re.search returns a\nMatch object with .group(),\n.span(), etc.\nIf not found, it returns None.\n\nThis allows very fast pattern matching in large strings, flexible for\npartial matches (e.g., ’Jan[eE]*’ to allow slight variations).\n\n\n2.6.2\nUsing raw strings\nWhen writing regex, prefix patterns with r to create raw\nstrings, which interpret backslashes literally:\n\nnormal_str = \"Hello\\nWorld\"  # \\n is a newline\nraw_str = r\"Hello\\nWorld\"    # keeps the literal \\n\n\nprint(normal_str)\nprint(raw_str)\n\nHello\nWorld\nHello\\nWorld\n\n\nPrefix strings with r to avoid having to escape\nbackslashes, e.g. r\"\\d+\" instead of\n\"\\\\d+\".\n\n\n2.6.3\nSearching in a file\nFor the following examples, we will use this file:\n\nfor line in open('data/sample_text.txt'):\n    print(line)\n\nHello, world!\n\nAlice smiled as she greeted Bob with a cheerful hello.\n\nIn the quiet morning, Bob whispered hello to the sleeping world.\n\nAlice and Bob wandered through a world that seemed to echo with hello.\n\nA simple hello from Alice brightened Bobâ€™s day in an ordinary world.\n\nBob called out, \"Hello, Alice!\" as they explored the world together.\n\nIn a magical world, hello was the key that united Alice and Bob.\n\nAlice thought, \"Hello to a new day in this ever-changing world,\" as Bob nodded.\n\nWith a friendly hello, Bob opened the door to Aliceâ€™s mysterious world.\n\nThe world felt lighter when Alice and Bob exchanged a heartfelt hello.\n\nBob wrote in his journal: \"Today, Alice said hello to the whole world.\"\n\nAmid the busy city, a quiet hello from Alice and Bob brought calm to the world.\n\nIn the realm of dreams, Alice and Bob discovered that every hello sparked wonder in the world.\n\nA warm hello from Bob melted the chill of the early world, as Alice looked on.\n\nAlice and Bob laughed together, their hello echoing through the vibrant world.\n\nWhile strolling through the park, Bobâ€™s spontaneous hello made the world seem friendlier to Alice.\n\nIn a story of friendship, every hello by Alice and every nod from Bob transformed their little world.\n\nThe world listened as Bob said hello, while Alice beamed in response.\n\nUnder the starlight, Alice and Bob shared a soft hello that warmed their world.\n\nA final hello from Alice to Bob closed a day where the world felt wonderfully alive.\n\n\n\nYou might loop over each line in a file and call\nre.search:\n\ndef find_first(pattern, filename='data/sample_text.txt'):\n    import re\n    for line in open(filename):\n        result = re.search(pattern, line)\n        if result is not None:\n            return result\n\nfind_first(\"Hello\")\n\n&lt;re.Match object; span=(0, 5), match='Hello'&gt;\n\n\n\n\n2.6.4\nUsing the “OR” operator (|)\nUse the | symbol for logical OR within a regex. For example, to find\neither “Alice” or “Bob”:\n\npattern = 'Alice|Bob'\nresult = find_first(pattern)\nprint(result)\n\n&lt;re.Match object; span=(0, 5), match='Alice'&gt;\n\n\nYou can also loop through lines, counting matches. For instance:\n\ndef count_matches(pattern, filename='data/sample_text.txt'):\n    import re\n    count = 0\n    for line in open(filename):\n        if re.search(pattern, line) is not None:\n            count += 1\n    return count\n\nmentions = count_matches('Alice|Bob')\nprint(mentions)\n\n19\n\n\n\n\n2.6.5\nMatching start/end of lines\n\n^: start of a line\n$: end of a line\n\n\nfind_first('^Hello')\n\n&lt;re.Match object; span=(0, 5), match='Hello'&gt;\n\n\n\nfind_first('world!$')\n\n&lt;re.Match object; span=(7, 13), match='world!'&gt;\n\n\n\n\n2.6.6\nMore on regex syntax\nRegex includes special metacharacters and quantifiers:\n\n. matches any character (except newline).\n* matches 0 or more of the preceding element.\n+ matches 1 or more of the preceding element.\n? makes the preceding element optional (0 or 1).\n[...] matches any one character in the brackets.\n(...) captures the matched text as a group.\n\\ escapes special characters or denotes special\nsequences like , etc.\n\n\n\n2.6.7\nString substitution\nUse re.sub(pattern, replacement, text) to substitute\nmatches:\n\ntext_line = \"This is the centre of the city.\"\npattern = r'cent(er|re)'\nupdated_line = re.sub(pattern, 'center', text_line)\nprint(updated_line)\n\nThis is the center of the city.\n\n\nThis allows you to clean up strings in powerful ways, such as\nnormalizing different spellings or removing special characters.\nUse re.findall to get all matches, re.split\nto split a string by a regex, and various flags (e.g.,\nre.IGNORECASE) to alter matching behavior.\nRegex is extremely powerful for tasks like extracting email\naddresses, validating formats, or searching logs.",
    "crumbs": [
      "Learning Modules",
      "04 | Strings, Lists, Dictionaries, and Tuples"
    ]
  },
  {
    "objectID": "learning-modules/04-data-structures.html#lists",
    "href": "learning-modules/04-data-structures.html#lists",
    "title": "04 | Strings, Lists, Dictionaries, and Tuples",
    "section": "3\nLists",
    "text": "3\nLists\nLists are mutable sequences that can store elements\nof any type (including other lists). They form the workhorse for many\ndata-processing tasks due to their flexibility.\n\n3.1 A\nlist is a sequence\nA list is a sequence of values (of any type). Create\none with square brackets:\n\nnumbers = [42, 123]\ncheeses = ['Cheddar', 'Edam', 'Gouda']\nmixed = ['spam', 2.0, 5, [10, 20]]  # nested list\nempty = []\n\nlen(cheeses) returns the length of a list. The length of\nan empty list is 0.\n\n\n3.2\nLists are mutable\nUse the bracket operator to read or write an element:\n\nnumbers[1] = 17  # modifies the list\nprint(numbers)\n\n[42, 17]\n\n\nUnlike strings, lists allow you to assign directly to their indices.\nYou can still use negative indices to count backward.\nUse the in operator to check membership:\n\n'Edam' in cheeses\n\nTrue\n\n\n\n\n3.3\nList slices\nLists support slicing with the same [start:end] syntax\nas strings:\n\nletters = ['a', 'b', 'c', 'd']\n\n\nletters[1:3]\n\n['b', 'c']\n\n\n\nletters[:2]\n\n['a', 'b']\n\n\n\nletters[2:]\n\n['c', 'd']\n\n\n\nletters[:] # copy of the list\n\n['a', 'b', 'c', 'd']\n\n\n\n\n3.4\nList operations\n+ concatenates, * repeats:\n\n[1, 2] + [3, 4] \n\n[1, 2, 3, 4]\n\n\n\n['spam'] * 4\n\n['spam', 'spam', 'spam', 'spam']\n\n\n\nsum([1, 2, 3])\n\n6\n\n\n\nmin([3, 1, 4])\n\n1\n\n\n\nmax([3, 1, 4])\n\n4\n\n\n\n\n3.5\nList methods\n\nappend(x) adds an item at the end.\nextend([x, y]) adds multiple items.\npop(index) removes and returns the item at\nindex.\nremove(x) removes the first occurrence of\nx.\n\n\nletters = ['a', 'b', 'c']\n\n\nletters.append('d')      # modifies letters\nprint(letters)\n\n['a', 'b', 'c', 'd']\n\n\n\nletters.extend(['e', 'f'])\nprint(letters)\n\n['a', 'b', 'c', 'd', 'e', 'f']\n\n\n\nletters.pop(1)           # removes 'b'\nprint(letters)\n\n['a', 'c', 'd', 'e', 'f']\n\n\n\nletters.remove('e')      # removes 'e'\nprint(letters)\n\n['a', 'c', 'd', 'f']\n\n\nThese list methods help manage growing or shrinking lists without\nextra variables.\n\nList methods often modify a list in place and return\nNone. This can confuse people who expect them to behave\nlike string methods. For instance:\n\nt = [1, 2, 3]\nt = t.remove(3)  # WRONG!\n\nprint(t)\n# Expect: [1, 2]\n# Return: None\n\nNone\n\n\nremove(3) modifies t and returns\nNone, so assigning it back to t loses the\noriginal list. If you see an error like\nNoneType object has no attribute 'remove', check whether\nyou accidentally assigned a list method’s return value to the list.\nFor the example above, you would do this:\n\nt = [1, 2, 3]\nt.remove(3)  # CORRECT!\n\nprint(t)\n\n[1, 2]\n\n\n\n\n3.6\nLists and strings\na list of characters is not the same as a\nstring. To convert a string to a list of characters,\nuse list():\n\ns = 'coal'\nt = list(s)\nprint(t)\n\n['c', 'o', 'a', 'l']\n\n\nTo split a string by whitespace into a list of words:\n\ns = \"The children yearn for the mines\"\nwords = s.split()\nprint(words)\n\n['The', 'children', 'yearn', 'for', 'the', 'mines']\n\n\nYou can specify a delimiter for split, and you can use\n''.join(list_of_strings) to rebuild a single string from a\nlist. These are useful for text tokenization, splitting logs, or\nreconstructing messages.\n\n\n3.7\nLooping through a list\na for loop iterates over each element:\n\nfor cheese in cheeses:\n    print(cheese)\n\nCheddar\nEdam\nGouda\n\n\n\n\n3.8\nSorting lists\nUse sorted() to return a new sorted list without\nmodifying the original:\n\nscrambled_list = [\"c\", \"a\", \"b\"]\nsorted_list = sorted(scrambled_list)\n\nprint(sorted_list)\nprint(scrambled_list)\n\n['a', 'b', 'c']\n['c', 'a', 'b']\n\n\nsorted('letters') returns a list of characters. Combine\nwith \"\".join() to build a sorted string:\n\n\"\".join(sorted('letters'))\n\n'eelrstt'\n\n\n\n\n3.9\nObjects and values\nVariables can refer to the same object or different\nobjects that have the same value. For example:\n\na = 'banana'\nb = 'banana'\na is b  # often True (same object)\n\nTrue\n\n\nIn this example, Python only created one string object, and both\na and b refer to it. But when you create two\nlists, you get two objects.\n\nx = [1, 2, 3]\ny = [1, 2, 3]\nx is y  # False (different objects)\n\nFalse\n\n\nIn this case we would say that the two lists are\nequivalent, because they have the same elements, but\nnot identical, because they are not the same object. If\ntwo objects are identical, they are also equivalent, but if they are\nequivalent, they are not necessarily identical.\n\n\n3.10\nAliasing\nWhen you assign one variable to another, both variables\nreference the same object:\n\na = [1, 2, 3]\nb = a\nb is a\n\nTrue\n\n\nIf an object is mutable, changes made via one variable affect the\nother:\n\nprint(a)\nb[0] = 5\nprint(a)\n\n[1, 2, 3]\n[5, 2, 3]\n\n\nAvoid aliasing unless it’s intentional.\n\n\n3.11\nList arguments\nWhen you pass a list to a function, you pass a reference to that\nlist. The function can modify the original list:\n\ndef pop_first(lst):\n    return lst.pop(0)\n\nletters = ['a', 'b', 'c']\npop_first(letters)\nprint(letters)\n\n['b', 'c']\n\n\nIf you do not want a function to modify the original list, pass a\ncopy:\n\npop_first(list(letters))  # or pop_first(letters[:])\n\n'b'",
    "crumbs": [
      "Learning Modules",
      "04 | Strings, Lists, Dictionaries, and Tuples"
    ]
  },
  {
    "objectID": "learning-modules/04-data-structures.html#dictionaries",
    "href": "learning-modules/04-data-structures.html#dictionaries",
    "title": "04 | Strings, Lists, Dictionaries, and Tuples",
    "section": "4\nDictionaries",
    "text": "4\nDictionaries\nA dictionary maps keys to values and offers very\nfast lookups. Keys must be immutable, while values can be\nanything (including lists).\n\n4.1 A\ndictionary is a mapping\nInstead of using integer indices, a dictionary can use almost any\nhashable type as a key. You create a\ndictionary with curly braces:\n\nnumbers = {}\nnumbers['zero'] = 0\nnumbers['one'] = 1\nnumbers\n\n{'zero': 0, 'one': 1}\n\n\nAccess a value using its key:\n\nnumbers['one']\n\n1\n\n\nDictionary keys must be unique and immutable. Lists cannot serve as\nkeys because they are mutable. These are useful for fast lookup by label\n(e.g., “user_id” -&gt; user info) instead of by integer position.\n\n\n4.2\nCreating dictionaries\nYou can create a dictionary all at once:\n\nnumbers = {'zero': 0, 'one': 1, 'two': 2}\n\nor use dict():\n\nnumbers_copy = dict(numbers)\nprint(numbers_copy)\n\nempty = dict()\nprint(empty)\n\n{'zero': 0, 'one': 1, 'two': 2}\n{}\n\n\n\n\n4.3 The\nin operator\nin checks for keys in the dictionary for membership\nwithout searching through all entries:\n\n'one' in numbers\n\nTrue\n\n\n\n'three' in numbers\n\nFalse\n\n\nTo check if something appears as a value, use\nnumbers.values():\n\n1 in numbers.values()\n\nTrue\n\n\n\n\n4.4\nCounting with dictionaries\nUse a dictionary to count how often each character appears in a\nstring:\n\ndef value_counts(string):\n    counter = {}\n    for letter in string:\n        if letter not in counter:\n            counter[letter] = 1\n        else:\n            counter[letter] += 1\n    return counter\n\nvalue_counts('brontosaurus')\n\n{'b': 1, 'r': 2, 'o': 2, 'n': 1, 't': 1, 's': 2, 'a': 1, 'u': 2}\n\n\n\n\n4.5\nLooping with dictionaries\nWhen you loop over a dictionary, you traverse its keys:\n\ncounter = value_counts('banana')\n\n\nfor key in counter:\n    print(key)\n\nb\na\nn\n\n\nUse counter.values() to loop over values:\n\nfor value in counter.values():\n    print(value)\n\n1\n3\n2\n\n\nOr you can use the bracket operator to get the key and value:\n\nfor key in counter:\n    print(key, counter[key])\n\nb 1\na 3\nn 2\n\n\nThis method searches the counter dictionary in every\nloop, and we will see more efficient version of this loop in the tuples\nsection.\n\n\n4.6\nLists and dictionaries\nA dictionary’s values can be lists (or other\ndictionaries), but keys must be hashable:\n\nd = {\n    \"fruits\": [\"apple\", \"banana\", \"cherry\"],\n    \"numbers\": [10, 20, 30],\n    \"colors\": {\n        \"red\": [True, False, True],\n        \"yellow\": [True, True, False],\n        \"green\": [True, False, False]\n    }\n}\n\nprint(d)\n\n{'fruits': ['apple', 'banana', 'cherry'], 'numbers': [10, 20, 30], 'colors': {'red': [True, False, True], 'yellow': [True, True, False], 'green': [True, False, False]}}\n\n\nThis allows you to combine structures for more complex data\nrepresentations, such as JSON-like objects. You cannot use a\nlist as a key. Python uses a hash table for\nquick lookups, and hash values must not change.",
    "crumbs": [
      "Learning Modules",
      "04 | Strings, Lists, Dictionaries, and Tuples"
    ]
  },
  {
    "objectID": "learning-modules/04-data-structures.html#tuples",
    "href": "learning-modules/04-data-structures.html#tuples",
    "title": "04 | Strings, Lists, Dictionaries, and Tuples",
    "section": "5\nTuples",
    "text": "5\nTuples\nTuples are immutable sequences that can hold multiple items. They’re\noften used where immutability is helpful (e.g., as dictionary keys).\n\n5.1\nTuples are sequences\nTuples work like lists but cannot be modified once created. You\ncreate a tuple with comma-separated values, usually enclosed in\nparentheses:\n\nt = ('l', 'u', 'p', 'i', 'n')\nt_2 = 'l', 'u', 'p', 'i', 'n'\n\nprint(type(t))\nprint(type(t_2))\n\n&lt;class 'tuple'&gt;\n&lt;class 'tuple'&gt;\n\n\nYou can create a single element tuple:\n\nt_single = \"a\",\nprint(t_single)\n\n('a',)\n\n\nWrapping a single element with parenthesis does not make a\nsingle-element tuple:\n\nt_single_bad = (\"a\")\nprint(t_single_bad)\nprint(type(t_single_bad))\n\na\n&lt;class 'str'&gt;\n\n\n\n\n5.2\nTuples are immutable\nLike strings, tuples are immutable. Attempting to\nmodify a tuple directly causes an error. Tuples do not have list-like\nmethods such as append or remove.\n\nt[0] = \"L\"\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[68], line 1\n----&gt; 1 t[0] = \"L\"\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nBecause they are immutable, tuples are hashable and\ncan serve as keys in a dictionary:\n\ncoords = {}\ncoords[(1, 2)] = \"Location A\"\ncoords[(3, 4)] = \"Location B\"\nprint(coords)\n\n{(1, 2): 'Location A', (3, 4): 'Location B'}\n\n\nYou cannot alter tuple contents after creation.\n\n\n5.3\nTuple assignment\nYou can assign multiple variables at once with tuple unpacking:\n\na, b = 1, 2 # could also use: (a, b) = (1, 2) or any combo of parenthesis\nprint(a, b)\n\n1 2\n\n\nIf the right side has the wrong number of values, Python raises a\nValueError.\n\na, b = 1, 2, 3\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[71], line 1\n----&gt; 1 a, b = 1, 2, 3\n\nValueError: too many values to unpack (expected 2)\n\n\n\nYou can also swap variables in one line. This allows you to swap\nvariables without an extra temporary variable and return multiple values\nelegantly:\n\nprint(a, b)\na, b = b, a # swap\nprint(a, b)\n\n1 2\n2 1\n\n\nYou often use tuple assignment to iterate over\n(key, value) pairs from a dictionary:\n\nd = {'one': 1, 'two': 2, 'three': 3}\n\nfor item in d.items():\n    key, value = item\n    print(key, '-&gt;', value)\n\none -&gt; 1\ntwo -&gt; 2\nthree -&gt; 3\n\n\nEach time through the loop, item is assigned a tuple\nthat contains a key and the corresponding value.\nWe can write this loop more concisely, like this:\n\nfor key, value in d.items():\n    print(key, '-&gt;', value)\n\none -&gt; 1\ntwo -&gt; 2\nthree -&gt; 3\n\n\n\n\n5.4\nTuples as return values\nA function can return a single tuple, effectively returning multiple\nvalues:\n\ndef min_max(t):\n    return min(t), max(t) # could also write: (min(t), max(t))\n\nlow, high = min_max([2, 4, 1, 3])\nprint(low, high)\n\n1 4\n\n\nThis offers a clean way to return more than one piece of information\nfrom a function.\n\n\n5.5\nArgument packing and unpacking\nIf a function parameter starts with *, Python\npacks extra arguments into a tuple:\n\ndef mean(*args):\n    return sum(args) / len(args)\n\nmean(1, 2, 3)\n\n2.0\n\n\nHere is an example you are already familiar with,\nprint:\ndef print(*args, sep=' ', end='\\n', file=None, flush=False):\n    \"\"\"print code\"\"\"\n\nprint(1, 2, 3, sep=\", \")\n\n1, 2, 3\n\n\nYou can unpack a sequence by using *\nwhen calling a function:\n\ndivmod(*[7, 3])  # same as divmod(7, 3)\n\n(2, 1)\n\n\nConsider a function that calculates a “trimmed” mean by removing the\nlowest and highest values:\n\ndef trimmed_mean(*args):\n    low, high = min_max(args)\n    trimmed = list(args)\n    trimmed.remove(low)\n    trimmed.remove(high)\n    return mean(*trimmed)\n\ntrimmed_mean(1, 2, 3, 4, 5)\n\n3.0\n\n\nWhile this is a bit more advanced than we will need for this course,\nit allows flexible argument passing and returning, which helps build\nutility functions that accept varying numbers of inputs.\n\n\n5.6\nZip\nThe built-in zip function pairs up corresponding\nelements from multiple sequences:\n\nscores1 = [1, 2, 4, 5, 1, 5, 2]\nscores2 = [5, 5, 2, 5, 5, 2, 3]\n\nfor s1, s2 in zip(scores1, scores2):\n    if s1 &gt; s2:\n        print(\"Team1 wins this game!\")\n    elif s1 &lt; s2:\n        print(\"Team2 wins this game!\")\n    else:\n        print(\"It's a tie!\")\n\nTeam2 wins this game!\nTeam2 wins this game!\nTeam1 wins this game!\nIt's a tie!\nTeam2 wins this game!\nTeam1 wins this game!\nTeam2 wins this game!\n\n\nlist(zip(a, b)) returns a list of tuples. You can also\ncombine zip with dict to create dictionaries\nfrom two parallel lists:\n\nletters = 'abc'\nnumbers = [0, 1, 2]\ndict(zip(letters, numbers)) # try list(zip(letters, numbers)) on your own\n\n{'a': 0, 'b': 1, 'c': 2}\n\n\nUse enumerate to loop over the indices and elements of a\nsequence at the same time:\n\nfor index, element in enumerate('abcefghijk'):\n    print(index, element)\n\n0 a\n1 b\n2 c\n3 e\n4 f\n5 g\n6 h\n7 i\n8 j\n9 k\n\n\nTo see the values enumerate creates, you need to turn\nthe enumerate object into either a list, tuple, or\ndictionary:\n\nenumerate('abcefghijk')\n\n&lt;enumerate at 0x2488a161df0&gt;\n\n\n\nlist(enumerate('abcefghijk'))\n\n[(0, 'a'),\n (1, 'b'),\n (2, 'c'),\n (3, 'e'),\n (4, 'f'),\n (5, 'g'),\n (6, 'h'),\n (7, 'i'),\n (8, 'j'),\n (9, 'k')]\n\n\n\ntuple(enumerate('abcefghijk'))\n\n((0, 'a'),\n (1, 'b'),\n (2, 'c'),\n (3, 'e'),\n (4, 'f'),\n (5, 'g'),\n (6, 'h'),\n (7, 'i'),\n (8, 'j'),\n (9, 'k'))\n\n\n\ndict(enumerate('abcefghijk'))\n\n{0: 'a',\n 1: 'b',\n 2: 'c',\n 3: 'e',\n 4: 'f',\n 5: 'g',\n 6: 'h',\n 7: 'i',\n 8: 'j',\n 9: 'k'}\n\n\nThis is true for many Python functions that create objects, so\nremember to experiment with new code.\n\n\n5.7\nInverting a dictionary\nTo invert a dictionary that maps a key to a value, you might need to\nmap each value to a list of keys (because multiple keys can share the\nsame value). For example:\n\ndef invert_dict(d):\n    new_d = {}\n    for key, val in d.items():\n        if val not in new_d:\n            new_d[val] = [key]\n        else:\n            new_d[val].append(key)\n    return new_d\n\nThis is useful for reverse lookups when multiple keys share the same\nvalue:\n\ncounts = {\n    \"a\": 1,\n    \"b\": 23,\n    \"c\": 1,\n    \"d\": 4,\n    \"e\": 4\n}\n\ninvert_dict(counts)\n\n{1: ['a', 'c'], 23: ['b'], 4: ['d', 'e']}\n\n\n\n\n5.8\nDictionaries with tuple keys\nTuples are hashable, so we can use them as dictionary keys:\n\nlocations = {}\nlocations[(1, 2)] = \"Start\"\nlocations[(3, 4)] = \"Goal\"\nprint(locations[(3, 4)]) \n\nGoal\n\n\nThis could be useful for coordinate-based lookups (e.g., board games\nor grid-based apps).",
    "crumbs": [
      "Learning Modules",
      "04 | Strings, Lists, Dictionaries, and Tuples"
    ]
  },
  {
    "objectID": "learning-modules/04-data-structures.html#exercises",
    "href": "learning-modules/04-data-structures.html#exercises",
    "title": "04 | Strings, Lists, Dictionaries, and Tuples",
    "section": "6\nExercises",
    "text": "6\nExercises\n\n6.1\nChecking for a word in a sentence\nWrite a program that checks if the word \"apple\" appears\nin the sentence\n“I bought some apples and oranges at the market.\" Print\n\"Found\" or \"Not Found\" accordingly. Consider\nusing re.search() with a pattern allowing an optional\ns.\n\n\n6.2\nFinding phone numbers with different formats\nGiven:\n\ntext = \"\"\"\nCall me at 123-456-7890 or at (123) 456-7890.\nAlternatively, reach me at 123.456.7890.\n\"\"\"\n\nWrite a single regex that matches all three phone formats. Use\nre.findall() to capture them.\n\n\n6.3\nExtracting captured groups\nFor a product catalog:\n\ncatalog = \"\"\"Product ID: ABC-123 Price: $29.99\nProduct ID: XY-999 Price: $199.95\nProduct ID: TT-100 Price: $10.50\nProduct ID: ZZ-777 Price: $777.00\nProduct ID: FF-333 Price: $2.99\n\"\"\"\n\nWrite a regex that captures (ProductID, Price) as\ngroups. Use re.findall() to produce a list of tuples.\n\n\n6.4\nAnagrams\nTwo words are anagrams if one can be rearranged to form the other.\nWrite is_anagram that returns True if two\nstrings are anagrams. Then find all anagrams of \"takes\" in\na given word list.\n\n\n6.5\nPalindromes\nA palindrome reads the same forward and backward. Write\nis_palindrome that checks if a string is a palindrome. Use\nreversed or slice notation to reverse strings.\n\n\n6.6\nUsing get in a dictionary\nRewrite the value_counts function to eliminate the\nif statement by using\ndict.get(key, default).\n\n\n6.7\nLongest word with all unique letters\nWrite has_duplicates(sequence) that returns\nTrue if any element appears more than once. Test it to see\nif you can find a word longer than \"unpredictably\" with all\nunique letters.\n\n\n6.8\nFinding repeats\nWrite find_repeats(counter) that takes a dictionary\nmapping from keys to counts and returns a list of keys appearing more\nthan once.\n\n\n6.9\nMost frequent letters\nWrite most_frequent_letters(string) that prints letters\nin decreasing order of frequency. You can use\nreversed(sorted(...)) or\nsorted(..., reverse=True).",
    "crumbs": [
      "Learning Modules",
      "04 | Strings, Lists, Dictionaries, and Tuples"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html",
    "href": "learning-modules/02-intro-to-python.html",
    "title": "02 | Intro to Python",
    "section": "",
    "text": "This module covers the Python basics you need for this course. It\nisn’t an exhaustive guide to Python, but it’s enough for anyone with\nprevious coding experience (see Prerequisite Course(s)).\nYou will learn how Python represents numbers, letters, and words,\nfollowed by arithmetic operations. We’ll also build important\nprogramming vocabulary. I won’t test you on these terms, but you’ll need\nthem for future lessons.\nNext, we’ll learn about variables, statements, the\nimport statement, and the print() function.\nWe’ll also discuss function arguments and Python modules.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#overview",
    "href": "learning-modules/02-intro-to-python.html#overview",
    "title": "02 | Intro to Python",
    "section": "",
    "text": "This module covers the Python basics you need for this course. It\nisn’t an exhaustive guide to Python, but it’s enough for anyone with\nprevious coding experience (see Prerequisite Course(s)).\nYou will learn how Python represents numbers, letters, and words,\nfollowed by arithmetic operations. We’ll also build important\nprogramming vocabulary. I won’t test you on these terms, but you’ll need\nthem for future lessons.\nNext, we’ll learn about variables, statements, the\nimport statement, and the print() function.\nWe’ll also discuss function arguments and Python modules.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#arithmetic-operators",
    "href": "learning-modules/02-intro-to-python.html#arithmetic-operators",
    "title": "02 | Intro to Python",
    "section": "2\nArithmetic operators",
    "text": "2\nArithmetic operators\nAn arithmetic operator is a symbol that represents a\ncomputation. For example:\n\n+ performs addition:\n\n\n2000 + 25\n\n2025\n\n\n\n- performs subtraction:\n\n\n2030 - 5\n\n2025\n\n\n\n* performs multiplication:\n\n\n405 * 25\n\n10125\n\n\n\n/ performs division:\n\n\n10125 / 5\n\n2025.0\n\n\nNotice that the result of division is 42.0 vs\n42. Python recognizes two numeric types:\n\nintegers: numbers without a decimal part\nfloating-point numbers (float): numbers with a\ndecimal point (including integer-like values stored in floating\nform)\n\nIf you add, subtract, or multiply two integers, the result remains an\ninteger. However, dividing two integers produces a floating-point\nresult.\nPython also supports integer division with the\noperator //, which always return an integer:\n\n4050 // 2\n\n2025\n\n\nThis operator is called “floor division” because it always rounds\ndown:\n\n4051 // 2\n\n2025\n\n\nThe modulus operator % returns the\nremainder after dividing two numbers:\n\n4051 % 2 # remainder is 1\n\n1\n\n\nIf a number divides evenly, % returns\n0:\n\n4050 % 2 # remainder is 0\n\n0\n\n\nFinally, ** performs exponentiation (raising a number to\na power):\n\n4.58442641 ** 5\n\n2025.0000056375889\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn other languages, like R, you use the caret\n^ for exponentiation, but in Python ^ is the\n“XOR” operator, which we won’t cover here.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#expressions",
    "href": "learning-modules/02-intro-to-python.html#expressions",
    "title": "02 | Intro to Python",
    "section": "3\nExpressions",
    "text": "3\nExpressions\nAn expression is a combination of operators and\nvalues:\n\n6 + 6 ** 2\n\n42\n\n\nPython follows standard order of operations:\n\n12 + 5 *6\n\n42\n\n\nUse parentheses to change that order:\n\n(12 + 5) * 6\n\n102\n\n\nEvery expression evaluates to a value, so\n6 * 7 becomes 42.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#arithmetic-functions",
    "href": "learning-modules/02-intro-to-python.html#arithmetic-functions",
    "title": "02 | Intro to Python",
    "section": "4\nArithmetic functions",
    "text": "4\nArithmetic functions\nPython provides functions that work with numbers,\nsuch as:\n\nround() rounds a float to the nearest integer:\n\n\nround(4.58442641 ** 5)\n\n2025\n\n\n\nabs() returns the absolute value\n\n\nabs(-2025)\n\n2025\n\n\nWhen you call a function, you must use parentheses.\nOmitting them causes a syntax error:\n\nabs 42 # correct usage: abs(42)\n\n\n  Cell In[15], line 1\n    abs 42 # correct usage: abs(42)\n        ^\nSyntaxError: invalid syntax\n\n\n\n\nIf you type only the function name:\n\nabs\n\n&lt;function abs(x, /)&gt;\n\n\nPython tells you that abs is indeed a function, along\nwith some extra details.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#strings",
    "href": "learning-modules/02-intro-to-python.html#strings",
    "title": "02 | Intro to Python",
    "section": "5\nStrings",
    "text": "5\nStrings\nA string is a sequence of characters. You can\nenclose them in single or double quotes:\n\nprint('Hello')\nprint(\"World\")\n\nHello\nWorld\n\n\nUse double quotes if you need an apostrophe, or single quotes if you\nneed a double quote:\n\nprint(\"That's her book\")\nprint('\"I see,\" he said')\n\nThat's her book\n\"I see,\" he said\n\n\n\n\n\n\n\n\nTip\n\n\n\nPython treats single and double quotes the same; you can choose\neither as long as you’re consistent.\n\n\nTriple-quoted strings can span multiple lines or\ncontain both single and double quotes:\n\nprint('''\"That's great\", she said.''')\n\nprint(\"\"\"\nTo be,\nor not to be,\nthat is definitely a question.\n\"\"\")\n\n\"That's great\", she said.\n\nTo be,\nor not to be,\nthat is definitely a question.\n\n\n\nStrings can hold spaces, punctuation, and digits:\n\nprint(\"How the turn tables... uhh wait. What was line 5?\")\n\nHow the turn tables... uhh wait. What was line 5?\n\n\nUse the + operator to concatenate\n(join) strings:\n\nprint('Well, ' + \"it's a small \" + 'world.')\n\nWell, it's a small world.\n\n\nUse the * operator to repeat strings:\n\nprint('RA' + 'TA' * 3)\n\nRATATATA\n\n\nOther arithmetic operators don’t work on strings.\nYou can use len() to find a string’s length:\n\nlen('12345')\n\n5\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotice that len() counts the the letters between the\nquotes, but not the quotes themselves.\n\n\nAvoid backticks ` or curly quotes “ ”\nbecause they cause syntax errors:\n\nprint(`hello`)\n\n\n  Cell In[24], line 1\n    print(`hello`)\n          ^\nSyntaxError: invalid syntax\n\n\n\n\n\nprint(“hello”)\n\n\n  Cell In[25], line 1\n    print(“hello”)\n          ^\nSyntaxError: invalid character '“' (U+201C)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nMost code editors color valid strings differently, so keep an eye on\nsyntax highlighting to avoid mistakes.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#values-and-types",
    "href": "learning-modules/02-intro-to-python.html#values-and-types",
    "title": "02 | Intro to Python",
    "section": "6 Values\nand types",
    "text": "6 Values\nand types\nWe’ve encountered three kinds of values:\n\n2 (integer)\n42.0 (float)\n\"text\" (string)\n\nA kind of value is called a type. Every value has a\ntype, also referred to as “belongs to” a type.\nPython provides a function, type(), that tells you the\ntype of any value:\n\ntype(2)\n\nint\n\n\n\ntype(42.0)\n\nfloat\n\n\n\ntype(\"text\")\n\nstr\n\n\nint, float, and str can also\nconvert values:\n\nint(42.9) # rounds down to 42\n\n42\n\n\n\nfloat(42) # converts integer 42 to float 42.0\n\n42.0\n\n\n\nstr(123) # converts number 123 to the string \"123\"\n\n'123'\n\n\nIf you try arithmetic on a string, you get an error:\n\nprint(123 * 3)   # numeric multiplication\nprint(\"123\" * 3) # string repetition\n\n369\n123123123\n\n\n\nprint(\"500\" / 5) # TypeError: can't divide a string by an integer\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[33], line 1\n----&gt; 1 print(\"500\" / 5) # TypeError: can't divide a string by an integer\n\nTypeError: unsupported operand type(s) for /: 'str' and 'int'\n\n\n\nTo fix this, cast to the right type:\n\nint(\"126\") * 3\n\n378\n\n\nIf you have a large integer, you may type it like\n1,000,000. This is a legal expression in Python, but the\nvalue is not what you would expect:\n\n1,000,000\n\n(1, 0, 0)\n\n\nPython interprets 1,000,000 as a comma-separated\nsequence of integers. We’ll learn about this kind of sequence later.\nYou can use underscores to make large numbers easier to read:\n\n1_000_000\n\n1000000",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#formal-and-natural-languages",
    "href": "learning-modules/02-intro-to-python.html#formal-and-natural-languages",
    "title": "02 | Intro to Python",
    "section": "7 Formal\nand natural languages",
    "text": "7 Formal\nand natural languages\nNatural languages (English, Spanish, etc.) evolved over time and rely\non context, idioms, and sometimes ambiguity. Formal languages like\nPython are precise and unambiguous. Python does exactly what you write,\nso details matter. Small mistakes in spelling or punctuation can cause\nbig errors. You might find this rigid at first, but you’ll adapt with\npractice.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#variables",
    "href": "learning-modules/02-intro-to-python.html#variables",
    "title": "02 | Intro to Python",
    "section": "8\nVariables",
    "text": "8\nVariables\nA variable is a name that refers to a value. Create\none with an assignment statement:\n\nn = 17\n\nThe assignment has three parts:\n\nThe variable name\nThe = operator\nAn expression (17 here)\n\n\npi = 3.141592653589793\nmessage = \"pie &gt; π\"\n\nOnce assigned, you can use these variables:\n\nprint(message)\nprint(n + 5)\nprint(2 * pi)\nprint(round(pi))\nprint(len(message))\n\npie &gt; π\n22\n6.283185307179586\n3\n7",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#variable-names",
    "href": "learning-modules/02-intro-to-python.html#variable-names",
    "title": "02 | Intro to Python",
    "section": "9\nVariable names",
    "text": "9\nVariable names\nYou can use letters and digits in a variable name but cannot start\nwith a digit. Although uppercase letters are allowed, most Python code\nuses lowercase. Use underscores to connect words: your_name\nor airspeed_of_unladen_swallow.\nA name containing punctuation (million!) or starting\nwith a number (76trombones) triggers a syntax error. Some\nwords, like class, are keywords and cannot be variable\nnames.\n\nmillion! = 1000000\n\n\n  Cell In[40], line 1\n    million! = 1000000\n           ^\nSyntaxError: invalid syntax\n\n\n\n\n76trombones is illegal because it starts with a\nnumber.\n\n76trombones = 'big parade'\n\n\n  Cell In[41], line 1\n    76trombones = 'big parade'\n     ^\nSyntaxError: invalid decimal literal\n\n\n\n\nclass is also illegal, but it might not be obvious\nwhy.\n\nclass = 'Defense Against the Dark Arts'\n\n\n  Cell In[42], line 1\n    class = 'Defense Against the Dark Arts'\n          ^\nSyntaxError: invalid syntax\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nYour editor will often highlight keywords in a different color so you\ncan recognize them.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#the-import-statement",
    "href": "learning-modules/02-intro-to-python.html#the-import-statement",
    "title": "02 | Intro to Python",
    "section": "10 The\nimport statement",
    "text": "10 The\nimport statement\nSome features require importing. For example, to use\nthe math module:\n\nimport math\n\nA module is a collection of variables and functions.\nPython’s math\nmodule provides a variable called pi that contains the\nvalue of the mathematical constant π:\n\nmath.pi\n\n3.141592653589793\n\n\nUse the dot to access module features:\n\nprint(math.sqrt(25))\nprint(math.pow(5, 2)) # 5 ** 2 behaves the same as math.pow(5, 2)\n\n5.0\n25.0",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#expressions-vs-statements",
    "href": "learning-modules/02-intro-to-python.html#expressions-vs-statements",
    "title": "02 | Intro to Python",
    "section": "11\nExpressions vs statements",
    "text": "11\nExpressions vs statements\nAn expression calculates a value, regardless of its\ncomplexity:\n\n19 + n + round(math.pi) * 2\n\n42\n\n\nA statement performs an action without producing a\nvalue you can use:\n\nn = 17\n\nWe evaluate expressions to get their value and\nexecute statements to perform actions.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#the-print-function",
    "href": "learning-modules/02-intro-to-python.html#the-print-function",
    "title": "02 | Intro to Python",
    "section": "12 The\nprint() function",
    "text": "12 The\nprint() function\nWhen you type an expression in many Python environments, it displays\nthe result. But if you have multiple expressions in a single cell (or\nscript), only the last one appears. Use print() to display\nmore than one item:\n\nprint(n + 2)\nprint(n + 3)\nprint(\"The value of pi is approximately\", math.pi)\n\n19\n20\nThe value of pi is approximately 3.141592653589793\n\n\n\n\n\n\n\n\nNote\n\n\n\nprint() separates arguments with a space by default.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#function-arguments",
    "href": "learning-modules/02-intro-to-python.html#function-arguments",
    "title": "02 | Intro to Python",
    "section": "13\nFunction Arguments",
    "text": "13\nFunction Arguments\nThe expressions inside a function call’s parentheses are\narguments. Different functions accept different numbers\nof arguments:\n\nint() can take one required argument and an optional\nbase:\n\n\nint(\"101\", 2)\n\n5\n\n\n\nmath.pow() takes two arguments:\n\n\nmath.pow(5, 2)\n\n25.0\n\n\n\nround() can take an optional second argument (decimals\nto round):\n\n\nround(math.pi, 3)\n\n3.142\n\n\n\nprint() accepts any number of arguments:\n\n\nprint(\"Any\", \"number\", \"of\", \"arguments\")\n\nAny number of arguments\n\n\nIf you supply too many or too few arguments, or if the arguments are\nthe wrong type, Python raises a TypeError:\n\nfloat(\"123\", 2)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[53], line 1\n----&gt; 1 float(\"123\", 2)\n\nTypeError: float expected at most 1 argument, got 2\n\n\n\n\nmath.pow(2)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[54], line 1\n----&gt; 1 math.pow(2)\n\nTypeError: pow expected 2 arguments, got 1\n\n\n\n\nmath.sqrt(\"25\")\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[55], line 1\n----&gt; 1 math.sqrt(\"25\")\n\nTypeError: must be real number, not str",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#comments",
    "href": "learning-modules/02-intro-to-python.html#comments",
    "title": "02 | Intro to Python",
    "section": "14\nComments",
    "text": "14\nComments\nAs code grows, comments clarify your reasoning or\nrecord important details. Python ignores text after a\n#:\n\n# Variables\nforce = 500 # Force in Newtons (N)\narea = 0.01 # Cross-sectional area in square meters (m²)\n\n# Formula\nstress = force / area\n\n# Output\nprint(\"Stress:\", stress, \"in (Pa)\")\n\nStress: 50000.0 in (Pa)\n\n\nGood comments explain why you wrote the code in a\ncertain way (especially if it’s not obvious):\n\n# Use SI units for consistency throughout the program\narea = 0.01\n\nBad comments restate the obvious:\n\narea = 0.01  # set area to 0.01\n\nWell-chosen variable names can reduce the need for comments, but\navoid names so long that they make expressions unreadable.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#debugging",
    "href": "learning-modules/02-intro-to-python.html#debugging",
    "title": "02 | Intro to Python",
    "section": "15\nDebugging",
    "text": "15\nDebugging\nWe call mistakes in code bugs, and the process of finding and fixing\nthem debugging. You might feel frustrated when things break, but\nremember it’s normal and part of learning.\nThink of the computer as precise but inflexible. You must provide\nexact instructions because it doesn’t infer or guess what you mean.\n\n15.1\nCommon Errors\n\nSyntax erros: The code violates Python’s structure\nrules. Python refuses to run the code and points out where it got\nstuck:\n\n\nmillion! = 1000000\n\n\n  Cell In[59], line 1\n    million! = 1000000\n           ^\nSyntaxError: invalid syntax\n\n\n\n\n\nRuntime errors: The code starts running but fails\nduring execution, like dividing a string by an integer:\n\n\n\"126\" / 3\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[60], line 1\n----&gt; 1 \"126\" / 3\n\nTypeError: unsupported operand type(s) for /: 'str' and 'int'\n\n\n\n\nSemantic errors: The code runs but does something\nunintended. For example, mixing up units might produce the wrong numeric\nresult without an obvious error:\n\n\n# This uses area in cm² instead of m²\nforce = 500       # Newtons\narea = 10         # cm² (wrong units)\nstress = force / area\nprint(stress)     # No error, but incorrect value =&gt; semantic error\n\n50.0",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "learning-modules/02-intro-to-python.html#exercises",
    "href": "learning-modules/02-intro-to-python.html#exercises",
    "title": "02 | Intro to Python",
    "section": "16\nExercises",
    "text": "16\nExercises\n\n16.1\nRounding Behavior\nExperiment with round() when a number ends in\n0.5. It sometimes rounds up and sometimes down. Figure out\nthe pattern:\n\nround(42.5)\n\n42\n\n\n\nround(43.5)\n\n44\n\n\n\n\n16.2\nDeliberate Mistakes\n\nWhat happens if you use a + sign before a number\n(+2) or repeat it (2++2)? What about\n2--2?\nWhat if you write two values without an operator\n(4 2)?\nWhat if you call round(42.5) but remove one or both\nparentheses?\n\n\n\n16.3\nType Checking\nGuess each expression’s type and then use type() to\ncheck:\n\n765\n2.718\n\"2 pi\"\nabs(-7)\nabs\nint\ntype\n\n\n\n16.4\nMore Arithmetic\n\nHow many seconds are there in 42 minutes 42 seconds?\nHow many miles are there in 10 kilometers\n(1.61 kilometers/mile)?\nIf you run a 10 kilometer race in 42 minutes 42 seconds, what is\nyour average pace in seconds per mile?\n\n\n\n16.5\nIntentional Errors\n\nWe’ve seen n = 17 is legal, what about\n17 = n?\nWhat about x = y = 1?\nIn some languages every statement ends with a semi-colon\n(;). What happens if you put a semi-colon at the end of a\nPython statement?\nWhat if you put a period at the end of a statement?\nWhat happens if you spell the name of a module wrong and try to\nimport maath?\n\n\n\n16.6\nVolume of a Sphere\nThe formula for the volume of a sphere with radius \\(r\\) is \\(\\frac{4}{3} \\pi r^3\\). Compute it for \\(r = 5\\).\n\nStart with a variable names radius (in\ncentimeters)\nCompute volume (in cubic centimeters)\nPrint the result and include comments\n\n\n\n16.7\nTrigonometry\nAccording to a trig identity, \\((\\cos x)^2\n+ (\\sin x)^2 = 1\\). Test this for x = 42.\n\nCreate a variable named x to 42\nUse math.cos() and math.sin() to\ncompute\n\n\n\n\n\n\n\nNote\n\n\n\nIt might not be exactly 1 because of floating-point imprecision.\n\n\n\n\n16.8\nExploring \\(e\\)\nThe math module defines e. Compute \\(e^2\\) in three ways:\n\nUse math.e and the exponentiation operator.\nUse math.pow to raise math.e to the power\n2.\nUse math.exp, which takes as an argument a value, \\(x\\), and computes \\(e^x\\).\n\nCompare the results and see which appears most accurate.",
    "crumbs": [
      "Learning Modules",
      "02 | Intro to Python"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GSCM 425: Supply Chain Network Design",
    "section": "",
    "text": "WVU Catalog: An in-depth study of how to parse\nsupply chain problems into a network design formulation and how to\ncollect appropriate data to use on these models. Students will also\nlearn how to validate, debug, and test the sensitivity of models to\nvarious input and model assumptions.\nPrerequisite Course(s): GSCM 360 and GSCM 370 with\nminimum of C- in each\nClass Meets: Tuesday/Thursday 8:30 AM - 9:45 AM\nClass Location: Reynolds Hall | Room 5205\nInstructor: Ozan Ozbeker (ozan.ozbeker@mail.wvu.edu)\nTeaching Assistants: None\n\n\n\n\n\n\nImportant\n\n\n\nAll emails related to the course must have the following subject\nformat:\n{Course} - {Term} - {WVU ID} - {Concise Question}\nFor example:\nGSCM 425 - Spring 2025 - oo0006 - Question about XYZ. You\ncan put more details in the email body."
  },
  {
    "objectID": "index.html#course-info",
    "href": "index.html#course-info",
    "title": "GSCM 425: Supply Chain Network Design",
    "section": "",
    "text": "WVU Catalog: An in-depth study of how to parse\nsupply chain problems into a network design formulation and how to\ncollect appropriate data to use on these models. Students will also\nlearn how to validate, debug, and test the sensitivity of models to\nvarious input and model assumptions.\nPrerequisite Course(s): GSCM 360 and GSCM 370 with\nminimum of C- in each\nClass Meets: Tuesday/Thursday 8:30 AM - 9:45 AM\nClass Location: Reynolds Hall | Room 5205\nInstructor: Ozan Ozbeker (ozan.ozbeker@mail.wvu.edu)\nTeaching Assistants: None\n\n\n\n\n\n\nImportant\n\n\n\nAll emails related to the course must have the following subject\nformat:\n{Course} - {Term} - {WVU ID} - {Concise Question}\nFor example:\nGSCM 425 - Spring 2025 - oo0006 - Question about XYZ. You\ncan put more details in the email body."
  },
  {
    "objectID": "index.html#course-description",
    "href": "index.html#course-description",
    "title": "GSCM 425: Supply Chain Network Design",
    "section": "Course Description",
    "text": "Course Description\nThis course offers a deep dive into supply chain network design,\nguiding students through the process of formulating real-world supply\nchain problems, gathering and validating data, and applying mathematical\nprogramming techniques to find optimal solutions. Students will develop\nbasic yet practical Python programming skills to use Gurobi’s optimizer\nand will also leverage Excel Solver for comparative analysis. Core\ntopics include facility location, transportation and transshipment\nmodels, multi-objective and scenario-based optimization, and sensitivity\nanalysis in the face of uncertainty. Emphasis is placed on the practical\nimplementation of these tools and the communication of results in a\nmanagerial context."
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "GSCM 425: Supply Chain Network Design",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nUpon successful completion of this course, students will be able\nto:\n\nDemonstrate Fundamental Python Skills: Use Python\neffectively for data handling and basic scripting in preparation for\noptimization tasks.\nFormulate and Solve Supply Chain Network Problems:\nModel and solve facility location, transportation, and other network\ndesign challenges using both Gurobi and Excel Solver.\nEvaluate and Compare Optimization Tools: Interpret\nresults produced by different solvers, comparing solution quality, run\ntimes, and applicability in real-world supply chain scenarios.\nApply Advanced Analysis Techniques: Incorporate\nscenario analysis, multi-objective optimization, and sensitivity testing\nto account for uncertainty and trade-offs in decision making.\nCommunicate and Collaborate: Work in teams to\nanalyze data, develop optimization models, and present solution insights\nand recommendations to stakeholders."
  },
  {
    "objectID": "course-information/resources.html",
    "href": "course-information/resources.html",
    "title": "Resources",
    "section": "",
    "text": "Office Hours: Tuesday/Thursday 9:45 AM - 10:30\nAM",
    "crumbs": [
      "Course Information",
      "Resources"
    ]
  },
  {
    "objectID": "course-information/resources.html#office-hours",
    "href": "course-information/resources.html#office-hours",
    "title": "Resources",
    "section": "Office Hours",
    "text": "Office Hours\nOffice Hours are regular time that course staff sets aside for you to\nget help on concepts and assignments.\nYou can come by at an point during this period and we’ll do our best\nto answer your question. Please come with your laptop and questions\nprepared ahead of time as sometimes there will be a line and it’s\nimportant we make time for everyone.\n\n\n\nWho\nWhere\nWhen\n\n\n\n\nOzan Ozbeker\nClassroom\nTuesday/Thursday 9:45 AM - 10:30 AM\n\n\n\n\n\n\n\n\n\nInstructor Note\n\n\n\nIn addition to teaching, I work full-time in industry. As a result,\nmy availability for school-related matters will primarily be on Tuesdays\nand Thursdays. While I may occasionally check my email on other days,\nplease plan to contact me during these designated times for the most\ntimely responses.\nI can meet by appointment (schedule via email) on Tuesday/Thursday\nafter 4:00 PM, sparingly. Must show proof that you could not\nattend regular office hours.",
    "crumbs": [
      "Course Information",
      "Resources"
    ]
  },
  {
    "objectID": "course-information/resources.html#readings",
    "href": "course-information/resources.html#readings",
    "title": "Resources",
    "section": "Readings",
    "text": "Readings\nMost of the materials for the course are open-source and freely\navailable online. You do not need to purchase any literature or software\nto succeed in this class.\nWhile there are no required textbooks for this course, the Learnings\nare adapted from the following books:\n\nThink Python,\n3E\nIntroduction to Operations Research, 11E by Hillier (Chapters 3, 9,\n10, & 12)\n\nWhile not directly referenced, these may aid in understanding course\nmaterial as well as in future endeavors:\n\nElements of\nData Science\nThink Stats,\n3E\nData Structures and\nInformation Retrieval in Python\nTidy\nData\nModeling and\nSimulation in Python\nAutomate The Boring\nStuff with Python\nBeyond the Basic\nStuff with Python\nThe Big Book\nof Small Python Projects",
    "crumbs": [
      "Course Information",
      "Resources"
    ]
  },
  {
    "objectID": "course-information/resources.html#software",
    "href": "course-information/resources.html#software",
    "title": "Resources",
    "section": "Software",
    "text": "Software\nRequired software, with references and documentation:\n\nGitHub Desktop\nuv\nRuff\nmarimo\n\nThese will be explained & installed in Lab\n1.",
    "crumbs": [
      "Course Information",
      "Resources"
    ]
  },
  {
    "objectID": "course-information/resources.html#ecampus-discussion-board",
    "href": "course-information/resources.html#ecampus-discussion-board",
    "title": "Resources",
    "section": "eCampus Discussion Board",
    "text": "eCampus Discussion Board\nThe discussion board is a forum that you may use to ask questions\nthat can be answered by course staff and you fellow students. Asking\ntechnical questions is an important skill and you’ll be asking your\ncolleagues and friends technical questions in your job. Best to get some\npractice now.\n\nSearch Before Asking\nBefore posting a question, check whether it has already been answered\nin a previous post. For example, suppose you are an\nIndexError; you could search just for that word to see if\nany other students have encountered that same error.\nMake sure to always check the “pinned” posts. We\nwill often “pin” a post about a particular assignment that might contain\nthe information you are looking for. Be sure to read these first.\n\n\nAsk A Question\nMake sure you’re going to ask an actual question.\nYou need to tell us about a specific issue you’re encountering, and why\nyou’re stuck on it (e.g., you are not getting the expected result, the\ntests are failing in a way you do not understand, etc.). Writing a post\nthat says “I can’t get Task 4 to work, I’ve pushed my code. Please look\nat it.” is not a question.\nIt may be helpful to write your question in the format of “I did {X},\nexpecting {Y}, but {Z} happened instead.” This can help us understand\nthe source of the error and reduce the time it takes to get you a high\nquality answer.\n\n\nPublic vs. Private\nAll questions about coursework, course logistics, etc. should be\nasked publicly (please note that you do have the option of asking the\nquestion anonymously if you prefer). If you ask such a question\nprivately, we will not answer it: we will ask you to ask it publicly,\nand will answer it once you do. This way, everyone can benefit from the\nanswer to the question and, if someone runs into the same issue you do,\nwe can refer them to the answer we provided in your post.\n\n\nThe more information, the better!\nSometimes people are brief to avoid wasting people’s time. With code,\nthe opposite is usually true — the more information you provide the more\neasily we can solve your problem.\nIn particular, it will be much easier for us to help you if we are\nable to reproduce the exact issue you are encountering (i.e., when we\nrun your code, we must be able to observe the exact same issue you’re\nencountering). And to do so, we need as much information as possible\nfrom you:\n\nIf your question relates to your code, make sure you push your code\nto GitHub before asking for help.\nInclude a detailed description of the exact chain of events that\nlead to the issue you’re encountering (Are you testing a specific\nfunction? If so, with what inputs? Etc.).\nIf you encounter an error message (or any other unexpected output)\nwhen running a command (like a Python program, Ruff, marimo, etc.) or\nwhen testing a piece of code in the interpreter, please make sure you\ninclude the full and unabridged error message (or unexpected output).\nSummarizing the message (e.g., “Python says something about a KeyError”)\nmakes it harder for us to figure out what the issue is.\nIf something is “wrong”, please describe in what way it seems wrong\nto you. For example, were you expecting a particular output but got a\ndifferent one? Is a piece of code behaving in a way you were not\nexpecting? Etc. It can be useful to tell us what you were expecting the\ncode to do, and what you encountered instead.\n\n\n\nNo Code or Screenshots\n\nNever post your code in the discussion board. As\nnoted in our Academic Integrity policies, you should never share your\ncode with other students (unless they are on your team), which means you\nshould never post it on the discussion board. If you need us to look at\nyour code, just push it to the GitHub and we will look at it there.\nPlease note that, if a test prints out a few lines of code as part of\nits output, that’s ok.\nNo screenshots or phone pictures. Do not post\nscreenshots of the output. Screenshots are not searchable, and may pose\nreadability issues for some people. Instructor/TAs may also want to\ncopy-paste that output somewhere else, which is not possible if you post\na screenshot.\n\nIf you need to share some output with us, copy-paste from the\nterminal and use the discussion board’s “code block” formatting. To copy\nsomething on the terminal, just select it (the same way you would do in\na word processor: click, and then drag until the end of the output) and\npress Control-Shift-C.\n\n\nOther Discussion Board Tips\n\nAvoid posts that have multiple unrelated\nquestions: Instead, write a separate post for each question.\nPlease note that it is ok to ask multiple questions in one post if they\nall relate to the same issue.\nWhen to use follow-ups and when to post a new\nquestion: If you need to provide additional information (say,\nbecause we pointed you to this page), please use a follow-up in the same\nthread. If, on the other hand, you have an entirely new question, please\nwrite a new post for it. That way, if others have that same question, it\nwill be easier for them to find your post (and our answer to it),\ninstead of having to dig through the followup discussions of unrelated\nposts. Do not edit the original question: it is unlikely that we will\nnotice your change.\nFound the answer yourself?: If you solved your\nproblem before we got around to helping you, please note that the issue\nis resolved. If the solution is not specific to your implementation,\nplease add a brief explanation of how you solved the problem in case\nanyone else runs into the same issue.",
    "crumbs": [
      "Course Information",
      "Resources"
    ]
  },
  {
    "objectID": "course-information/grading-and-deliverables.html",
    "href": "course-information/grading-and-deliverables.html",
    "title": "Grading & Deliverables",
    "section": "",
    "text": "If you are new to using specifications grading, here’s what you can\nexpect:\nLabs & Test Questions are assigned one of three marks:\nThese will be assessed on:\nAn assignment’s specs will be provided with the instructions.",
    "crumbs": [
      "Course Information",
      "Grading & Deliverables"
    ]
  },
  {
    "objectID": "course-information/grading-and-deliverables.html#resubmissions",
    "href": "course-information/grading-and-deliverables.html#resubmissions",
    "title": "Grading & Deliverables",
    "section": "Resubmissions",
    "text": "Resubmissions\nI will allow 5 Lab revisions to change a\nNeeds Improvement mark to a\nSatisfactory mark.\nOnce a Lab is graded and returned to you, there will be a one\nweek window for you to resubmit that Lab. This means that, if\nyou produce work that needs some improvement, you will have a chance to\naddress the grader’s feedback to improve your score on that Lab.\nThere will be no revisions for Quizzes or Test Questions.\n\n\n\n\n\n\nNote\n\n\n\nResubmissions should be submitted via email to the instructor with\n“Lab # Resubmission” as the\n{Concise Question}.\n\n\n\nLate Submissions\nLate submissions will not be accepted in this class, except under\nextraordinary circumstances. Please bear in mind that the grading scheme\nwill be set up to absorb a reasonable amount of sub-par work, and also\nallows you to resubmit at most one programming homework (no tests or\nfinal project).\nThat said, to be clear: if you encounter some sort of\nemergency (medical, family, etc.) please reach out to your instructor as\nsoon as you are able to do so. I am more than happy to find\nways to provide additional flexibility in these situations. Ideally, you\nshould notify me of these circumstances before the work is due so we can\ndiscuss options with you.\nIn other words, the late submission policy applies to\nordinary circumstances: if you are having a busy week, you have\nan event that overlaps with a deadline, etc., then the grading scheme\nwill have some built-in flexibility for this. Instead of trying to argue\nfor a few extra days to work on a homework, you should just submit the\nwork you have completed by the deadline, so you can get feedback on that\nwork and use that feedback to improve your work in future assignments,\nor even to resubmit the homework as described above.\n\n\nGrading Disputes\nExcept in very specific cases (described below), you cannot dispute\nthe score assigned to you on a piece of work. There is one exception to\nthis: if a grader made an factual mistake in your grading. Please note\nthat this only includes cases where a grader makes an erroneous\nstatement about your code in their feedback. It does not include cases\nwhere you simply disagree with whether something deserves to be flagged\nas incorrect.\nFor example, suppose you receive a piece of feedback that says\n“Incorrect: Function X did not check that parameter Y is greater than\nzero”. If function X in your code did perform this check, and the grader\nmissed this fact (and erroneously gave you that feedback), you can ask\nus to review this decision. Please note that, even if the feedback is\namended, it may not affect your actual SNU score.\nWe ask that you keep these requests brief and to the point: no more\nthan a few sentences identifying the exact statement that the grader\nmade and the reasons you believe the statement was mistaken, including\nreferences to specific parts of your code (e.g., “I did check the value\nof the parameter in line 107”). Focus on laying out the facts, and\nnothing else.\nFinally, it is also your responsibility to make these requests in a\ntimely manner. Requests to review grading mistakes must be submitted no\nlater than one week after a graded piece of work is\nreturned to you. After that time, we will not consider any such\nrequests, regardless of whether the request is reasonable and\njustified.\n\n\n\n\n\n\nNote\n\n\n\nDisputes should be submitted via email to the instructor with\n“Lab # | Test # Grading Dispute” as the\n{Concise Question}.\n\n\n\n\nAcademic Integrity Violation\nThe minimum penalty for an Academic\nIntegrity violation is a U for all grades on\nthe assignment in question and a drop in a letter grade for each\nviolation.\n\n\nCurving\nIn lieu of traditional curving, I reserve the right to lower the\nthresholds for each grade. I will not raise the thresholds. (So if you\nearn an B according to the above chart, you will get an B or\nbetter.)",
    "crumbs": [
      "Course Information",
      "Grading & Deliverables"
    ]
  },
  {
    "objectID": "course-information/policies.html",
    "href": "course-information/policies.html",
    "title": "Policies",
    "section": "",
    "text": "The integrity of the classes offered by any academic institution\nsolidifies the foundation of its mission and cannot be sacrificed to\nexpediency, ignorance, or blatant fraud. Therefore, instructors will\nenforce rigorous standards of academic integrity in all aspects and\nassignments of their courses. For the detailed policy of West Virginia\nUniversity regarding the definitions of acts considered to fall under\nacademic dishonesty and possible ensuing sanctions, please see the West\nVirginia University Academic\nStandards Policy. Should you have any questions about possibly\nimproper research citations or references, or any other activity that\nmay be interpreted as an attempt at academic dishonesty, please see your\ninstructor before the assignment is due to discuss the matter.\n\nIt is common to have questions about what amount of collaboration and\nreliance on tools is acceptable, simply put: In this course, you\nare expected to primarily turn in code you wrote.\nCode written by a peer, TA, stranger on the internet, or LLM\nis not code you wrote. While you may use code written\nby others within reason, you must give proper credit, and it will not be\nconsidered your own work for evaluation purposes.\n\n\n\n\n\n\nWarning\n\n\n\nPlease also see Artificial\nIntelligence (AI) for specifics of how this policy relates to\nthe use of AI tools in this course.\n\n\nWhile outside of the classroom programming is often a very\ncollaborative process, you should be working on coming up with your own\nsolutions to problems, to ensure you are learning what you came here to\nlearn. You may generally use outside resources, talk to peers, etc. so\nlong as the significant majority of your code is your own work and all\nsources are properly credited. Furthermore, if you use code from the\ninternet, you are expected to understand and adhere to the license of\nthat code. Failure to do so may result in a significant penalty to a\ngrade. Finally, if you have any questions regarding what would or would\nnot be considered academic dishonesty in this course, please don’t\nhesitate to ask me.",
    "crumbs": [
      "Course Information",
      "Policies"
    ]
  },
  {
    "objectID": "course-information/policies.html#academic-integrity",
    "href": "course-information/policies.html#academic-integrity",
    "title": "Policies",
    "section": "",
    "text": "The integrity of the classes offered by any academic institution\nsolidifies the foundation of its mission and cannot be sacrificed to\nexpediency, ignorance, or blatant fraud. Therefore, instructors will\nenforce rigorous standards of academic integrity in all aspects and\nassignments of their courses. For the detailed policy of West Virginia\nUniversity regarding the definitions of acts considered to fall under\nacademic dishonesty and possible ensuing sanctions, please see the West\nVirginia University Academic\nStandards Policy. Should you have any questions about possibly\nimproper research citations or references, or any other activity that\nmay be interpreted as an attempt at academic dishonesty, please see your\ninstructor before the assignment is due to discuss the matter.\n\nIt is common to have questions about what amount of collaboration and\nreliance on tools is acceptable, simply put: In this course, you\nare expected to primarily turn in code you wrote.\nCode written by a peer, TA, stranger on the internet, or LLM\nis not code you wrote. While you may use code written\nby others within reason, you must give proper credit, and it will not be\nconsidered your own work for evaluation purposes.\n\n\n\n\n\n\nWarning\n\n\n\nPlease also see Artificial\nIntelligence (AI) for specifics of how this policy relates to\nthe use of AI tools in this course.\n\n\nWhile outside of the classroom programming is often a very\ncollaborative process, you should be working on coming up with your own\nsolutions to problems, to ensure you are learning what you came here to\nlearn. You may generally use outside resources, talk to peers, etc. so\nlong as the significant majority of your code is your own work and all\nsources are properly credited. Furthermore, if you use code from the\ninternet, you are expected to understand and adhere to the license of\nthat code. Failure to do so may result in a significant penalty to a\ngrade. Finally, if you have any questions regarding what would or would\nnot be considered academic dishonesty in this course, please don’t\nhesitate to ask me.",
    "crumbs": [
      "Course Information",
      "Policies"
    ]
  },
  {
    "objectID": "course-information/policies.html#adverse-weather",
    "href": "course-information/policies.html#adverse-weather",
    "title": "Policies",
    "section": "Adverse Weather",
    "text": "Adverse Weather\nIn the event of inclement or threatening weather, everyone should use\nhis or her best judgment regarding travel to and from campus. Safety\nshould be the main concern. If you cannot get to class because of\nadverse weather conditions, you should contact your instructor as soon\nas possible. Similarly, if your instructor(s) are unable to reach the\nclass location, they will notify you of any cancellation or change as\nsoon as possible, using agreed upon methods to prevent students from\nembarking on any unnecessary travel. If you cannot get to class because\nof weather conditions, instructors will make allowances relative to\nrequired attendance policies, as well as any scheduled tests, quizzes,\nor other assessments. [adopted 9-8-2014]",
    "crumbs": [
      "Course Information",
      "Policies"
    ]
  },
  {
    "objectID": "course-information/policies.html#appropriate-use-of-technology",
    "href": "course-information/policies.html#appropriate-use-of-technology",
    "title": "Policies",
    "section": "Appropriate Use of Technology",
    "text": "Appropriate Use of Technology\nUse of technology in the classroom should always be directly related\nto class activities and/or course learning outcomes. Inappropriate\ntechnology use can be an impediment to learning and a distraction to all\nmembers of the class. As such, inappropriate use of technology in the\nclassroom may be considered a disruption of the class and constitute a\nviolation of the WVU\nStudent Conduct Code and could potentially result in a referral to\nthe Office of Student Rights and Responsibilities. Use of technology in\nthe classroom when specifically prohibited by the instructor may also\nconstitute a violation of WVU’s Academic\nIntegrity policy.",
    "crumbs": [
      "Course Information",
      "Policies"
    ]
  },
  {
    "objectID": "course-information/policies.html#artificial-intelligence",
    "href": "course-information/policies.html#artificial-intelligence",
    "title": "Policies",
    "section": "Artificial Intelligence",
    "text": "Artificial Intelligence\nArtificial intelligence (AI) tools that can create and develop\nacademic content are not allowed unless permission is given by an\ninstructor. Students must receive instructor permission prior to\nutilizing AI tools. Unauthorized use of AI tools may result in academic\ndishonesty charges.\nIn this course, we will be developing foundational skills and\nknowledge that are very important to discover and practice on your own.\nAt this stage of learning, it is far too easy to overuse these tools and\nnot gain the skills and understanding you came here for. Only as the\nproblems you aim to solve grow in complexity will the extent to which\nthe gaps in your understanding start to become a problem.\nAs a result, and to help avoid potential academic honesty issues\n— the use of AI tools, such as ChatGPT or CoPilot, to write code\nsubmitted for this course is not allowed.\nAs stated in the Academic\nIntegrity policy, the code you turn in should be your own\ncreation, not code that AI originated or in any way modified.\n\n\n\n\n\n\nImportant\n\n\n\nUsing AI tools to generate code for assignments in this course will\nviolate WVU’s\nAcademic Integrity policy.\n\n\nIn general, this means pasting your code into an AI tool or copying\nany code from it should be avoided.\n\nWhat you may do with AI tools:\n\nUse these tools to ask questions unrelated to the assignment. While\nI only have time in class to provide 1-2 examples on a topic, you may\nfind it useful to explore additional ones by asking AI for them. This\ntends to work quite well and avoids any academic honestly issues.\nAsk AI to explain an error message to you. Instead of pasting in\nyour code and saying “fix this”, instead pasting just the error message\nand asking the AI how to diagnose the problem. If in doubt, ask me\nbefore using any tools if you are unsure about this policy.",
    "crumbs": [
      "Course Information",
      "Policies"
    ]
  },
  {
    "objectID": "course-information/policies.html#attendance-participation",
    "href": "course-information/policies.html#attendance-participation",
    "title": "Policies",
    "section": "Attendance & Participation",
    "text": "Attendance & Participation\nAttendance is not required; however, in-class benefits\ninclude live guidance, interactive practice, and exercises reviewed only\nin class. Students who prefer or need additional help will find regular\nattendance invaluable.\nThe WVU Catalog contains the full Attendance\nPolicy.",
    "crumbs": [
      "Course Information",
      "Policies"
    ]
  },
  {
    "objectID": "course-information/policies.html#inclusivity-statement",
    "href": "course-information/policies.html#inclusivity-statement",
    "title": "Policies",
    "section": "Inclusivity Statement",
    "text": "Inclusivity Statement\nThe West Virginia University community is committed to creating and\nfostering a positive learning and working environment based on open\ncommunication, mutual respect, and inclusion.\nIf you are a person with a disability and anticipate needing any type\nof accommodation in order to participate in your classes, please advise\nyour instructors and make appropriate arrangements with the Office of Student Accommodations.\nMore information is available at the Division of Diversity, Equity, and\nInclusion website as well. [adopted 2-11-2013]",
    "crumbs": [
      "Course Information",
      "Policies"
    ]
  },
  {
    "objectID": "course-information/policies.html#incomplete-policy",
    "href": "course-information/policies.html#incomplete-policy",
    "title": "Policies",
    "section": "Incomplete Policy",
    "text": "Incomplete Policy\nThe WVU Catalog contains the full Incomplete\nPolicy.",
    "crumbs": [
      "Course Information",
      "Policies"
    ]
  },
  {
    "objectID": "course-information/policies.html#sale-of-course-material-statement",
    "href": "course-information/policies.html#sale-of-course-material-statement",
    "title": "Policies",
    "section": "Sale of Course Material Statement",
    "text": "Sale of Course Material Statement\nAll course materials, including lectures, class notes, quizzes,\nexams, handouts, presentations, and other course materials provided to\nstudents for their courses are protected intellectual property. As such,\nthe unauthorized purchase or sale of these materials may result in\ndisciplinary sanctions under the Student\nConduct Code. [adopted 5-11-2015]",
    "crumbs": [
      "Course Information",
      "Policies"
    ]
  },
  {
    "objectID": "course-information/policies.html#sexual-misconduct-statement",
    "href": "course-information/policies.html#sexual-misconduct-statement",
    "title": "Policies",
    "section": "Sexual Misconduct Statement",
    "text": "Sexual Misconduct Statement\nWest Virginia University does not tolerate sexual misconduct,\nincluding harassment, stalking, sexual assault, sexual exploitation, or\nrelationship violence: BOG\nRule 1.6. It is important for you to know that there are resources\navailable if you or someone you know needs assistance. You may speak to\na member of university administration, faculty, or staff; keep in mind\nthat they have an obligation to report the incident to the Title\nIX Coordinator.\nIf you want to speak to someone who is permitted to keep your\ndisclosure confidential, please seek assistance from the Carruth Center,\n304-293-9355 or 304-293-4431 (24-hour\nhotline), and locally within the community at the Rape and Domestic Violence Information\nCenter (RDVIC), 304-292-5100 or\n304-292-4431 (24-hour hotline).\nFor more information, please consult WVU’s Title IX\nOffice.",
    "crumbs": [
      "Course Information",
      "Policies"
    ]
  },
  {
    "objectID": "course-information/policies.html#student-evaluation-of-instruction-statement",
    "href": "course-information/policies.html#student-evaluation-of-instruction-statement",
    "title": "Policies",
    "section": "Student Evaluation of Instruction Statement",
    "text": "Student Evaluation of Instruction Statement\nEffective teaching is a primary mission of West Virginia University.\nStudent evaluation of instruction provides the university and the\ninstructor with feedback about your experiences in the course for review\nand course improvement. Your participation in the evaluation of course\ninstruction is both strongly encouraged and highly valued. Results are\nstrictly confidential, anonymous, and not available to the instructor\nuntil after final grades are released by Admissions and Records.\nInformation about how you can complete this evaluation will provided by\nyour instructor. [adopted 4-14-2008]",
    "crumbs": [
      "Course Information",
      "Policies"
    ]
  },
  {
    "objectID": "course-information/schedule.html",
    "href": "course-information/schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Course weeks with modules follow a consistent cycle:",
    "crumbs": [
      "Course Information",
      "Schedule"
    ]
  },
  {
    "objectID": "course-information/schedule.html#calendar",
    "href": "course-information/schedule.html#calendar",
    "title": "Schedule",
    "section": "Calendar",
    "text": "Calendar\nSchedule subject to change, changes will be announced in class\nand on eCampus.\n\nLabs: due on Wednesday at 11:59 PM of the following\nweek.\n\nExample - Week 3:\n\nTuesday (2025-02-04), we will go over the exercises from\nFlow Control and Functions.\nThursday (2025-02-06), you will work on Lab 3 in\nclass.\nWednesday (2025-02-12), Lab 3 is due.\n\n\nTests: due on Wednesday at 11:59 PM following the\nprep week.\n\nExample - Test 1:\n\nTuesday (2025-02-18): No new lecture material for this week, give\ntime to ask questions for test.\nThursday (2025-02-20): No new lecture material for this week, give\ntime to ask questions for test.\nWednesday (2025-02-26): Test is due at 11:59 PM.\nNote: New material will start on Tuesday, 2025-02-25, and I will not\nbe helping with tests outside of technical issues.\n\n\nFinal Project: due at 11:59 PM on Monday, April\n28th, 2025.\n\n\n\n\n\n\n\n\n\n\n\nWeek\nStart\nLearning Module(s)\nCourse Deliverable Due\n\n\n\n\n1\n2025-01-13\nCourse Intro\n\n\n\n2\n2025-01-20\n01 | Setting Up Your Workstation\n\n\n\n3\n2025-01-27\n02 | Intro to Python\nLab 01\n\n\n4\n2025-02-03\n03 | Flow Control and Functions\nLab 02\n\n\n5\n2025-02-10\n04 | Data Structures\nLab 03\n\n\n6\n2025-02-17\nTest 01 (Modules 01-04) Prep\nLab 04\n\n\n7\n2025-02-24\nTest 01\n\n\n\n8\n2025-03-03\n05 | Intro to Gurobi & Optimization\nTest 01\n\n\n9\n2025-03-10\n**05 | Intro to Gurobi & Optimization\nPart 2**\n\n\n10\n2025-03-17\nSpring Recess\nRecess\n\n\n11\n2025-03-24\n06 | Minimum Cost Network Flow Modeling\nLab 05\n\n\n12\n2025-03-31\n\nLab 06\n\n\n13\n2025-04-07\n\n\n\n\n14\n2025-04-14\n\n\n\n\n15\n2025-04-21\n\n\n\n\n16\n2025-04-28\n\n\n\n\n17\n2025-05-05\nFinals Week (No Final Exam)",
    "crumbs": [
      "Course Information",
      "Schedule"
    ]
  },
  {
    "objectID": "learning-modules/01-setting-up-your-workstation.html",
    "href": "learning-modules/01-setting-up-your-workstation.html",
    "title": "01 | Setting Up Your Workstation",
    "section": "",
    "text": "In this course, we will spend time learning three critical tools for\noptimization:\n\nThe Command Line\nPython / Gurobi Solver\nExcel Solver (which you should have some experience\nwith by now)\n\nPython is usually ranked as the\nfirst or second most popular programming language in the world and, just\nas importantly, it’s also one of the easiest to learn. It’s a general\npurpose language, which means it can perform a wide range of tasks. The\njoke goes that Python is the 2nd best language at everything, and\nthere’s some truth to that (although Python is 1st at some tasks, like\nmachine learning).\nInstead of re-writing the great documentation offered by the\nproducts, I will provide you with links to the sections that are most\nimportant, as well as some extra resources that you might find\nhelpful.\nIn the realm of software, documentation is your friend, you will not\nalways have a teacher to tell you exactly what to do, so learning to go\nthrough documentation is an important skill of itself. Do not skim\nthrough the instructions provided. If there are any non-default options\nneeded, I will mention them.\n\n\n\n\n\n\nWarning\n\n\n\nThis is going to be by far the most tedious of the lectures in this\ncourse. Setting up your computer and environment is a pain but it must\nbe done. This module will comprise of a lot of reading and not a whole\nlot of doing, but it’s essential you understand the basics of these\ntools to be successful in class. The following modules will be much more\nhands on and interactive.",
    "crumbs": [
      "Learning Modules",
      "01 | Setting Up Your Workstation"
    ]
  },
  {
    "objectID": "learning-modules/01-setting-up-your-workstation.html#overview",
    "href": "learning-modules/01-setting-up-your-workstation.html#overview",
    "title": "01 | Setting Up Your Workstation",
    "section": "",
    "text": "In this course, we will spend time learning three critical tools for\noptimization:\n\nThe Command Line\nPython / Gurobi Solver\nExcel Solver (which you should have some experience\nwith by now)\n\nPython is usually ranked as the\nfirst or second most popular programming language in the world and, just\nas importantly, it’s also one of the easiest to learn. It’s a general\npurpose language, which means it can perform a wide range of tasks. The\njoke goes that Python is the 2nd best language at everything, and\nthere’s some truth to that (although Python is 1st at some tasks, like\nmachine learning).\nInstead of re-writing the great documentation offered by the\nproducts, I will provide you with links to the sections that are most\nimportant, as well as some extra resources that you might find\nhelpful.\nIn the realm of software, documentation is your friend, you will not\nalways have a teacher to tell you exactly what to do, so learning to go\nthrough documentation is an important skill of itself. Do not skim\nthrough the instructions provided. If there are any non-default options\nneeded, I will mention them.\n\n\n\n\n\n\nWarning\n\n\n\nThis is going to be by far the most tedious of the lectures in this\ncourse. Setting up your computer and environment is a pain but it must\nbe done. This module will comprise of a lot of reading and not a whole\nlot of doing, but it’s essential you understand the basics of these\ntools to be successful in class. The following modules will be much more\nhands on and interactive.",
    "crumbs": [
      "Learning Modules",
      "01 | Setting Up Your Workstation"
    ]
  },
  {
    "objectID": "learning-modules/01-setting-up-your-workstation.html#your-computer-and-the-command-line",
    "href": "learning-modules/01-setting-up-your-workstation.html#your-computer-and-the-command-line",
    "title": "01 | Setting Up Your Workstation",
    "section": "2 Your\ncomputer and the command line",
    "text": "2 Your\ncomputer and the command line\nBefore we install these tools, we need to get comfortable using the\ncommand line. But what exactly is it? Let me explain.\nWhen people refer to the command line, you might hear terms like\nterminal, console, CLI\n(command-line interface), and shell used\ninterchangeably. While they’re related, they’re not exactly the same\nthing. For this course, you don’t need to fully understand every nuance,\nbut having a general sense of these terms will help clear up\nconfusion.\n\n2.1\nConsole\nA console historically refers to the physical device used to interact\nwith a computer. In modern terms, it includes the combination of your\ncomputer’s screen, keyboard, and mouse.\n\n\n\nIn the past, consoles were often standalone machines with\nbuilt-in screens and keyboards. Today, the term is used less often, but\nit’s good to understand its origins.\n\n\n\n\n2.2\nTerminal\nA terminal is a program that allows\nyou to enter commands into your computer. Think of it as the “window” or\n“app” where you type the instructions that your computer processes.\nFor example:\n\nOn Windows, the terminal is called Windows\nTerminal.\nOn Mac, it’s simply called Terminal.\n\nThe terminal is just like any other program on your computer, such as\nWord or Excel. You can even replace the default terminal with other\noptions or use terminals built into tools like Visual Studio Code\n(foreshadowing??). While it may seem intimidating, it’s just a\ntool for interacting with your computer through text commands.\n\n\n2.3\nCommand line or Command-Line Interface (CLI)\nThe command-line interface (CLI) is the actual\ninterface where you type commands for your computer to\nprocess. It’s a way of interacting with your operating system using\ntext, rather than clicking with a mouse (which is how you use a GUI, or\ngraphical user interface).\nThe CLI exists inside the terminal, and you can think of it as the\nengine running underneath. For simplicity, you can treat the terms\nterminal and CLI as interchangeable in this course.\n\n\n2.4\nShell\nA shell is a program that acts as\nthe interpreter for the commands you enter into the CLI. It takes what\nyou type, processes it, and returns the results.\nYour computer’s shell comes pre-installed:\n\nLinux: Bash (Bourne\nAgain Shell)\nMac: Zsh (Z Shell)\nWindows: PowerShell\n(successor to Command Prompt)\n\nA shell also allows you to create scripts, which are\nfiles containing sets of commands to automate tasks. While scripting is\nsimilar to programming in languages like Python or R, it’s not the focus\nof this course. For now, we’ll stick to typing individual commands.\n\n\n2.5 Web\nSearching as an Analogy\nLet’s connect what we’ve learned so far with an example of searching\nthe web:\n\nTerminal: the terminal is like your web\nbrowser (Chrome, Edge, or Safari). It’s the environment or\n“window” where everything happens.\nCLI: The CLI is like the search\nbar inside your browser (or the one on the mage page of Google\nor Bing). It’s where you type in your commands (or search queries) for\nthe system to process.\nShell: The Shell is the search engine\nitself (Google Search or Bing Search). It takes the query you\nentered, processes it, and returns the results.\n\n\n\n2.6 Why\nare we using the CLI?\nSimply put, many tools in the realm of data analytics, data science,\nand data engineering are designed with the command line in mind first.\nGraphical user interfaces (GUIs) may follow, but the command line often\nremains the most powerful and flexible way to interact with these tools.\nIn this class, we need a basic understanding of the CLI to install and\nset up essential tools and occasionally run scripts.\n\n\n\n\n\n\nTip\n\n\n\nDon’t be intimidated by the command line! While you may be more\nfamiliar with tools or apps that have a visual interface, the command\nline provides a powerful way to control your computer. If it’s any\nsolace, after this initial setup assignment, we will use the command\nline sparingly. It’s just essential for getting started.\n\n\n\n\n2.7\nUnderstanding working directories\nWhen you use the command line, the concept of a working directory is\ncrucial. The working directory is the folder where your commands operate\nby default. It’s like being inside the room in a building, you can only\ninteract with the items inside that room unless you explicitly move to a\ndifferent room.\nFor example, if you see this prompt on the command line:\n\n\nCLI\n\nC:\\Users\\oo0006\\Desktop&gt;\n\nIt means the current working directory is the Desktop\nfolder inside the user directory of the user oo0006. If you\ntype a command like dir (to list the files in the working\ndirectory), it will show the contents of the Desktop\nfolder.\n\n2.7.1\nCommon symbols and their meaning\n\n\\ (Backslash): Used in Windows paths to separate\nfolders (e.g., C:\\Users\\oo0006\\Desktop).\n/ (Forward Slash): Used in Unix-like systems (Linux,\nmacOS) for the same purpose (e.g.,\n/home/user/Desktop).\n$: In many tutorials, this symbol represents the\nstart of a command in the command line. It’s a convention to indicate\nyou should enter a command into the terminal. For instance,\nfollowing code cell means you should type ls into the\nterminal and press Enter.:\n\n\n\nCLI\n\n$ ls\n\n\n\n\n\n\n\nTip\n\n\n\nThis is the convention I will be following in my material.\n\n\n\n&gt;: In Windows, this symbol is part of the prompt and\nindicates the terminal is ready for your input.\n\n\n\n2.7.2\nChanging directories\nTo navigate the file system in the command line, you use the\ncd (change directory) command:\n\nTo move to a specific folder (if you’re in\nC:\\Users\\oo0006\\, this will take you to\nC:\\Users\\oo0006\\Documents):\n\n\n\nCLI\n\n$ cd Documents\n\n\nTo go up one level (if you’re in\nC:\\Users\\oo0006\\Documents, this will take you back to\nC:\\Users\\oo0006\\):\n\n\n\nCLI\n\n$ cd ..\n\n\nTo move directly to another folder:\n\n\n\nCLI\n\n$ cd C:\\Program Files\n\nThis takes you straight to C:\\Program Files, no matter\nwhere you were previously.\n\n\n\n2.8 Key\ntakeaways\n\nThe command line is a powerful tool, don’t let its simplicity fool\nyou.\nThe working directory determines where commands will execute by\ndefault.\nUnderstanding the prompt and basic navigation commands like\ncd can make the command line much less intimidating.",
    "crumbs": [
      "Learning Modules",
      "01 | Setting Up Your Workstation"
    ]
  },
  {
    "objectID": "learning-modules/01-setting-up-your-workstation.html#git-github-github-desktop",
    "href": "learning-modules/01-setting-up-your-workstation.html#git-github-github-desktop",
    "title": "01 | Setting Up Your Workstation",
    "section": "3 Git,\nGitHub, & GitHub Desktop",
    "text": "3 Git,\nGitHub, & GitHub Desktop\nGit\nis a version control system that intelligently tracks changes in files.\nGit is particularly useful when you and a group of people are all making\nchanges to the same files at the same time.\nTypically, to do this in a Git-based workflow, you would:\n\nCreate a branch off from the main copy of files\nthat you (and your collaborators) are working on.\nMake edits to the files independently and safely on\nyour own personal branch.\nLet Git intelligently merge your specific changes\nback into the main copy of files, so that your changes don’t impact\nother people’s updates.\nLet Git keep track of your and other people’s\nchanges, so you all stay working on the most up-to-date version of the\nproject.\n\nGitHub is a cloud-based platform\nwhere you can store, share, and work together with others to write code.\nYou can think of Git as the engine that GitHub runs on.\nStoring your code in a “repository” on GitHub allows you to:\n\nShowcase or share your work.\nTrack and manage changes to your code over time.\nLet others review your code, and make suggestions to improve\nit.\nCollaborate on a shared project, without worrying that your changes\nwill impact the work of your collaborators before you’re ready to\nintegrate them.\n\nWhen you upload files to GitHub, you’ll store them in a “Git\nrepository.” This means that when you make changes (or “commits”) to\nyour files in GitHub, Git will automatically start to track and manage\nyour changes.\nThere are plenty of Git-related actions that you can complete on\nGitHub directly in your browser, such as creating a Git repository,\ncreating branches, and uploading and editing files. But, most people\nwork on their files locally (on their own computer), then continually\nsync these local changes—and all the related Git data—with the central\n“remote” repository on GitHub. This is how we will interact with GitHub\nin this course, with the help of GitHub Desktop.\n\n\n\nGitHub Desktop Interface\n\n\nOnce you start to collaborate with others and all need to work on the\nsame repository at the same time, you’ll continually:\n\nPull all the latest changes made by your\ncollaborators from the remote repository on GitHub.\nPush back your own changes to the same remote\nrepository on GitHub.\n\nGit figures out how to intelligently merge this flow of changes, and\nGitHub helps you manage the flow through features such as “pull\nrequests.”\n\n\n\n\n\n\nNote\n\n\n\nWe will be sticking to GitHub’s tools for using Git, so you do not\nneed to install Git separately for this course. In the future, you may\nwant to spend some time understanding Git on its own, but for this\ncourse and most companies, understanding GitHub’s (below) workflows is\nmore important.\n\n\n\n3.1\nSetup GitHub\nFollow the guides in the order they are presented. Again, I recommend\nreading through the whole set of Get Started articles,\nbut these are the essentials for this course.\n\nCreating\nan account on GitHub\n\nUse your Mix account for the email. Your username doesn’t matter; I\nused Ozan Ozbeker - WVU. In this course, we will be using\nprivate repositories, but I recommend creating a personal account to add\nprojects for your resume. The final project of this class could be a\ngood start.\n\nHello\nWorld\n\nThis is the critical GitHub workflow, make sure you understand\nit.\n\nSetting\nup your profile\n\nThis will introduce you to using Markdown, which will be essential\nlater in this course and for formatting your READMEs.\n\n\n\n\n\n\n\n\nNote\n\n\n\nGitHub also provides hands-on exercises for many of their articles at\nGitHub Skills for free. I won’t\nrequire you to do any of these as I’m not sure how long they take, but\nthese ones may be of benefit: Introduction to\nGitHub, Communicate\nusing Markdown, Review pull\nrequests, & Resolve merge\nconflicts.\n\n\n\n\n3.2\nSetup GitHub Desktop\nGitHub Desktop is a free, open source application that helps you to\nwork with code hosted on GitHub or other Git hosting services. With\nGitHub Desktop, you can perform Git commands, such as committing and\npushing changes, in a graphical user interface, rather than using the\ncommand line.\nA typical workflow is:\n\nUse GitHub Desktop to download a GitHub repository to your computer\nand create a new branch.\nUse an editor such as Visual Studio Code to make changes to the\ncode.\nReturn to GitHub Desktop to commit and push the changes to\nGitHub.\n\nAgain, follow the guides in the order they are presented. Again x 2,\nI recommend reading through the whole set of Get\nStarted articles, but these are the essentials for this course.\n\nParts 1 & 2 of Getting\nstarted with GitHub Desktop\n\nThis guide, and all the following, will have specific steps for Mac\n& Windows.\n\nParts 2-5 of Creating\nyour first repository using GitHub Desktop\n\nThis will be similar to some parts of the GitHub (website) guides\nabove, that’s on purpose.",
    "crumbs": [
      "Learning Modules",
      "01 | Setting Up Your Workstation"
    ]
  },
  {
    "objectID": "learning-modules/01-setting-up-your-workstation.html#uv",
    "href": "learning-modules/01-setting-up-your-workstation.html#uv",
    "title": "01 | Setting Up Your Workstation",
    "section": "4 uv",
    "text": "4 uv\nSo far, we’ve only installed VS Code & GitHub Desktop, which are\ntools we need for this course, but they are not specific to Python. Now\nwe will focus on installing Python as well as a few other tools that\nwill make our coding lives easier.\nuv is an extremely fast\nPython package and project manager. It is how we will manage our project\ndependencies, including Python itself.\n\n\n\n\n\n\nNote\n\n\n\nFrom this point, all of the installation will be done via the command\nline.\n\n\n\n4.1\nInstallation\nYou can install uv using PowerShell on Windows:\n\n\nCLI\n\n$ powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\nAnd curl on macOS:\n\n\nCLI\n\n$ curl -LsSf https://astral.sh/uv/install.sh | sh\n\n\n\n\n\n\n\nImportant\n\n\n\nAt this point, you need to restart your shell, which means close your\nterminal and open it again.\n\n\nNow, we check to see that uv is available by running the\nuv command:\n\n\nCLI\n\n$ uv --version\n\n\n\noutput\n\nuv 0.5.20 (1c17662b3 2025-01-15)\n\nWith that confirmation, we will now install Python to be used across\nthe system:\n\n\nCLI\n\n$ uv python install 3.12\n\nThen you can use uv python list to verify the\ninstallation went through:\n\n\nCLI\n\n$ uv python list\n\nYou will see list of the available versions of Python uv can download\nas well as where Python 3.12 was installed.\n\n\n4.2\nUsing uv\nTo fully appreciate the benefits of uv and why we are using it, it’s\nessential to understand Python environments, virtual environments, and\nhow uv simplifies these concepts through its Projects\ninterface.\nuv provides two ways to handle dependencies (a dependency is any\nextra package your project needs that doesn’t come with Python by\ndefault). The preferred approach is the uv project\ninterface, which includes commands like uv init,\nuv add, uv lock, and more. While uv also\nincludes an implementation of pip, we will not be using it\nin this course.\n\n\n\n\n\n\nTip\n\n\n\nUsing uv projects has fewer commands and guides you toward best\npractices, much like how GitHub Desktop simplifies workflows compared to\nthe full Git CLI tools.\n\n\nWhen we installed Python 3.12 earlier using\nuv python install 3.12, we were not in a project. As a\nresult, Python was installed into uv’s default environment. On most\nWindows systems, this environment is located at\nAppData/Roaming/uv/python/cpython-3.12.8-windows-x86_64-none/python.exe.\nHowever, you don’t need to worry about its location—uv manages it for\nyou.\nTo add dependencies to a project using uv, we use the command\nuv add [package]. Let’s try downloading Polars, a library we’ll use in the second\nhalf of this course:\n\n\nCLI\n\n$ uv add polars\n\n\n\noutput\n\nerror: No `pyproject.toml` found in current directory or any parent directory\n\nWe encountered an error! This happened because we’re not in a\nproject. This is one of the many guardrails uv provides when using its\nproject interface. If we had used uv pip install polars, we\ncould have installed the package into the default (global) environment.\nHowever, since this is considered bad practice, uv actively discourages\nit.\nInstead, uv projects leverage virtual\nenvironments using Python’s built-in venv module.\nEssentially, each project has its own dependencies without interfering\nwith others. This isolation prevents version conflicts and keeps your\nprojects organized.\nuv projects also provide a significant advantage: caching. When you\nuse the same dependency across multiple projects, uv only downloads it\nonce and stores it in a cache. For future projects, it reuses the cached\nfiles instead of downloading and installing them again. This drastically\nreduces disk space usage and installation time, especially when working\nwith large or repeated dependencies. For this course, where each Lab\n& Test will be its own uv project, this feature will save us\nconsiderable time.\nWe’ll get hands-on experience with uv projects in the the Lab, but\nyou can look at the official Working on\nprojects guide if you would like.",
    "crumbs": [
      "Learning Modules",
      "01 | Setting Up Your Workstation"
    ]
  },
  {
    "objectID": "learning-modules/01-setting-up-your-workstation.html#ruff",
    "href": "learning-modules/01-setting-up-your-workstation.html#ruff",
    "title": "01 | Setting Up Your Workstation",
    "section": "5\nRuff",
    "text": "5\nRuff\nMany Python packages provide applications that can be used as tools.\nuv has specialized support for easily invoking and installing tools. Ruff is an extremely fast Python\nlinter and code formatter, made by the creators of uv.\n\n5.1\nInstallation\nYou can install Ruff with:\n\n\nCommand Line\n\n$ uv tool install ruff\n\n\n\n5.2\nUsing Ruff\nRuff’s two main features are its linter and formatter.\nA linter analyzes your code for potential errors,\nbad practices, or violations of style rules. It can give warnings or\nerrors, but it won’t change your code automatically. It’s essentially a\nspellchecker for your code, pointing out what’s wrong without fixing\nit.\nA formatter automatically adjusts the layout and\nstyle of your code to match a predefined set of rules. It produces\nclean, consistently styled code by modifying it directly.\n\n\n5.3\nRuff’s linter\nruff check is the primary entrypoint to the Ruff linter.\nIt accepts a list of files or directories, and lints all discovered\nPython files, optionally fixing any fixable errors:\n\n\nCommand Line\n\nruff check # Lint all files in the current directory.\nruff check path/to/code/ # Lint all files in `path/to/code` (and any subdirectories).\n\nRuff supports automatic fixes for a variety of lint errors. For\nexample, Ruff can remove unused imports, reformat docstrings, rewrite\ntype annotations to use newer Python syntax, and more.\nTo enable fixes, pass the --fix flag to ruff check:\n\n\nCommand Line\n\nruff check --fix # Lint all files in the current directory, and fix any fixable errors.\n\nI don’t recommend using automatic fixes as it can help develop bad\nhabits in coding. Using the Ruff linter to find mistakes is good, but\nyou should work on not making the mistakes to begin with.\n\n\n5.4\nRuff’s formatter\nruff format is the primary entrypoint to the formatter.\nIt accepts a list of files or directories, and formats all discovered\nPython files:\n\n\nCommand Line\n\nruff format # Format all files in the current directory.\nruff format path/to/code/ # Format all files in `path/to/code` (and any subdirectories).\nruff format path/to/file.py # Format a single file.\n\nRun the linter first to identify and fix any errors, then use the\nformatter to clean up your code’s style. While you’re free to choose any\ncode style (as long as it’s syntactically valid), adhering to a standard\nmakes it easier to learn best practices and collaborate with others.\nFollowing a standard format also helps minimize unnecessary diffs in\nyour GitHub changes.",
    "crumbs": [
      "Learning Modules",
      "01 | Setting Up Your Workstation"
    ]
  },
  {
    "objectID": "learning-modules/01-setting-up-your-workstation.html#marimo",
    "href": "learning-modules/01-setting-up-your-workstation.html#marimo",
    "title": "01 | Setting Up Your Workstation",
    "section": "6\nmarimo",
    "text": "6\nmarimo\nThe final tool we’ll be installing is marimo. marimo is an open-source reactive notebook\nfor Python — reproducible, git-friendly, executable as a script, and\nshareable as an app.\n\n6.1\nInstallation\nYou can install marimo with:\n\n\nCommand Line\n\n$ uv tool install marimo\n\n\n\n6.2 Why\nmarimo (over VS Code)\nWe already installed VS Code, why am I making you install another\ntool to use Python with? I’m glad you asked.\nThe main difference between traditional Python programming in tools\nlike VS Code vs interactive notebooks like marimo (or Jupyter Notebook)\nis how you write and run your code. In VS Code, you typically write your\nentire script in a .py file and run the whole program at\nonce, with the output appearing in a terminal or console. This approach\nis great for building full applications, like downloading data,\nautomatically refreshing a dashboard, or scraping a website. On the\nother hand, interactive notebooks allow you to write and execute code in\nsmaller chunks, or cells, and see the results (including graphs or\ntables) immediately beside the code. This makes notebooks ideal for data\nanalysis, visualization, prototyping, and/or teaching, as they encourage\nexperimentation and provide instant feedback.\nWhile VS Code is better suited for maintaining well-organized,\nmodular code, notebooks excel in scenarios that involve step-by-step\nexploration and explanation. They serve different purposes, but are\ncomplementary.\n\n\n\n\n\n\nNote\n\n\n\nA typical workflow in industry is using notebooks to explore new\ndata, experiment with visuals, try models, and so on. Once the code is\nin a stable state, the code in the notebook will be turned into a Python\npackage or\nmodule to be used in production (software\nengineering loves to use manufacturing terms.).\n\n\n\n\n6.3 Why\nmarimo (over Jupyter Notebook)\nWe already covered why we may want to use a notebook instead of a\nregular IDE like VS Code, so why marimo over Jupyter?\nmarimo is the new kid on the block when it comes to comes to coding\nnotebooks. Jupyter has been the\nstandard for interactive computing for years now, and absolutely\ndeserves its flowers.\nFrom the marimo FAQ: marimo\nis a reinvention of the Python notebook as a reproducible, interactive,\nand shareable Python program that can be executed as scripts or deployed\nas interactive web apps.\n\nConsistent state: In marimo, your notebook code,\noutputs, and program state are guaranteed to be consistent. Run a cell\nand marimo reacts by automatically running the cells that reference its\nvariables. Delete a cell and marimo scrubs its variables from program\nmemory, eliminating hidden state.\nBuilt-in interactivity: marimo also comes with UI\nelements like sliders, a DataFrame transformer, and interactive plots\nthat are automatically synchronized with Python. Interact with an\nelement and the cells that use it are automatically re-run with its\nlatest value.\nPure Python programs: Unlike Jupyter notebooks,\nmarimo notebooks are stored as pure Python files that can be executed as\nscripts, deployed as interactive web apps, and versioned easily with\nGit.\n\n\n\n6.4\nLearning marimo\nFeel free to look at the User Guide, but we will be\ngoing through their interactive tutorials in a later Lab.\nYou can see some examples of marimo notebooks at their gallery.",
    "crumbs": [
      "Learning Modules",
      "01 | Setting Up Your Workstation"
    ]
  },
  {
    "objectID": "learning-modules/01-setting-up-your-workstation.html#gurobi-optimizer",
    "href": "learning-modules/01-setting-up-your-workstation.html#gurobi-optimizer",
    "title": "01 | Setting Up Your Workstation",
    "section": "7 Gurobi\nOptimizer",
    "text": "7 Gurobi\nOptimizer\nSo far, you’ve set up your environment for Python development with\nuv, installed GitHub Desktop for version control, and learned about\nmarimo for notebooks. The final piece in our optimization puzzle is\nGurobi, a leading commercial solver that is free for\nacademic use.\nGurobi is a powerful\nmathematical programming solver capable of handling linear, integer, and\nother advanced optimization models. In this course, we’ll use Gurobi\nprimarily through its Python API, gurobipy, to solve supply\nchain network design problems more efficiently than is possible with\nExcel Solver alone.\n\n7.1\nLicensing and Academic Access\nGurobi is commercial software, but it’s free for\nstudents and faculty at degree-granting institutions. To obtain a\nlicense:\n\nCreate a Gurobi Account\n\nGo to Gurobi’s Academic License page and sign up using your\nuniversity email.\nWait for an email verifying your academic license. Gurobi usually\ngrants these licenses quickly, but it can sometimes take a day or\ntwo.\n\nDownload and Install Gurobi\n\nOnce you have a Gurobi account, log in to the Gurobi Download Center\nto download the installer for your operating system (Windows, macOS, or\nLinux).\nRun the installer and follow the on-screen prompts. By default,\nGurobi installs to a folder like C:\\gurobi\\ on Windows or\n/Library/gurobi/ on macOS.\n\nActivate Your License\n\nAfter installation, open a terminal (PowerShell on Windows or the\nTerminal on macOS) and run:\n\n\n\n\nCommand Line\n\n$ grbgetkey YOUR-LICENSE-KEY\n\n\nReplace YOUR-LICENSE-KEY with the key from your Gurobi\naccount’s “My Account” page or from the email you received.\nThis will create a gurobi.lic file on your system,\ntypically located in your home directory.\n\n\n\n\n\n\n\nWarning\n\n\n\nMake sure you keep your gurobi.lic file in a safe\nlocation and don’t share it publicly. It contains your license\ncredentials.\n\n\n\n\n7.2\nInstalling the Gurobi Python API\nIn older versions, you had to rely on Gurobi’s custom installer for\nthe Python bindings. Fortunately, modern versions (Gurobi 9.5+) are also\navailable on PyPI under the name gurobipy. This means we\ncan install the Python API the same way we add other Python packages\n(covered in Lab 1). However, remember that you must\nstill install the main Gurobi solver (the previous step) for\ngurobipy to function.\n\n\n7.3\nGurobi Docs and Tutorials\nGurobi’s own documentation is excellent and well worth exploring:\n\nGurobi Documentation –\nofficial API references, tutorials, parameter guides.\nGurobi\nModeling Examples – real-world examples demonstrating how to set up\nand solve diverse optimization problems.\n\nIn later modules and labs, we’ll walk through building facility\nlocation, transportation, and transshipment models in Python using\nGurobi. For now, ensure you have the solver installed, licensed, and\nready to go so that you can focus on actual modeling in upcoming\nlessons.",
    "crumbs": [
      "Learning Modules",
      "01 | Setting Up Your Workstation"
    ]
  },
  {
    "objectID": "learning-modules/01-setting-up-your-workstation.html#finish",
    "href": "learning-modules/01-setting-up-your-workstation.html#finish",
    "title": "01 | Setting Up Your Workstation",
    "section": "8\nFinish",
    "text": "8\nFinish\nThat’s it! With Gurobi in place, you now have the\ncomplete environment for writing and running optimization models in\nPython. The next modules will be more hands-on, so don’t worry if the\nsetup process feels tedious. Proper installation and licensing of Gurobi\nis crucial to ensure everything runs smoothly later.",
    "crumbs": [
      "Learning Modules",
      "01 | Setting Up Your Workstation"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "",
    "text": "So far, we’ve used Python’s built-in functions. In this module,\nyou’ll learn to create and run your own functions, and see how one\nfunction can call another. We’ll also introduce the for\nloop to repeat computations and the if statement to execute different\ncode based on program state. Finally, we’ll learn how to handle external\nfiles, update variables, and perform searches in strings.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#overview",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#overview",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "",
    "text": "So far, we’ve used Python’s built-in functions. In this module,\nyou’ll learn to create and run your own functions, and see how one\nfunction can call another. We’ll also introduce the for\nloop to repeat computations and the if statement to execute different\ncode based on program state. Finally, we’ll learn how to handle external\nfiles, update variables, and perform searches in strings.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#defining-new-functions",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#defining-new-functions",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "2\nDefining new functions",
    "text": "2\nDefining new functions\nA function definition specifies the name of a new\nfunction and the sequence of statements that run when the function is\ncalled:\n\ndef print_lyrics():\n    print(\"Almost Heaven, West Virginia\")\n    print(\"Blue Ridge Mountains, Shenandoah River\")\n\ndef is a keyword that indicates a function definition.\nThe name of this function is print_lyrics. The empty\nparentheses after the name indicate that this function doesn’t take any\narguments.\nThe first line of the function definition is the\nheader, and the rest is the body. The\nheader must end with a colon, and the body must be indented (by\nconvention, four spaces). The body of this function is two\nprint() statements, but in general, the body can include\nany number of statements.\nDefining a function creates a function object, which\nyou can display:\n\nprint_lyrics\n\n&lt;function __main__.print_lyrics()&gt;\n\n\nThe output shows that print_lyrics takes no arguments.\n__main__ is the name of the module that contains\nprint_lyrics.\nYou can call this function the same way as any other Python\nfunction:\n\nprint_lyrics()\n\nAlmost Heaven, West Virginia\nBlue Ridge Mountains, Shenandoah River",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#parameters",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#parameters",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "3\nParameters",
    "text": "3\nParameters\nSome of the functions we’ve seen require arguments:\nabs() takes a number, and math.pow() takes two\narguments (the base and the exponent). We can make our own:\n\ndef print_twice(string):\n    print(string)\n    print(string)\n\nThe variable in parentheses is called a parameter.\nWhen the function is called, the value of the argument is assigned to\nthe parameter. For example:\n\nprint_twice(\"Hail WV!\")\n\nHail WV!\nHail WV!\n\n\nThis has the same effect as assigning the argument to the parameter\nand then executing the body:\n\nstring = \"Hail WV!\"\nprint(string)\nprint(string)\n\nHail WV!\nHail WV!\n\n\nYou can also pass a variable as an argument:\n\nline = \"Hail WV!\"\nprint_twice(line)\n\nHail WV!\nHail WV!",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#calling-functions",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#calling-functions",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "4 Calling\nfunctions",
    "text": "4 Calling\nfunctions\nOnce you define a function, you can use it inside another. Here’s a\nplayful example of printing lyrics for “Turn\nDown For What” by DJ Snake & Lil Jon:\nVerse:\nFire up that loud\nAnother round of shots\n\nChorus:\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n\nBuild:\nshots! shots! shots! shots!\nshots! shots! shots! shots!\nshots! shots! shots! shots!\nshots! shots! shots! shots!\nAs Lil Jon suggests, we need to buy a lot of rounds of shots. We can\nstart with a helper function:\n\ndef repeat(word, n):\n    print(word * n)\n\n\nrepeat(\"shots! \", 3)\n\nshots! shots! shots! \n\n\n\ndef print_build():\n    repeat(\"shots! \", 4)\n    repeat(\"shots! \", 4)\n    repeat(\"shots! \", 4)\n    repeat(\"shots! \", 4)\n\nprint_build()\n\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n\n\nprint_build() calls repeat(), which then\ncalls print(). We could do the same with fewer functions,\nbut this illustrates how functions can work together.\nIf we want to control how many times repeat() repeats,\nwe add a parameter to print_build():\n\ndef print_build(n):\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n\nThen we can call:\n\nprint_build(4)\n\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n\n\nNext, let’s add verse and chorus functions:\n\ndef print_verse():\n    print(\"Fire up that loud\")\n    print(\"Another round of shots\")\n\nprint_verse()\n\nFire up that loud\nAnother round of shots\n\n\n\ndef print_chorus():\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n\nprint_chorus()\n\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n\n\nNow bring it all together:\n\nprint_verse()\nprint_chorus()\nprint_verse()\nprint_chorus()\nprint_build(4)\n\nFire up that loud\nAnother round of shots\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nFire up that loud\nAnother round of shots\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n\n\nWe’re repeating some lines of code explicitly, which isn’t ideal.\nWe’ll address that soon.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#repetition",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#repetition",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "5\nRepetition",
    "text": "5\nRepetition\nTo print something multiple times, you can use a for\nloop. Here’s a simple example:\n\nfor i in range(2):\n    print(i)\n\n0\n1\n\n\nrange(2) creates a sequence of two values:\n0 and 1. The loop assigns each value to\ni and then runs the body. When the sequence ends, the loop\nends.\nHere’s a loop that prints the verse twice:\n\nfor i in range(2):\n    print(\"Verse\", i)\n    print_verse(),\n    print() # adds a blank line\n\nVerse 0\nFire up that loud\nAnother round of shots\n\nVerse 1\nFire up that loud\nAnother round of shots\n\n\n\nA for loop can appear inside a function, such as this\none that prints the verse m times:\n\ndef print_m_verse(m):\n    for i in range(m):\n        print_verse()\n\nprint_m_verse(4)\n\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\n\n\nIn this example, we don’t use i in the body of the loop,\nbut there has to be a variable in the header anyway.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#variables-and-parameters-are-local",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#variables-and-parameters-are-local",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "6\nVariables and parameters are local",
    "text": "6\nVariables and parameters are local\nA variable created inside a function is local,\nmeaning it only exists inside that function. Here’s an example:\n\ndef cat_twice(part_1, part_2):\n    cat = part_1 + part_2\n    print_twice(cat)\n\n\nline_1 = \"Country roads, \"\nline_2 = \"take me home.\"\ncat_twice(line_1, line_2)\n\nCountry roads, take me home.\nCountry roads, take me home.\n\n\nInside cat_twice(), cat is created. Outside of it,\ncat doesn’t exist:\n\nprint(cat)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 print(cat)\n\nNameError: name 'cat' is not defined\n\n\n\nParameters are also local. Outside cat_twice(),\npart_1 and part_2 don’t exist.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#tracebacks",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#tracebacks",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "7\nTracebacks",
    "text": "7\nTracebacks\nWhen a runtime error occurs inside a function, Python shows a\ntraceback, listing the function that was running, the\nfunction that called it, and so on, up the “stack.” Here’s a\nprint_twice() that tries to print cat, which\nis a local variable in a different function:\n\ndef print_twice(string):\n    print(cat)              # NameError\n    print(cat)\n\n\ncat_twice(line_1, line_2)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[23], line 1\n----&gt; 1 cat_twice(line_1, line_2)\n\nCell In[19], line 3, in cat_twice(part_1, part_2)\n      1 def cat_twice(part_1, part_2):\n      2     cat = part_1 + part_2\n----&gt; 3     print_twice(cat)\n\nCell In[22], line 2, in print_twice(string)\n      1 def print_twice(string):\n----&gt; 2     print(cat)              # NameError\n      3     print(cat)\n\nNameError: name 'cat' is not defined\n\n\n\nThe traceback shows that cat_twice() called\nprint_twice(), which caused the error.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#refactoring",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#refactoring",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "8\nRefactoring",
    "text": "8\nRefactoring\nLet’s reorganize our “Turn Down for What” example to avoid repeated\ncode. This is called refactoring.\n\n# Original\ndef print_build(n):\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n    repeat(\"shots! \", n)\n\n# Improved\ndef print_build(repeats, shots):\n    for i in range(repeats):\n        repeat(\"shots! \", shots)\n\nprint_build(4, 4)\n\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n\n\n\n# Original\ndef print_verse():\n    print(\"Fire up that loud\")\n    print(\"Another round of shots\")\n\n# Improved\ndef print_verse(lines):\n    for i in range(lines):\n        print(\"Fire up that loud\")\n        print(\"Another round of shots\")\n\nprint_verse(4)\n\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\n\n\n\n# Original\ndef print_chorus():\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n    print(\"Turn down for what?\")\n\n# Improved\ndef print_chorus(lines):\n    for i in range(lines):\n        print(\"Turn down for what?\")\n\nprint_chorus(6)\n\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n\n\nPutting it all together:\n\nprint_verse(1)\nprint()\nprint_chorus(5)\nprint()\nprint_verse(1)\nprint()\nprint_chorus(5)\nprint()\nprint_verse(4)\nprint()\nprint_build(6, 4)\nprint()\nprint_chorus(5)\n\nFire up that loud\nAnother round of shots\n\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n\nFire up that loud\nAnother round of shots\n\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\nFire up that loud\nAnother round of shots\n\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\nTurn down for what?\n\n\nRefactoring improves the code’s structure without changing its\nbehavior. If we had planned the structure from the start, we might have\navoided this step, but sometimes you only see a better design after you\nstart coding.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#why-functions",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#why-functions",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "9 Why\nfunctions?",
    "text": "9 Why\nfunctions?\n\nReadability: Naming groups of statements makes code\neasier to read and debug.\nReusability: Functions eliminate repetitive code.\nChanges become easier to manage.\nModularity: Breaking down a program into functions\nlets you debug parts individually.\nReuse: Well-designed functions can be used by other\nprograms.\n\nWrapping code in a function is called encapsulation.\nOne advantage is that a name serves as documentation. Another is that\ncalling a function is more concise than copying and pasting its\nbody.\nAdding parameters to a function is called\ngeneralization, because it makes the function more\ngeneral – for example, printing \"shots!\" any number of\ntimes.\nWhen a function has several numerical arguments, it’s easy to mix\nthem up. You can use keyword arguments to specify each\nargument by name:\n\ndef print_build(repeats, shots):\n    for i in range(repeats):\n        repeat(\"shots! \", shots)\n\nprint_build(repeats=8, shots=4)\nprint()\nprint_build(shots=4, repeats=8)\n\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \n\nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots! \nshots! shots! shots! shots!",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#docstrings",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#docstrings",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "10\nDocstrings",
    "text": "10\nDocstrings\nA docstring is a string at the start of a function\nthat explains its interface:\n\ndef print_build(repeats, shots):\n    \"\"\"Prints \"shots\" for a custom amount of times and lines\n\n    repeats: number of lines of lyrics\n    shots: number of times \"shots\" is printed per line\n    \"\"\"\n    for i in range(repeats):\n        repeat(\"shots! \", shots)\n\nA good docstring explains what the function does and the effect of\neach parameter, without diving into internal details.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#if-statements",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#if-statements",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "11\nif statements",
    "text": "11\nif statements\nConditional statements let you check conditions and\nchange the program’s behavior. The simplest form is the if\nstatement:\nif x &gt; 0:\n    print('x is positive')\nThe boolean expression after if is called the condition.\nIf it’s true, Python executes the indented block; otherwise, it skips\nit.\nIf you need a block that does nothing, use pass:\nif x &lt; 0:\n    pass          # TODO: need to handle negative values!",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#boolean-expressions-and-logical-operators",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#boolean-expressions-and-logical-operators",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "12\nBoolean expressions and logical operators",
    "text": "12\nBoolean expressions and logical operators\nA boolean expression is either True or\nFalse. For instance:\n\n5 == 5\n\nTrue\n\n\n\n5 == 7\n\nFalse\n\n\nThe double equal sign == compares two values for\nequality.\n\n\n\n\n\n\nTip\n\n\n\nA common error is to use a single equal sign (=) instead\nof a double equal sign (==). Remember that =\nassigns a value to a variable and == compares two\nvalues.\n\n\nOther relational operators include:\nx != y # x is not equal to y\nx &gt; y  # x is greater than y\nx &lt; y  # x is less than to y\nx &gt;= y # x is greater than or equal to y\nx &lt;= y # x is less than or equal to y\nYou can combine boolean expressions with logical\noperators: and, or, and\nnot. For example:\nx &gt; 0 and x &lt; 10\nx % 2 == 0 or x % 3 == 0\nnot x &gt; y",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#the-else-clause",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#the-else-clause",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "13 The\nelse clause",
    "text": "13 The\nelse clause\nif can include an else clause:\nif x % 2 == 0:\n    print('x is even')\nelse:\n    print('x is odd')\nOne branch runs if the condition is true, the other if it’s\nfalse.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#chained-conditionals",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#chained-conditionals",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "14\nChained conditionals",
    "text": "14\nChained conditionals\nWhen you have more than two possibilities, use elif:\nif x &lt; y:\n    print('x is less than y')\nelif x &gt; y:\n    print('x is greater than y')\nelse:\n    print('x and y are equal')\nConditions are checked in order, and only the first true branch\nruns.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#nested-conditionals",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#nested-conditionals",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "15\nNested Conditionals",
    "text": "15\nNested Conditionals\nOne conditional can be nested within another, but it can be harder to\nread:\nif 0 &lt; x:\n    if x &lt; 10:\n        print('x is a positive single-digit number.')\nLogical operators often simplify nested conditionals:\nif 0 &lt; x and x &lt; 10:\n    print('x is a positive single-digit number.')\nFor this kind of condition, Python provides a more concise\noption:\nif 0 &lt; x &lt; 10:\n    print('x is a positive single-digit number.')",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#some-functions-have-return-values",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#some-functions-have-return-values",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "16 Some\nfunctions have return values",
    "text": "16 Some\nfunctions have return values\nFunctions like abs, round,\nmath.sqrt, and math.pow return a value. You\ncan assign that value to a variable or use it in an expression:\n\nimport math\nradius = math.sqrt(42 / math.pi)\narea = math.pi * radius**2\n\nYou can also write your own function with a return value:\n\ndef circle_area(radius):\n    area = math.pi * radius**2\n    return area\n\n\na = circle_area(radius)\na\n\n42.00000000000001\n\n\nHowever, local variables inside a function (like area)\ndon’t exist outside that function.\n\narea\n\n42.00000000000001",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#and-some-have-none",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#and-some-have-none",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "17 And\nsome have None",
    "text": "17 And\nsome have None\nIf a function doesn’t use return, it returns\nNone, a special value:\n\ndef repeat(word, n):\n    print(word * n)\n\nThis function uses the print function to display a\nstring, but it does not use a return statement to return a\nvalue. If we assign the result to a variable, it displays the string\nanyway.\n\nresult = repeat('Shots! ', 3)\nprint(result)  # Displays None\n\nShots! Shots! Shots! \nNone\n\n\nIf you want a function that returns a string rather than prints it,\nyou can do:\n\ndef repeat_string(word, n):\n    return word * n\n\nNotice that we can use an expression in a return statement, not just\na variable.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#return-values-and-conditionals",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#return-values-and-conditionals",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "18\nReturn values and conditionals",
    "text": "18\nReturn values and conditionals\nA function can have multiple return statements, such as a\nreimplementation of abs:\n\ndef absolute_value(x):\n    if x &lt; 0:\n        return -x\n    else:\n        return x\n\nMake sure thath every possible path hits a return statement:\n\ndef absolute_value_wrong(x):\n    if x &lt; 0:\n        return -x\n    if x &gt; 0:\n        return x\n    # If x is 0, returns None (missing a final else branch)",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#boolean-functions",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#boolean-functions",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "19\nBoolean functions",
    "text": "19\nBoolean functions\nFunctions can return the boolean values True and\nFalse, which is often convenient for encapsulating a\ncomplex test in a function. For example, is_divisible\nchecks whether x is divisible by y with no remainder.\n\ndef is_divisible(x, y):\n    if x % y == 0:\n        return True\n    else:\n        return False\n\n\nis_divisible(6, 4)\n\nFalse\n\n\n\nis_divisible(6, 3)\n\nTrue\n\n\nInside the function, the result of the == operator is a\nboolean, so we can write the function more concisely by returning it\ndirectly:\n\ndef is_divisible(x, y):\n    return x % y == 0\n\nBoolean functions are often used in conditional statements:\n\nif is_divisible(6, 2):\n    print('divisible')\n\ndivisible\n\n\nIt might be tempting to write something like this:\n\nif is_divisible(6, 2) == True:\n    print('divisible')\n\ndivisible\n\n\nBut the comparison is unnecessary.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#input-validation",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#input-validation",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "20 Input\nvalidation",
    "text": "20 Input\nvalidation\nWe now have all the tools we need to make sure that the programs we\nwrite will be executed fully, regardless of user error.\nRemember, if the end use can mess up your instructions they will.\nSound familiar?\nLet’s go back to the example of calculating the volume of a sphere\nwith a succinct function using what we’ve learned so far:\n\ndef volume_of_sphere(radius):\n    from math import pi\n    return (4/3) * pi * radius**3\n\nIf radius is an integer or float, no problem. But if we get a string,\nwe will get an error:\n\nprint(volume_of_sphere(4))\nprint(volume_of_sphere(\"4\"))\n\n268.082573106329\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[48], line 2\n      1 print(volume_of_sphere(4))\n----&gt; 2 print(volume_of_sphere(\"4\"))\n\nCell In[47], line 3, in volume_of_sphere(radius)\n      1 def volume_of_sphere(radius):\n      2     from math import pi\n----&gt; 3     return (4/3) * pi * radius**3\n\nTypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'\n\n\n\nWhile the default error message gives the user an idea of what’s\nwrong, we can handle this more gracefully:\n\ndef volume_of_sphere(radius):\n    if type(radius) == int or type(radius) == float:\n        from math import pi\n        return (4/3) * pi * radius**3\n    else:\n        print(\"Input was not a number, try again.\")\n        return None\n\nvolume_of_sphere(\"5\")\n\nInput was not a number, try again.\n\n\nIf this were a standalone program, it would return a result instead\nof stopping execution with an error.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#debugging",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#debugging",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "21\nDebugging",
    "text": "21\nDebugging\nDebugging can be frustrating, but it is also challenging,\ninteresting, and sometimes even fun. And it is one of the most important\nskills you can learn.\nIn some ways debugging is like detective work. You are given clues\nand you have to infer the events that led to the results you see.\nDebugging is also like experimental science. Once you have an idea\nabout what is going wrong, you modify your program and try again. If\nyour hypothesis was correct, you can predict the result of the\nmodification, and you take a step closer to a working program. If your\nhypothesis was wrong, you have to come up with a new one.\nFor some people, programming and debugging are the same thing; that\nis, programming is the process of gradually debugging a program until it\ndoes what you want. The idea is that you should start with a working\nprogram and make small modifications, debugging them as you go.\nIf you find yourself spending a lot of time debugging, that is often\na sign that you are writing too much code before you start tests. If you\ntake smaller steps, you might find that you can move faster.\n\nWhen a syntax or runtime error occurs, the error message contains a\nlot of information, but it can be overwhelming. The most useful parts\nare usually:\n\nWhat kind of error it was, and\nWhere it occurred.\n\nSyntax errors are usually easy to find, but there are a few gotchas.\nErrors related to spaces and tabs can be tricky because they are\ninvisible and we are used to ignoring them.\n\nx = 5\n y = 6\n\n\n  Cell In[50], line 2\n    y = 6\n    ^\nIndentationError: unexpected indent\n\n\n\n\nIn this example, the problem is that the second line is indented by\none space. But the error message points to y, which is\nmisleading. Error messages indicate where the problem was discovered,\nbut the actual error might be earlier in the code.\nThe same is true of runtime errors. For example, suppose you are\ntrying to convert a ratio to decibels, like this:\n\nimport math\nnumerator = 9\ndenominator = 10\nratio = numerator // denominator\ndecibels = 10 * math.log10(ratio)\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[51], line 5\n      3 denominator = 10\n      4 ratio = numerator // denominator\n----&gt; 5 decibels = 10 * math.log10(ratio)\n\nValueError: math domain error\n\n\n\nThe error message indicates line 5, but there is nothing wrong with\nthat line. The problem is in line 4, which uses integer division instead\nof floating-point division – as a result, the value of\nratio is 0. When we call\nmath.log10, we get a ValueError with the\nmessage math domain error, because 0 is not in\nthe “domain” of valid arguments for math.log10, because the\nlogarithm of 0 is undefined.\nIn general, you should take the time to read error messages\ncarefully, but don’t assume that everything they say is correct.\n\nBreaking a large program into smaller functions creates natural\ncheckpoints for debugging. If a function is not working, there are three\npossibilities to consider:\n\nThere is something wrong with the arguments the function is getting\n– that is, a precondition is violated.\nThere is something wrong with the function – that is, a\npostcondition is violated.\nThe caller is doing something wrong with the return value.\n\nTo rule out the first possibility, you can add a print\nstatement at the beginning of the function that displays the values of\nthe parameters (and maybe their types). Or you can write code that\nchecks the preconditions explicitly.\n\n\n\n\n\n\nTip\n\n\n\nThis is a very basic version of logging.\n\n\nIf the parameters look good, you can add a print statement before\neach return statement and display the return value. If possible, call\nthe function with arguments that make it easy check the result.\nIf the function seems to be working, look at the function call to\nmake sure the return value is being used correctly – or used at all!\nAdding print statements at the beginning and end of a\nfunction can help make the flow of execution more visible for testing.\nFor example, here is a version of volume_of_sphere with\nprint statements:\n\ndef volume_of_sphere(radius):\n    if type(radius) == int or type(radius) == float:\n        print(f\"Radius is a valid type: {type(radius)}\") # Showing radius is fine\n        from math import pi\n        return (4/3) * pi * radius**3\n    else:\n        print(\"Input was not a number, try again.\") # In original example, showing radius was not fine\n        return None\n\n\nvol = volume_of_sphere(5)\nprint(vol)\n\nRadius is a valid type: &lt;class 'int'&gt;\n523.5987755982989\n\n\n\nvol = volume_of_sphere(\"5\")\nvol\n\nInput was not a number, try again.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/03-functions-flow-control-and-conditionals.html#exercises",
    "href": "learning-modules/03-functions-flow-control-and-conditionals.html#exercises",
    "title": "03 | Functions, Flow Control, & Conditionals",
    "section": "22\nExercises",
    "text": "22\nExercises\n\n22.1\nRight-Align Text\nWrite a function named print_right() that takes a string\nnamed text as a parameter and prints the string with enough\nleading spaces that the last letter of the string is in the 40th column\nof the display.\nHint: Use len(), +, and *.\nHere’s an example output:\nprint_right(\"Monty\")\nprint_right(\"Python's\")\nprint_right(\"Flying Circus\")\n                                   Monty\n                                Python's\n                           Flying Circus\n\n\n22.2\nDraw a Triangle\nWrite a function called triangle that takes a string and\nan integer, then draws a pyramid of the given height using copies of the\nstring. For example:\ntriangle(\"L\", 5)\nL\nLL\nLLL\nLLLL\nLLLLL\n\n\n22.3\nDraw a Rectangle\nWrite a function called rectangle that takes a string\nand two integers, then draws a rectangle of the given width and height\nusing copies of the string. For example:\nrectangle(\"[]\", 5, 4)\n[][][][][]\n[][][][][]\n[][][][][]\n[][][][][]\n\n\n22.4\nTriangle Tester\nWrite a function named is_triangle that takes three\nintegers as arguments and returns True or False depending on whether you\ncan form a triangle with those lengths. Use the rule:\n\nIf any of the three lengths is greater than the sum of the other two,\nthen you cannot form a triangle. Otherwise, you can. (If the sum of two\nlengths equals the third, they form what is called a “degenerate”\ntriangle.)\n\nHint: Use a chained conditional.\n\n\n22.5\nCheck “Between”\nWrite a boolean function is_between(x, y, z), that\nreturns True if \\(x &lt; y &lt;\nz\\) or if \\(z &lt; y &lt; x\\),\nand False otherwise.",
    "crumbs": [
      "Learning Modules",
      "03 | Functions, Flow Control, & Conditionals"
    ]
  },
  {
    "objectID": "learning-modules/05-intro-to-gurobipy.html",
    "href": "learning-modules/05-intro-to-gurobipy.html",
    "title": "05 | Introduction to Optimization with Gurobi\n(gurobipy)",
    "section": "",
    "text": "Linear Programming (LP) is a fundamental optimization technique that\nhelps decision-makers allocate limited resources optimally. In this\nmodule, we’ll explore how to formulate linear programming models,\nidentify their components, and solve them using both Excel Solver and\nPython with Gurobi.\nAfter completing this module, you will be able to:\n\nIdentify the three key components of a linear programming model\nFormulate linear programming models from problem descriptions\nDetermine whether a function is linear or nonlinear\nSolve linear programming problems using graphical methods\nImplement and solve LP models using Excel Solver\nImplement and solve LP models using Python with Gurobi\nInterpret the results of your optimization models",
    "crumbs": [
      "Learning Modules",
      "05 | Introduction to Optimization with Gurobi (gurobipy)"
    ]
  },
  {
    "objectID": "learning-modules/05-intro-to-gurobipy.html#overview",
    "href": "learning-modules/05-intro-to-gurobipy.html#overview",
    "title": "05 | Introduction to Optimization with Gurobi\n(gurobipy)",
    "section": "",
    "text": "Linear Programming (LP) is a fundamental optimization technique that\nhelps decision-makers allocate limited resources optimally. In this\nmodule, we’ll explore how to formulate linear programming models,\nidentify their components, and solve them using both Excel Solver and\nPython with Gurobi.\nAfter completing this module, you will be able to:\n\nIdentify the three key components of a linear programming model\nFormulate linear programming models from problem descriptions\nDetermine whether a function is linear or nonlinear\nSolve linear programming problems using graphical methods\nImplement and solve LP models using Excel Solver\nImplement and solve LP models using Python with Gurobi\nInterpret the results of your optimization models",
    "crumbs": [
      "Learning Modules",
      "05 | Introduction to Optimization with Gurobi (gurobipy)"
    ]
  },
  {
    "objectID": "learning-modules/05-intro-to-gurobipy.html#introduction-to-linear-programming",
    "href": "learning-modules/05-intro-to-gurobipy.html#introduction-to-linear-programming",
    "title": "05 | Introduction to Optimization with Gurobi\n(gurobipy)",
    "section": "2\nIntroduction to Linear Programming",
    "text": "2\nIntroduction to Linear Programming\nLinear Programming (LP) is a powerful optimization technique used to\nfind the best outcome in mathematical models with linear relationships.\nLP has wide applications in business and supply chain management,\nincluding:\n\nProduction planning and scheduling\nResource allocation\nTransportation and distribution problems\nFinancial portfolio optimization\nNetwork flow problems\n\n\n2.1\nWhat Makes a Problem Suitable for Linear Programming?\nA problem can be solved using linear programming if:\n\nThe objective (what you’re trying to maximize or minimize) can be\nexpressed as a linear function\nAll constraints can be expressed as linear inequalities or\nequations\nAll variables can take non-negative values (in standard form)\n\n\n\n2.2\nComponents of a Linear Programming Model\nEvery LP model consists of three essential components:\n\nDecision Variables: What you’re trying to decide\n(usually denoted as \\(X_1\\), \\(X_2\\), etc.)\nObjective Function: The goal you’re trying to\nmaximize or minimize (\\(profit\\), \\(cost\\), etc.)\nConstraints: Limitations on resources or\nrequirements that must be satisfied\n\n\n\n2.3\nLinear vs. Nonlinear Functions\nA linear function has the form:\n\\[y = a_1x_1 + a_2x_2 + ... + a_nx_n +\nb\\]\nWhere:\n\n\\(x_1, x_2, ..., x_n\\) are\nvariables\n\\(a_1, a_2, ..., a_n, b\\) are\nconstants\n\nIn a linear function:\n\nVariables appear only to the first power (no squares, cubes,\netc.)\nVariables don’t multiply or divide each other\nThere are no transcendental functions (log, sin, etc.) of\nvariables\n\nExamples of linear functions:\n\n\\(y = 2.5x + 5\\)\n\\(y = -x + 5\\)\n\\(y = 5\\) (constant function)\n\\(x = 5\\) (can be rewritten as\n\\(1x = 5\\))\n\nExamples of nonlinear functions:\n\n\\(y = 2x^2\\) (variables raised to\npowers other than 1)\n\\(y = 3x/(2x+1)\\) (variables\ndividing each other)\n\\(y = 3x*(2x+1)\\) (variables\nmultiplying each other)",
    "crumbs": [
      "Learning Modules",
      "05 | Introduction to Optimization with Gurobi (gurobipy)"
    ]
  },
  {
    "objectID": "learning-modules/05-intro-to-gurobipy.html#the-wyndor-glass-co.-problem",
    "href": "learning-modules/05-intro-to-gurobipy.html#the-wyndor-glass-co.-problem",
    "title": "05 | Introduction to Optimization with Gurobi\n(gurobipy)",
    "section": "3 The\nWyndor Glass Co. Problem",
    "text": "3 The\nWyndor Glass Co. Problem\nLet’s examine a classic LP problem that we’ll use throughout this\nmodule. The Wyndor Glass Company produces high-quality glass products in\nthree plants and is considering launching two new products:\n\nAluminum-framed glass doors (Product 1)\nWood-framed windows (Product 2)\n\nEach plant has a limited number of production hours available per\nweek:\n\nPlant 1: 4 hours available for Product 1 only\nPlant 2: 12 hours available for Product 2 only\nPlant 3: 18 hours available for both products\n\nThe company earns:\n\n$3,000 profit per batch of Product 1\n$5,000 profit per batch of Product 2\n\nThe problem: How many batches of each product should Wyndor produce\nweekly to maximize profit?\n\n3.1\nFormulating the Wyndor Glass LP Model\n\nDecision Variables:\n\n\\(X_1\\) = Number of batches of\nProduct 1 (aluminum-framed doors)\n\\(X_2\\) = Number of batches of\nProduct 2 (wood-framed windows)\n\nObjective Function:\n\nMaximize \\(Z = 3X_1 + 5X_2\\)\n(profit in thousands of dollars)\n\nConstraints:\n\nPlant 1: \\(1X_1 + 0X_2 \\leq 4\\)\n(hours available in Plant 1)\nPlant 2: \\(0X_1 + 2X_2 \\leq 12\\)\n(hours available in Plant 2)\nPlant 3: \\(3X_1 + 2X_2 \\leq 18\\)\n(hours available in Plant 3)\nNon-negativity: \\(X_1, X_2 \\geq 0\\)\n(can’t produce negative amounts)\n\n\nThis complete mathematical model represents our optimization\nproblem.",
    "crumbs": [
      "Learning Modules",
      "05 | Introduction to Optimization with Gurobi (gurobipy)"
    ]
  },
  {
    "objectID": "learning-modules/05-intro-to-gurobipy.html#solving-lp-models-graphically",
    "href": "learning-modules/05-intro-to-gurobipy.html#solving-lp-models-graphically",
    "title": "05 | Introduction to Optimization with Gurobi\n(gurobipy)",
    "section": "4 Solving\nLP Models Graphically",
    "text": "4 Solving\nLP Models Graphically\nFor LP problems with two decision variables, we can solve them\ngraphically by:\n\nPlotting each constraint on a graph\nIdentifying the feasible region (the area that satisfies all\nconstraints)\nFinding the optimal solution at one of the corner points of the\nfeasible region\n\n\n4.1\nSteps to Solve the Wyndor Glass Problem Graphically:\n\nPlot the constraints:\n\nPlant 1: \\(X_1 \\leq 4\\) (vertical\nline at \\(X_1 = 4\\))\nPlant 2: \\(X_2 \\leq 6\\) (horizontal\nline at \\(X_2 = 6\\))\nPlant 3: \\(3X_1 + 2X_2 \\leq 18\\)\n(line connecting points \\((6,0)\\) and\n\\((0,9)\\))\nNon-negativity: \\(X_1 \\geq 0\\) and\n\\(X_2 \\geq 0\\) (the positive\nquadrant)\n\nIdentify the feasible region:\n\nThe region bounded by these lines forms a polygon. Any point inside\nthis polygon represents a feasible solution.\n\nFind the optimal solution:\n\nThe optimal solution will be at one of the corner points of the\nfeasible region\nFor a maximization problem, we want the corner point that gives the\nhighest value of the objective function\n\n\nLet’s calculate the objective function value at each corner\npoint:\n\n\n\nCorner Point\n\\(X_1\\)\n\\(X_2\\)\n\\(Z = 3X_1 + 5X_2\\)\n\n\n\n\n(0,0)\n0\n0\n0\n\n\n(4,0)\n4\n0\n12\n\n\n(0,6)\n0\n6\n30\n\n\n(2,6)\n2\n6\n36\n\n\n\nThe optimal solution is \\(X_1 = 2\\),\n\\(X_2 = 6\\), which gives a maximum\nprofit of $36,000.\n\n\n4.2\nUsing Level Curves to Find the Optimal Solution\nAnother approach is to use level curves of the\nobjective function:\n\nDraw the level curve \\(Z = 3X_1 + 5X_2 =\nC\\) for some value of \\(C\\)\nIncrease \\(C\\) until the level\ncurve is about to leave the feasible region\nThe last point of contact is the optimal solution\n\nThis graphical method helps visualize how the optimal solution is\nfound, though it becomes impractical for problems with more than two\nvariables.\n\n\n4.3\nVisualization of the Wyndor Glass Problem\nLet’s visualize the solution to better understand the constraints and\noptimal point:\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create a new figure with a specific size for better visibility\nplt.figure(figsize=(7, 6))\n\n# Define the range for x and y axes\nx_range = np.linspace(0, 6, 100)\ny_range = np.linspace(0, 9, 100)\n\n# Create a meshgrid for contour plotting\nX, Y = np.meshgrid(x_range, y_range)\nZ = 3 * X + 5 * Y  # Objective function: 3x₁ + 5x₂\n\n# Plot the constraints\n# Constraint 1: x₁ ≤ 4 (Plant 1)\nplt.axvline(x=4, color='red', linestyle='-', linewidth=2, label='Plant 1: x₁ ≤ 4')\n\n# Constraint 2: x₂ ≤ 6 (Plant 2)\nplt.axhline(y=6, color='green', linestyle='-', linewidth=2, label='Plant 2: x₂ ≤ 6')\n\n# Constraint 3: 3x₁ + 2x₂ ≤ 18 (Plant 3)\n# Convert to y = mx + b form: y ≤ (18 - 3x₁)/2 = 9 - 1.5x₁\nconstraint3_y = lambda x: (18 - 3 * x) / 2\nplt.plot(x_range, [constraint3_y(x) for x in x_range], 'blue', \n            linestyle='-', linewidth=2, label='Plant 3: 3x₁ + 2x₂ ≤ 18')\n\n# Non-negativity constraints\nplt.axhline(y=0, color='black', linestyle='-', linewidth=1.5)\nplt.axvline(x=0, color='black', linestyle='-', linewidth=1.5)\n\n# Define the vertices of the feasible region\nfeasible_region_x = [0, 0, 2, 4, 4]\nfeasible_region_y = [0, 6, 6, 3, 0]\n\n# Shade the feasible region\nplt.fill(feasible_region_x, feasible_region_y, color='gray', alpha=0.2, label='Feasible Region')\n\n# Create contours for the objective function\ncontour_levels = np.arange(0, 45, 6)  # Levels at 0, 6, 12, 18, 24, 30, 36, 42\ncontour = plt.contour(X, Y, Z, levels=contour_levels, colors='purple', alpha=0.6)\nplt.clabel(contour, inline=True, fontsize=10, fmt='Z = %1.0f')\n\n# Mark the corner points of the feasible region and evaluate the objective function at each\ncorner_points = [(0, 0), (0, 6), (2, 6), (4, 3), (4, 0)]\ncorner_values = [3*x + 5*y for x, y in corner_points]\n\nfor i, point in enumerate(corner_points):\n    x, y = point\n    value = corner_values[i]\n    plt.plot(x, y, 'ko', markersize=8)  # Black dots for corner points\n    \n    # Add labels for each corner point with its coordinates and objective value\n    if point != (2, 6):  # Skip the optimal point as we'll label it differently\n        plt.annotate(f'({x}, {y}): Z = {value}', \n                    xy=point, xytext=(x+0.2, y+0.2),\n                    fontsize=10, arrowprops=dict(arrowstyle='-&gt;'))\n\n# Highlight the optimal solution\nplt.plot(2, 6, 'ro', markersize=12)  # Red dot for optimal solution\nplt.annotate(f'Optimal Solution (2, 6): Z = 36', \n                xy=(2, 6), xytext=(2.5, 7),\n                fontsize=12, fontweight='bold', color='red',\n                arrowprops=dict(facecolor='red', shrink=0.05))\n\n# Add axis labels and a title\nplt.xlabel('x₁ (Product 1: Doors)', fontsize=12)\nplt.ylabel('x₂ (Product 2: Windows)', fontsize=12)\nplt.title('Wyndor Glass Company Linear Programming Problem', fontsize=14, fontweight='bold')\n\n# Set the axis limits with some margin\nplt.xlim(-0.5, 6)\nplt.ylim(-0.5, 9)\n\n# Add a grid for better readability\nplt.grid(True, linestyle='--', alpha=0.6)\n\n# Add a legend\nplt.legend(loc='upper right', fontsize=10)\n\n# Add a text box explaining the problem\ntextbox_text = (\n    \"Wyndor Glass Company Problem:\\n\"\n    \"Maximize Z = 3x₁ + 5x₂\\n\"\n    \"Subject to:\\n\"\n    \"  x₁ ≤ 4 (Plant 1)\\n\"\n    \"  x₂ ≤ 6 (Plant 2)\\n\"\n    \"  3x₁ + 2x₂ ≤ 18 (Plant 3)\\n\"\n    \"  x₁, x₂ ≥ 0\"\n)\nplt.figtext(0.15, 0.02, textbox_text, fontsize=10, \n            bbox=dict(facecolor='white', alpha=0.7, boxstyle='round,pad=0.5'))\n\n# Make the layout tight\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Learning Modules",
      "05 | Introduction to Optimization with Gurobi (gurobipy)"
    ]
  },
  {
    "objectID": "learning-modules/05-intro-to-gurobipy.html#special-cases-in-linear-programming",
    "href": "learning-modules/05-intro-to-gurobipy.html#special-cases-in-linear-programming",
    "title": "05 | Introduction to Optimization with Gurobi\n(gurobipy)",
    "section": "5 Special\nCases in Linear Programming",
    "text": "5 Special\nCases in Linear Programming\nLinear programming problems can sometimes have special cases:\n\n5.1\nInfeasible Solution\nIf the constraints are contradictory, there’s no feasible region, and\nthe problem has no solution.\nExample: If we added a constraint \\(X_1 +\nX_2 ≥ 20\\) to the Wyndor problem, it would conflict with our\nother constraints, making the problem infeasible.\n\n\n5.2\nMultiple Optimal Solutions\nIf the objective function is parallel to one of the constraint\nboundaries, there could be infinitely many optimal solutions along that\nboundary.\nExample: If the Wyndor objective function were \\(Z = 3X_1 + 2X_2\\) (instead of \\(3X_1 + 5X_2\\)), there might be multiple\noptimal solutions.\n\n\n5.3\nUnbounded Solution\nIf the feasible region extends infinitely in the direction of\nimprovement for the objective function, the problem is unbounded.\nExample: If we removed the Plant 3 constraint from the Wyndor\nproblem, the profit could increase without limit by producing more of\nProduct 2.",
    "crumbs": [
      "Learning Modules",
      "05 | Introduction to Optimization with Gurobi (gurobipy)"
    ]
  },
  {
    "objectID": "learning-modules/05-intro-to-gurobipy.html#solving-lp-with-excel-solver",
    "href": "learning-modules/05-intro-to-gurobipy.html#solving-lp-with-excel-solver",
    "title": "05 | Introduction to Optimization with Gurobi\n(gurobipy)",
    "section": "6 Solving\nLP with Excel Solver",
    "text": "6 Solving\nLP with Excel Solver\nWhile graphical methods are educational, real-world problems\ntypically have many variables and constraints. We need computational\ntools like Excel Solver.\n\n6.1\nSetting Up the Wyndor Glass Problem in Excel\n\nCreate a spreadsheet with cells for:\n\nDecision variables (\\(X_1\\) and\n\\(X_2\\))\nObjective function calculation\nLeft-hand side of each constraint\nRight-hand side of each constraint\n\nSet up the Excel Solver:\n\nGo to Data tab → Solver\nSet Objective: Cell containing the objective function value\nBy Changing Variable Cells: Cells containing \\(X_1\\) and \\(X_2\\)\nSubject to the Constraints: Add each constraint\nSelect “Simplex LP” as the solving method\n\nClick Solve and review the solution\n\nExcel Solver will find:\n\n\\(X_1 = 2\\), \\(X_2 = 6\\)\nMaximum profit = $36,000\n\n\n\n6.2\nSensitivity Analysis in Excel Solver\nExcel Solver also provides sensitivity analysis, showing how changes\nin parameters affect the optimal solution:\n\nAfter solving, click on “Sensitivity Report”\nThis shows:\n\nShadow prices (dual values) for constraints\nAllowable increases/decreases for coefficients\n\n\nFor example, we can answer questions like:\n\nWhat if the profit of Product 2 decreases to $3,000?\nWhat if Plant 3 capacity increases by 2 hours?",
    "crumbs": [
      "Learning Modules",
      "05 | Introduction to Optimization with Gurobi (gurobipy)"
    ]
  },
  {
    "objectID": "learning-modules/05-intro-to-gurobipy.html#solving-lp-with-python-and-gurobi",
    "href": "learning-modules/05-intro-to-gurobipy.html#solving-lp-with-python-and-gurobi",
    "title": "05 | Introduction to Optimization with Gurobi\n(gurobipy)",
    "section": "7 Solving\nLP with Python and Gurobi",
    "text": "7 Solving\nLP with Python and Gurobi\nFor more complex problems or when integrating optimization into\nlarger systems, Python with the Gurobi solver provides a powerful\nalternative.\n\n7.1\nSetting Up the Wyndor Glass Problem in Python\nHere’s how to formulate and solve the Wyndor Glass problem using\nGurobi in Python:\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"wyndor\")\n\n# Create variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Product 1\nx2 = model.addVar(lb=0, name=\"x2\")  # Product 2\n\n# Set objective: Maximize 3x1 + 5x2\nmodel.setObjective(3 * x1 + 5 * x2, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(1 * x1 + 0 * x2 &lt;= 4, \"Plant1\")\nmodel.addConstr(0 * x1 + 2 * x2 &lt;= 12, \"Plant2\")\nmodel.addConstr(3 * x1 + 2 * x2 &lt;= 18, \"Plant3\")\n\n# Optimize model\nmodel.optimize()\n\n# Print solution\nif model.status == GRB.OPTIMAL:\n    print(\"Optimal solution found:\")\n    print(f\"X1 = {x1.x:.2f}, X2 = {x2.x:.2f}\")\n    print(f\"Optimal profit = ${model.objVal * 1000:.2f}\")\nelse:\n    print(\"No optimal solution found\")\n\nGurobi Optimizer version 12.0.1 build v12.0.1rc0 (win64 - Windows 11.0 (26100.2))\n\nCPU model: 13th Gen Intel(R) Core(TM) i9-13900H, instruction set [SSE2|AVX|AVX2]\nThread count: 14 physical cores, 20 logical processors, using up to 20 threads\n\nOptimize a model with 3 rows, 2 columns and 4 nonzeros\nModel fingerprint: 0xc030cf3a\nCoefficient statistics:\n  Matrix range     [1e+00, 3e+00]\n  Objective range  [3e+00, 5e+00]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [4e+00, 2e+01]\nPresolve removed 2 rows and 0 columns\nPresolve time: 0.00s\nPresolved: 1 rows, 2 columns, 2 nonzeros\n\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    4.5000000e+01   1.500000e+00   0.000000e+00      0s\n       1    3.6000000e+01   0.000000e+00   0.000000e+00      0s\n\nSolved in 1 iterations and 0.01 seconds (0.00 work units)\nOptimal objective  3.600000000e+01\nOptimal solution found:\nX1 = 2.00, X2 = 6.00\nOptimal profit = $36000.00\n\n\nThis code:\n\nCreates a Gurobi model\nAdds decision variables with lower bounds of 0\nSets the objective function to maximize profit\nAdds the three plant constraints\nSolves the model and prints the results\n\nThe solution will match what we found graphically and with Excel\nSolver: \\(X_1 = 2\\), \\(X_2 = 6\\), with a profit of $36,000.\n\n\n7.2\nSensitivity Analysis with Gurobi\nWe can also perform sensitivity analysis with Gurobi:\n\n# Get shadow prices (dual values)\nfor constr in model.getConstrs():\n    print(f\"{constr.ConstrName}: Shadow Price = {constr.Pi}\")\n\n# Get reduced costs\nfor var in model.getVars():\n    print(f\"{var.VarName}: Reduced Cost = {var.RC}\")\n\nPlant1: Shadow Price = 0.0\nPlant2: Shadow Price = 1.5\nPlant3: Shadow Price = 1.0\nx1: Reduced Cost = 0.0\nx2: Reduced Cost = 0.0",
    "crumbs": [
      "Learning Modules",
      "05 | Introduction to Optimization with Gurobi (gurobipy)"
    ]
  },
  {
    "objectID": "learning-modules/05-intro-to-gurobipy.html#another-example-apex-television-company",
    "href": "learning-modules/05-intro-to-gurobipy.html#another-example-apex-television-company",
    "title": "05 | Introduction to Optimization with Gurobi\n(gurobipy)",
    "section": "8 Another\nExample: Apex Television Company",
    "text": "8 Another\nExample: Apex Television Company\nLet’s look at another example: The Apex Television Company needs to\ndecide how many 60-inch and 42-inch TV sets to produce to maximize\nprofit.\n\nMarket limitations: At most 40 of the 60-inch sets and 10 of the\n42-inch sets can be sold per month\nAvailable work hours: 500 hours per month\nProduction requirements:\n\n60-inch set: 20 work-hours, $120 profit\n42-inch set: 10 work-hours, $80 profit\n\n\n\n8.1\nFormulating the Apex Television LP Model\n\nDecision Variables:\n\n\\(X_1\\) = Number of 60-inch sets\nproduced\n\\(X_2\\) = Number of 42-inch sets\nproduced\n\nObjective Function:\n\nMaximize \\(Z = 120X_1 + 80X_2\\)\n(profit in dollars)\n\nConstraints:\n\nMarket constraint for 60-inch: \\(X_1 \\leq\n40\\)\nMarket constraint for 42-inch: \\(X_2 \\leq\n10\\)\nWork hours: \\(20X_1 + 10X_2 \\leq\n500\\)\nNon-negativity: \\(X_1, X_2 \\geq\n0\\)\n\n\n\n\n8.2\nSolving the Apex Television Problem with Excel\nUsing Excel Solver as before, we would find:\n\n\\(X_1 = 20\\), \\(X_2 = 10\\)\nMaximum profit = $3,200\n\n\n\n8.3\nSolving the Apex Television Problem with Python and Gurobi\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"apex\")\n\n# Create variables\nx1 = model.addVar(lb=0, name=\"x1\")  # 60-inch TVs\nx2 = model.addVar(lb=0, name=\"x2\")  # 42-inch TVs\n\n# Set objective: Maximize 120x1 + 80x2\nmodel.setObjective(120 * x1 + 80 * x2, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 &lt;= 40, \"Market60\")\nmodel.addConstr(x2 &lt;= 10, \"Market42\")\nmodel.addConstr(20 * x1 + 10 * x2 &lt;= 500, \"WorkHours\")\n\n# Optimize model\nmodel.optimize()\n\n# Print solution\nif model.status == GRB.OPTIMAL:\n    print(\"Optimal solution found:\")\n    print(f\"X1 = {x1.x:.2f}, X2 = {x2.x:.2f}\")\n    print(f\"Optimal profit = ${model.objVal:.2f}\")\nelse:\n    print(\"No optimal solution found\")\n\nGurobi Optimizer version 12.0.1 build v12.0.1rc0 (win64 - Windows 11.0 (26100.2))\n\nCPU model: 13th Gen Intel(R) Core(TM) i9-13900H, instruction set [SSE2|AVX|AVX2]\nThread count: 14 physical cores, 20 logical processors, using up to 20 threads\n\nOptimize a model with 3 rows, 2 columns and 4 nonzeros\nModel fingerprint: 0xbc523b33\nCoefficient statistics:\n  Matrix range     [1e+00, 2e+01]\n  Objective range  [8e+01, 1e+02]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [1e+01, 5e+02]\nPresolve removed 3 rows and 2 columns\nPresolve time: 0.00s\nPresolve: All rows and columns removed\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    3.2000000e+03   0.000000e+00   0.000000e+00      0s\n\nSolved in 0 iterations and 0.01 seconds (0.00 work units)\nOptimal objective  3.200000000e+03\nOptimal solution found:\nX1 = 20.00, X2 = 10.00\nOptimal profit = $3200.00\n\n\n\n\n8.4\nVisualization of the Apex Television Problem\nLet’s visualize the solution to better understand the constraints and\noptimal point:\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create figure and axes\nfig, ax = plt.subplots(figsize=(7, 6))\n\n# Define the boundaries of the plot\nx1_range = np.linspace(0, 45, 100)\nx2_range = np.linspace(0, 15, 100)\nX1, X2 = np.meshgrid(x1_range, x2_range)\n\n# Plot the constraints\nax.plot(x1_range, np.zeros_like(x1_range), 'k-', lw=2)  # X2 = 0\nax.plot(np.zeros_like(x2_range), x2_range, 'k-', lw=2)  # X1 = 0\nax.plot(np.ones_like(x2_range) * 40, x2_range, 'r-', lw=2, label='X1 ≤ 40')  # X1 = 40\nax.plot(x1_range, np.ones_like(x1_range) * 10, 'g-', lw=2, label='X2 ≤ 10')  # X2 = 10\nax.plot(x1_range, (500 - 20 * x1_range) / 10, 'b-', lw=2, label='20X1 + 10X2 ≤ 500')  # Work hours\n\n# Shade the feasible region\nx1_vertices = [0, 0, 20, 25]\nx2_vertices = [0, 10, 10, 0]\nax.fill(x1_vertices, x2_vertices, alpha=0.2, color='gray')\n\n# Mark the optimal solution\nax.plot(20, 10, 'ro', markersize=10)\nax.annotate('Optimal (20, 10)', xy=(20, 10), xytext=(22, 10.5),\n            arrowprops=dict(facecolor='black', shrink=0.05))\n\n# Add objective function contour\nZ = 120 * X1 + 80 * X2\ncontours = ax.contour(X1, X2, Z, levels=np.linspace(500, 3200, 7), alpha=0.6, colors='purple')\nplt.clabel(contours, inline=True, fontsize=8, fmt='Z = %.0f')\n\n# Set plot limits and labels\nax.set_xlim(0, 45)\nax.set_ylim(0, 15)\nax.set_xlabel('X1 (60-inch TVs)')\nax.set_ylabel('X2 (42-inch TVs)')\nax.set_title('Apex Television LP Problem')\nax.grid(True)\nax.legend()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Learning Modules",
      "05 | Introduction to Optimization with Gurobi (gurobipy)"
    ]
  },
  {
    "objectID": "learning-modules/05-intro-to-gurobipy.html#summary",
    "href": "learning-modules/05-intro-to-gurobipy.html#summary",
    "title": "05 | Introduction to Optimization with Gurobi\n(gurobipy)",
    "section": "9\nSummary",
    "text": "9\nSummary\nLinear Programming is a powerful optimization technique with wide\napplications in supply chain management and operations. These skills\nprovide a foundation for more advanced optimization models that we’ll\nexplore in future modules, including network flow models, facility\nlocation problems, and integer programming.",
    "crumbs": [
      "Learning Modules",
      "05 | Introduction to Optimization with Gurobi (gurobipy)"
    ]
  },
  {
    "objectID": "learning-modules/05-intro-to-gurobipy.html#exercises",
    "href": "learning-modules/05-intro-to-gurobipy.html#exercises",
    "title": "05 | Introduction to Optimization with Gurobi\n(gurobipy)",
    "section": "10\nExercises",
    "text": "10\nExercises\n\n10.1\nProduction Planning\nA manufacturing plant produces two types of products: standard and\ndeluxe. Each standard product requires 4 hours of machining time and 2\nhours of assembly time. Each deluxe product requires 6 hours of\nmachining time and 3 hours of assembly time. The plant has 240 hours of\nmachining time and 120 hours of assembly time available per week. The\nprofit is $7 per standard product and $10 per deluxe product.\nFormulate this as an LP model and solve it using both Excel Solver\nand Python with Gurobi to determine the optimal production levels.",
    "crumbs": [
      "Learning Modules",
      "05 | Introduction to Optimization with Gurobi (gurobipy)"
    ]
  }
]